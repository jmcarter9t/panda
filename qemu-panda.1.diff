This is a diff between qemu 2.9.1 and panda master branch to examine the changes
that were made to get things working in panda.

Only in panda: build
Only in panda: build.sh
Only in panda/chardev: char-panda.c
Only in panda/chardev: char-panda.h

diff -bur qemu-2.9.1/chardev/Makefile.objs panda/chardev/Makefile.objs
--- qemu-2.9.1/chardev/Makefile.objs	2017-09-07 12:25:12.000000000 -0400
+++ panda/chardev/Makefile.objs	2020-01-22 10:59:21.890782321 -0500
@@ -13,5 +13,6 @@
 chardev-obj-y += char-socket.o
 chardev-obj-y += char-stdio.o
 chardev-obj-y += char-udp.o
+chardev-obj-y += char-panda.o
 chardev-obj-$(CONFIG_WIN32) += char-win.o
 chardev-obj-$(CONFIG_WIN32) += char-win-stdio.o

diff -bur qemu-2.9.1/configure panda/configure
--- qemu-2.9.1/configure	2017-09-07 12:25:12.000000000 -0400
+++ panda/configure	2020-01-22 10:59:21.890782321 -0500
@@ -94,6 +94,7 @@
     QEMU_CXXFLAGS=
     for arg in $QEMU_CFLAGS; do
         case $arg in
+            -std=*|\
             -Wstrict-prototypes|-Wmissing-prototypes|-Wnested-externs|\
             -Wold-style-declaration|-Wold-style-definition|-Wredundant-decls)
                 ;;
@@ -115,6 +116,13 @@
   do_cc $QEMU_CFLAGS $local_cflags -o $TMPE $TMPC $LDFLAGS $local_ldflags
 }
 
+compile_prog_cxx() {
+  local_cxxflags="$1"
+  local_ldflags="$2"
+  echo $cxx $QEMU_CFLAGS $local_cxxflags -o $TMPE $TMPC $LDFLAGS $local_ldflags >> config.log
+  $cxx $QEMU_CFLAGS $QEMU_CXXFLAGS $local_cxxflags -o $TMPE $TMPCXX $LDFLAGS $local_ldflags >> config.log 2>&1
+}
+
 # symbolically link $1 to $2.  Portable version of "ln -sf".
 symlink() {
   rm -rf "$2"
@@ -181,6 +189,8 @@
 libs_qga=""
 debug_info="yes"
 stack_protector=""
+llvm="no"
+llvmver="3.3"
 
 # Don't accept a target_list environment variable.
 unset target_list
@@ -201,7 +211,7 @@
 brlapi=""
 curl=""
 curses=""
-docs=""
+docs="no"
 fdt=""
 netmap="no"
 pixman=""
@@ -243,6 +253,7 @@
 EXESUF=""
 DSOSUF=".so"
 LDFLAGS_SHARED="-shared"
+LDFLAGS="-rdynamic $LDFLAGS"
 modules="no"
 prefix="/usr/local"
 mandir="\${prefix}/share/man"
@@ -254,7 +265,7 @@
 includedir="\${prefix}/include"
 sysconfdir="\${prefix}/etc"
 local_statedir="\${prefix}/var"
-confsuffix="/qemu"
+confsuffix="/panda"
 slirp="yes"
 oss_lib=""
 bsd="no"
@@ -284,7 +295,7 @@
 lzo=""
 snappy=""
 bzip2=""
-guest_agent=""
+guest_agent="no"
 guest_agent_with_vss="no"
 guest_agent_ntddscsi="no"
 guest_agent_msi=""
@@ -396,8 +407,8 @@
 # left shift of signed integers is well defined and has the expected
 # 2s-complement style results. (Both clang and gcc agree that it
 # provides these semantics.)
-QEMU_CFLAGS="-fno-strict-aliasing -fno-common -fwrapv $QEMU_CFLAGS"
-QEMU_CFLAGS="-Wall -Wundef -Wwrite-strings -Wmissing-prototypes $QEMU_CFLAGS"
+QEMU_CFLAGS="-fPIC -fno-strict-aliasing -fno-common -fwrapv $QEMU_CFLAGS"
+QEMU_CFLAGS="-Wall -Wwrite-strings -Wmissing-prototypes $QEMU_CFLAGS"
 QEMU_CFLAGS="-Wstrict-prototypes -Wredundant-decls $QEMU_CFLAGS"
 QEMU_CFLAGS="-D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE $QEMU_CFLAGS"
 QEMU_INCLUDES="-I. -I\$(SRC_PATH) -I\$(SRC_PATH)/include"
@@ -636,6 +647,7 @@
   # won't work when we're compiling with gcc as a C compiler.
   QEMU_CFLAGS="-DOS_OBJECT_USE_OBJC=0 $QEMU_CFLAGS"
   HOST_VARIANT_DIR="darwin"
+  LIBS="-lprotobuf-c -lprotobuf $LIBS"
   supported_os="yes"
 ;;
 SunOS)
@@ -693,6 +705,7 @@
   vhost_scsi="yes"
   vhost_vsock="yes"
   QEMU_INCLUDES="-I\$(SRC_PATH)/linux-headers -I$(pwd)/linux-headers $QEMU_INCLUDES"
+  LIBS="-ldl  -lprotobuf-c -lprotobuf  $LIBS"
   supported_os="yes"
 ;;
 *)
@@ -800,6 +813,8 @@
   ;;
   --target-list=*) target_list="$optarg"
   ;;
+  --extra-plugins-path=*) extra_plugins_path="$optarg"
+  ;;
   --enable-trace-backends=*) trace_backends="$optarg"
   ;;
   # XXX: backwards compatibility
@@ -935,6 +950,10 @@
   ;;
   --enable-bluez) bluez="yes"
   ;;
+  --enable-llvm) llvm="yes"
+  ;;
+  --with-llvm=*) llvmdir="$optarg"
+  ;;
   --disable-kvm) kvm="no"
   ;;
   --enable-kvm) kvm="yes"
@@ -1294,6 +1313,7 @@
   --target-list=LIST       set target list (default: build everything)
 $(echo Available targets: $default_target_list | \
   fold -s -w 53 | sed -e 's/^/                           /')
+  --extra-plugins-path=PATH also compile plugins at this PATH
 
 Advanced options (experts only):
   --source-path=PATH       path of source code [$source_path]
@@ -1355,6 +1375,9 @@
   --enable-debug-stack-usage
                            track the maximum stack usage of stacks created by qemu_alloc_stack
 
+  --enable-llvm            enable LLVM support (for all targets)"
+  --with-llvm=PATH         LLVM path (PATH/bin/llvm-config must exist)"
+
 Optional features, enabled with --enable-FEATURE and
 disabled with --disable-FEATURE, default is enabled if available:
 
@@ -1697,7 +1720,7 @@
 fi
 
 if test -z "${target_list+xxx}" ; then
-    target_list="$default_target_list"
+    target_list="i386-softmmu x86_64-softmmu arm-softmmu ppc-softmmu"
 else
     target_list=$(echo "$target_list" | sed -e 's/,/ /g')
 fi
@@ -3198,6 +3221,103 @@
 fi
 
 ##########################################
+# llvm support probe
+
+if test "$llvm" != "no" ; then
+  cat > $TMPCXX << EOF
+#include <llvm/IR/LLVMContext.h>
+int main(void) { llvm::LLVMContext& c = llvm::getGlobalContext(); return 0; }
+EOF
+  if test "$llvmdir" != ""; then
+    if [ -x "$llvmdir/bin/llvm-config-$llvmver" ]; then
+      llvm_config="$llvmdir/bin/llvm-config-$llvmver"
+    else
+      llvm_config="$llvmdir/bin/llvm-config"
+    fi
+  else
+      llvm_config="llvm-config"
+  fi
+  if ! "$llvm_config" --version >> config.log 2>&1; then
+    feature_not_found "llvm (required for --enable-llvm)"
+    exit 1
+  fi
+  #llvm_components="jit bitreader bitwriter asmparser ipo linker engine"
+  llvm_components=""
+  llvm_cxxflags=`$llvm_config $llvm_components --cxxflags 2> /dev/null`
+
+  llvm_ldflags=`$llvm_config $llvm_components --ldflags 2> /dev/null`
+  llvm_ldflags="$llvm_ldflags"
+  llvm_libs=`$llvm_config $llvm_components --libs 2> /dev/null`
+
+  if compile_prog_cxx "$llvm_cxxflags" "$llvm_libs $llvm_ldflags" ; then
+    : LLVM found
+  else
+    feature_not_found "llvm (required for --enable-llvm)"
+    exit 1
+  fi
+fi
+
+if test "$llvm" != "no" ; then
+  llvm="yes"
+  #These will be automatically added by klee and we don't want
+  #duplicated libs on the command line.
+  #if [ "x$s2e" != "xyes" ]; then
+    LIBS="$llvm_libs $LIBS $llvm_ldflags"
+  #fi
+  linker="$cxx"
+fi
+
+if test "$llvm" != "no" ; then
+  if [ -x "$llvmdir/bin/clang" ]; then
+    clang="$llvmdir/bin/clang"
+  elif clang --version >> config.log 2>&1; then
+    : clang found
+    clang=`which clang`
+  else
+    feature_not_found "clang (required to be built with LLVM)"
+    exit 1
+  fi
+
+  if [ -x "$llvmdir/bin/clang++" ]; then
+    clangxx="$llvmdir/bin/clang++"
+  elif clang++ --version >> config.log 2>&1; then
+    : clang++ found
+    clangxx=`which clang++`
+  else
+    feature_not_found "clang++ (required to be built with LLVM)"
+    exit 1
+  fi
+
+  if [ -e "$llvmdir/bin/llvm-link" ] ; then
+    llvm_link=`cd $llvmdir/bin/ && find \`pwd\` -name llvm-link`
+  elif [ -e "$llvmdir/bin/llvm-link-$llvmver" ] ; then
+    llvm_link=`cd $llvmdir/bin/ && find \`pwd\` -name llvm-link-$llvmver`
+  fi
+  if [ -x "$llvm_link" ]; then
+    : llvm_link found
+  else
+    feature_not_found "llvm-link (required to be built with LLVM)"
+    exit 1
+  fi
+fi
+
+##########################################
+# pycparser probe
+
+if ! $python <<EOF
+import sys
+import pycparser
+version = [int(x) for x in pycparser.__version__.split(".")]
+if version[0] < 2 or (version[0] == 2 and version[1] < 10):
+  sys.exit(1)
+else:
+  sys.exit(0)
+EOF
+then
+  feature_not_found "pycparser (required for PANDA plugin APIs)"
+fi
+
+##########################################
 # libcap probe
 
 if test "$cap" != "no" ; then
@@ -3735,7 +3855,7 @@
 # check if memfd is supported
 memfd=no
 cat > $TMPC << EOF
-#include <sys/memfd.h>
+#include <sys/mman.h>
 
 int main(void)
 {
@@ -4020,7 +4140,9 @@
 int main(void) { return bswap_32(0); }
 EOF
 if compile_prog "" "" ; then
-  byteswap_h=yes
+    # disabling bc this breaks our llvm
+    # byteswap_h=yes
+    true
 fi
 
 # Search for bswap32 function
@@ -4032,9 +4154,13 @@
 int main(void) { return bswap32(0); }
 EOF
 if compile_prog "" "" ; then
-  bswap_h=yes
+    # disabling bc this breaks our llvm
+    # bswap_h=no
+    true
 fi
 
+
+
 ##########################################
 # Do we have libiscsi >= 1.9.0
 if test "$libiscsi" != "no" ; then
@@ -4838,6 +4964,7 @@
 qemu_moddir=$libdir$confsuffix
 qemu_datadir=$datadir$confsuffix
 qemu_localedir="$datadir/locale"
+panda_plugindir="$libdir/panda"
 
 tools=""
 if test "$want_tools" = "yes" ; then
@@ -5025,6 +5152,7 @@
 echo "Windows SDK       $win_sdk"
 fi
 echo "Source path       $source_path"
+echo "Extra plugins path $extra_plugins_path"
 echo "C compiler        $cc"
 echo "Host C compiler   $host_cc"
 echo "C++ compiler      $cxx"
@@ -5099,6 +5227,7 @@
 echo "KVM support       $kvm"
 echo "HAX support       $hax"
 echo "RDMA support      $rdma"
+echo "LLVM support      $llvm"
 echo "TCG interpreter   $tcg_interpreter"
 echo "fdt support       $fdt"
 echo "preadv support    $preadv"
@@ -5196,6 +5325,7 @@
 echo "qemu_datadir=$qemu_datadir" >> $config_host_mak
 echo "qemu_docdir=$qemu_docdir" >> $config_host_mak
 echo "qemu_moddir=$qemu_moddir" >> $config_host_mak
+echo "panda_plugindir=$panda_plugindir" >> $config_host_mak
 if test "$mingw32" = "no" ; then
   echo "qemu_localstatedir=$local_statedir" >> $config_host_mak
 fi
@@ -5327,6 +5457,9 @@
 echo "VERSION=$qemu_version" >>$config_host_mak
 echo "PKGVERSION=$pkgversion" >>$config_host_mak
 echo "SRC_PATH=$source_path" >> $config_host_mak
+if [ ! -z "$extra_plugins_path" ]; then
+  echo "EXTRA_PLUGINS_PATH=$extra_plugins_path" >> $config_host_mak
+fi
 echo "TARGET_DIRS=$target_list" >> $config_host_mak
 if [ "$docs" = "yes" ] ; then
   echo "BUILD_DOCS=yes" >> $config_host_mak
@@ -5499,6 +5632,22 @@
   echo "VIRGL_CFLAGS=$virgl_cflags" >> $config_host_mak
   echo "VIRGL_LIBS=$virgl_libs" >> $config_host_mak
 fi
+
+if test "$llvm" = "yes" ; then
+    FILTERFLAGS="-pedantic"
+  if test "$debug" = "yes" ; then
+     FILTERFLAGS="$FILTERFLAGS -O2 -O1 -O3 -fomit-frame-pointer"
+  fi
+
+  echo "CLANG_CXXFLAGS:=$clang_cxxflags" >> $config_host_mak
+  echo "LLVMCC:=$clang" >> $config_host_mak
+  echo "LLVMCXX:=$clangxx" >> $config_host_mak
+  echo "LLVM_LINK:=$llvm_link" >> $config_host_mak
+  echo "CONFIG_LLVM=y" >> $config_host_mak
+  echo "LLVM_CXXFLAGS=\$(filter-out $FILTERFLAGS,$llvm_cxxflags)" >> $config_host_mak
+  echo "LLVMDIR=$llvmdir" >> $config_host_mak
+fi
+
 if test "$xen" = "yes" ; then
   echo "CONFIG_XEN_BACKEND=y" >> $config_host_mak
   echo "CONFIG_XEN_CTRL_INTERFACE_VERSION=$xen_ctrl_version" >> $config_host_mak
@@ -5945,9 +6094,11 @@
 
 case "$target_name" in
   i386)
+    gdb_xml_files="i386-32bit-core.xml"
   ;;
   x86_64)
     TARGET_BASE_ARCH=i386
+    gdb_xml_files="i386-64bit-core.xml"
   ;;
   alpha)
     mttcg="yes"
@@ -6137,6 +6288,11 @@
 if test "$target_linux_user" = "yes" ; then
   echo "CONFIG_LINUX_USER=y" >> $config_target_mak
 fi
+
+if [ "$llvm" = "yes" ]; then
+   echo "LIBS:=$llvm_libs $llvm_ldflags \$(LIBS)" >> $config_target_mak
+fi
+
 list=""
 if test ! -z "$gdb_xml_files" ; then
   for x in $gdb_xml_files; do

diff -bur qemu-2.9.1/cpu-exec.c panda/cpu-exec.c
--- qemu-2.9.1/cpu-exec.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/cpu-exec.c	2020-01-22 10:59:21.890782321 -0500
@@ -29,12 +29,24 @@
 #include "qemu/rcu.h"
 #include "exec/tb-hash.h"
 #include "exec/log.h"
-#include "qemu/main-loop.h"
 #if defined(TARGET_I386) && !defined(CONFIG_USER_ONLY)
 #include "hw/i386/apic.h"
 #endif
 #include "sysemu/cpus.h"
 #include "sysemu/replay.h"
+#include "sysemu/sysemu.h"
+#include "panda/rr/rr_log.h"
+#include "panda/callbacks/cb-support.h"
+#include "panda/common.h"
+
+#ifdef CONFIG_LLVM
+#include "panda/tcg-llvm.h"
+const int has_llvm_engine = 1;
+#endif
+
+int generate_llvm = 0;
+int execute_llvm = 0;
+extern bool panda_tb_chaining;
 
 /* -icount align implementation. */
 
@@ -54,6 +66,13 @@
 #define MAX_DELAY_PRINT_RATE 2000000000LL
 #define MAX_NB_PRINTS 100
 
+// Needed to prevent before_block_exec_invalidate_opt from 
+// running more than once
+bool panda_bb_invalidate_done = false;
+
+// Whether or not a block has actually run since cpu_exec was last entered
+bool ranBlockSinceEnter = false;
+
 static void align_clocks(SyncClocks *sc, const CPUState *cpu)
 {
     int64_t cpu_icount;
@@ -142,6 +161,7 @@
     uintptr_t ret;
     TranslationBlock *last_tb;
     int tb_exit;
+    uint8_t exitCode;
     uint8_t *tb_ptr = itb->tc_ptr;
 
     qemu_log_mask_and_addr(CPU_LOG_EXEC, itb->pc,
@@ -163,10 +183,44 @@
 #endif /* DEBUG_DISAS */
 
     cpu->can_do_io = !use_icount;
+
+    if (cpu->tcg_exit_req == 0)
+        panda_callbacks_before_block_exec(cpu, itb);
+
+    // If there has been a request to break the CPU
+    // loop, return now. Before we execute the block
+    if (panda_exit_loop) {
+        cpu->can_do_io = 1;
+        // tcg_exit_req is likely already 0, but make sure it's
+        // cleared now before we resume execution later
+        atomic_set(&cpu->tcg_exit_req, 0);
+        return TB_EXIT_REQUESTED;
+    }
+
+    // NB: This is where we did this in panda1
+    panda_bb_invalidate_done = false;
+
+#if defined(CONFIG_LLVM)
+    if (execute_llvm) {
+        assert(itb->llvm_tc_ptr);
+        ret = tcg_llvm_qemu_tb_exec(env, itb);
+    } else {
+        assert(tb_ptr);
+        ret = tcg_qemu_tb_exec(env, tb_ptr);
+    }
+#else
     ret = tcg_qemu_tb_exec(env, tb_ptr);
+#endif // CONFIG_LLVM
     cpu->can_do_io = 1;
     last_tb = (TranslationBlock *)(ret & ~TB_EXIT_MASK);
+    ranBlockSinceEnter = true;
+
     tb_exit = ret & TB_EXIT_MASK;
+
+    /* force into variable of known size */
+    exitCode = (uint8_t)tb_exit;
+    panda_callbacks_after_block_exec(cpu, itb, exitCode);
+
     trace_exec_tb_exit(last_tb, tb_exit);
 
     if (tb_exit > TB_EXIT_IDX1) {
@@ -187,6 +241,12 @@
             cc->set_pc(cpu, last_tb->pc);
         }
     }
+    if (tb_exit == TB_EXIT_REQUESTED) {
+        /* We were asked to stop executing TBs (probably a pending
+         * interrupt. We've now stopped, so clear the flag.
+         */
+        atomic_set(&cpu->tcg_exit_req, 0);
+    }
     return ret;
 }
 
@@ -361,8 +421,10 @@
              */
             tb = tb_htable_lookup(cpu, pc, cs_base, flags);
             if (!tb) {
+                panda_callbacks_before_block_translate(cpu, pc);
                 /* if no translated code available, then translate it now */
                 tb = tb_gen_code(cpu, pc, cs_base, flags, 0);
+                panda_callbacks_after_block_translate(cpu, tb);
             }
 
             mmap_unlock();
@@ -381,6 +443,9 @@
     }
 #endif
     /* See if we can patch the calling TB. */
+#ifdef CONFIG_SOFTMMU
+    if (!rr_in_replay() && panda_tb_chaining) {
+#endif
     if (last_tb && !qemu_loglevel_mask(CPU_LOG_TB_NOCHAIN)) {
         if (!have_tb_lock) {
             tb_lock();
@@ -390,6 +455,9 @@
             tb_add_jump(last_tb, tb_exit, tb);
         }
     }
+#ifdef CONFIG_SOFTMMU
+    }
+#endif
     if (have_tb_lock) {
         tb_unlock();
     }
@@ -403,13 +471,12 @@
         if ((cpu->interrupt_request & CPU_INTERRUPT_POLL)
             && replay_interrupt()) {
             X86CPU *x86_cpu = X86_CPU(cpu);
-            qemu_mutex_lock_iothread();
             apic_poll_irq(x86_cpu->apic_state);
             cpu_reset_interrupt(cpu, CPU_INTERRUPT_POLL);
-            qemu_mutex_unlock_iothread();
         }
 #endif
-        if (!cpu_has_work(cpu)) {
+        if (!cpu_has_work(cpu) && !rr_in_replay()) {
+            current_cpu = NULL;
             return true;
         }
 
@@ -435,6 +502,17 @@
 
 static inline bool cpu_handle_exception(CPUState *cpu, int *ret)
 {
+
+    // If we finished a reverse-step, clear the most recent breakpoint
+    if ((cpu->reverse_flags & (GDB_RSTEP | GDB_RDONE)) == (GDB_RSTEP | GDB_RDONE)) {
+        // Remove the breakpoint we just hit
+        // And clear the reverse_flags
+        cpu_breakpoint_remove_by_instr(cpu, cpu->last_gdb_instr-1, BP_GDB);
+        cpu->reverse_flags = 0;
+    }
+
+    cpu->exception_index = panda_callbacks_before_handle_exception(cpu, cpu->exception_index);
+
     if (cpu->exception_index >= 0) {
         if (cpu->exception_index >= EXCP_INTERRUPT) {
             /* exit request from the cpu execution loop */
@@ -458,10 +536,11 @@
             return true;
 #else
             if (replay_exception()) {
+#ifdef TARGET_PPC
+                rr_exception_index_at(RR_CALLSITE_CPU_EXCEPTION_INDEX, &cpu->exception_index);
+#endif
                 CPUClass *cc = CPU_GET_CLASS(cpu);
-                qemu_mutex_lock_iothread();
                 cc->do_interrupt(cpu);
-                qemu_mutex_unlock_iothread();
                 cpu->exception_index = -1;
             } else if (!replay_has_interrupt()) {
                 /* give a chance to iothread in replay mode */
@@ -487,11 +566,22 @@
                                         TranslationBlock **last_tb)
 {
     CPUClass *cc = CPU_GET_CLASS(cpu);
+    int interrupt_request = cpu->interrupt_request;
+#ifdef CONFIG_SOFTMMU
+    //mz Record and Replay.
+    //mz it is important to do this in the order written, as
+    //during record env->interrupt_request can be changed at any
+    //time via a signal.  Thus, we want to make sure that we
+    //record the same value in the log as the one being used in
+    //these decisions.
+    rr_skipped_callsite_location = RR_CALLSITE_CPU_HANDLE_INTERRUPT_BEFORE;
+    rr_interrupt_request(&interrupt_request);
 
-    if (unlikely(atomic_read(&cpu->interrupt_request))) {
-        int interrupt_request;
-        qemu_mutex_lock_iothread();
-        interrupt_request = cpu->interrupt_request;
+    if (rr_in_replay()) {
+        cpu->interrupt_request = interrupt_request;
+    }
+#endif
+    if (unlikely(interrupt_request)) {
         if (unlikely(cpu->singlestep_enabled & SSTEP_NOIRQ)) {
             /* Mask out external interrupts for this step. */
             interrupt_request &= ~CPU_INTERRUPT_SSTEP_MASK;
@@ -499,7 +589,6 @@
         if (interrupt_request & CPU_INTERRUPT_DEBUG) {
             cpu->interrupt_request &= ~CPU_INTERRUPT_DEBUG;
             cpu->exception_index = EXCP_DEBUG;
-            qemu_mutex_unlock_iothread();
             return true;
         }
         if (replay_mode == REPLAY_MODE_PLAY && !replay_has_interrupt()) {
@@ -509,7 +598,6 @@
             cpu->interrupt_request &= ~CPU_INTERRUPT_HALT;
             cpu->halted = 1;
             cpu->exception_index = EXCP_HLT;
-            qemu_mutex_unlock_iothread();
             return true;
         }
 #if defined(TARGET_I386)
@@ -520,14 +608,12 @@
             cpu_svm_check_intercept_param(env, SVM_EXIT_INIT, 0, 0);
             do_cpu_init(x86_cpu);
             cpu->exception_index = EXCP_HALTED;
-            qemu_mutex_unlock_iothread();
             return true;
         }
 #else
         else if (interrupt_request & CPU_INTERRUPT_RESET) {
             replay_interrupt();
             cpu_reset(cpu);
-            qemu_mutex_unlock_iothread();
             return true;
         }
 #endif
@@ -544,20 +630,22 @@
              * reload the 'interrupt_request' value */
             interrupt_request = cpu->interrupt_request;
         }
+#ifdef CONFIG_SOFTMMU
+        //mz record the value again in case do_interrupt has set EXITTB flag
+        rr_skipped_callsite_location = RR_CALLSITE_CPU_HANDLE_INTERRUPT_AFTER;
+        rr_interrupt_request((int *)&cpu->interrupt_request);
+        if (rr_in_replay()) {
+            interrupt_request = cpu->interrupt_request;
+        }
+#endif
         if (interrupt_request & CPU_INTERRUPT_EXITTB) {
             cpu->interrupt_request &= ~CPU_INTERRUPT_EXITTB;
             /* ensure that no TB jump will be modified as
                the program flow was changed */
             *last_tb = NULL;
         }
-
-        /* If we exit via cpu_loop_exit/longjmp it is reset in cpu_exec */
-        qemu_mutex_unlock_iothread();
     }
-
-    /* Finally, check if we need to exit to the main loop.  */
-    if (unlikely(atomic_read(&cpu->exit_request)
-        || (use_icount && cpu->icount_decr.u16.low + cpu->icount_extra == 0))) {
+    if (unlikely(atomic_read(&cpu->exit_request) || replay_has_interrupt())) {
         atomic_set(&cpu->exit_request, 0);
         cpu->exception_index = EXCP_INTERRUPT;
         return true;
@@ -567,63 +655,105 @@
 }
 
 static inline void cpu_loop_exec_tb(CPUState *cpu, TranslationBlock *tb,
-                                    TranslationBlock **last_tb, int *tb_exit)
+                                    TranslationBlock **last_tb, int *tb_exit,
+                                    SyncClocks *sc)
 {
     uintptr_t ret;
-    int32_t insns_left;
+
+    if (unlikely(atomic_read(&cpu->exit_request))) {
+        return;
+    }
 
     trace_exec_tb(tb, tb->pc);
     ret = cpu_tb_exec(cpu, tb);
     tb = (TranslationBlock *)(ret & ~TB_EXIT_MASK);
     *tb_exit = ret & TB_EXIT_MASK;
-    if (*tb_exit != TB_EXIT_REQUESTED) {
-        *last_tb = tb;
-        return;
-    }
-
-    *last_tb = NULL;
-    insns_left = atomic_read(&cpu->icount_decr.u32);
-    atomic_set(&cpu->icount_decr.u16.high, 0);
-    if (insns_left < 0) {
+    switch (*tb_exit) {
+    case TB_EXIT_REQUESTED:
         /* Something asked us to stop executing chained TBs; just
          * continue round the main loop. Whatever requested the exit
-         * will also have set something else (eg exit_request or
-         * interrupt_request) which we will handle next time around
-         * the loop.  But we need to ensure the zeroing of icount_decr
-         * comes before the next read of cpu->exit_request
-         * or cpu->interrupt_request.
+         * will also have set something else (eg interrupt_request)
+         * which we will handle next time around the loop.  But we
+         * need to ensure the tcg_exit_req read in generated code
+         * comes before the next read of cpu->exit_request or
+         * cpu->interrupt_request.
          */
         smp_mb();
-        return;
-    }
-
+        *last_tb = NULL;
+        break;
+    case TB_EXIT_ICOUNT_EXPIRED:
+    {
     /* Instruction counter expired.  */
-    assert(use_icount);
-#ifndef CONFIG_USER_ONLY
-    /* Ensure global icount has gone forward */
-    cpu_update_icount(cpu);
+#ifdef CONFIG_USER_ONLY
+        abort();
+#else
+        int insns_left = cpu->icount_decr.u32;
+        *last_tb = NULL;
+        if (cpu->icount_extra && insns_left >= 0) {
     /* Refill decrementer and continue execution.  */
-    insns_left = MIN(0xffff, cpu->icount_budget);
+            cpu->icount_extra += insns_left;
+            insns_left = MIN(0xffff, cpu->icount_extra);
+            cpu->icount_extra -= insns_left;
     cpu->icount_decr.u16.low = insns_left;
-    cpu->icount_extra = cpu->icount_budget - insns_left;
-    if (!cpu->icount_extra) {
-        /* Execute any remaining instructions, then let the main loop
-         * handle the next event.
-         */
+        } else {
         if (insns_left > 0) {
+                /* Execute remaining instructions.  */
             cpu_exec_nocache(cpu, insns_left, tb, false);
+                align_clocks(sc, cpu);
+            }
+            cpu->exception_index = EXCP_INTERRUPT;
+            cpu_loop_exit(cpu);
+        }
+        break;
+#endif
         }
+    default:
+        *last_tb = tb;
+        break;
+    }
+}
+
+#ifdef CONFIG_DEBUG_TCG
+uint64_t counter_128k = 0;
+void debug_counter(void);
+void debug_counter(void) {
+        counter_128k++;
+}
+#endif
+
+__attribute__((always_inline)) static inline void debug_checkpoint(CPUState *cpu) {
+#ifdef CONFIG_DEBUG_TCG
+    if (rr_on() && cpu->rr_guest_instr_count >> 17 > counter_128k) {
+        debug_counter();
     }
 #endif
 }
 
+__attribute__((always_inline)) static inline void detect_infinite_loops(void) {
+    if (!rr_in_replay()) return;
+
+    static uint64_t last_instr_count = 0;
+    static unsigned loop_tries = 0;
+    if (last_instr_count == rr_get_guest_instr_count()) {
+        loop_tries++;
+        if (loop_tries > 20) {
+            fprintf(stderr, "rr_guest_instr_count = %" PRIu64 "\n",
+                    rr_get_guest_instr_count());
+            assert(false);
+        }
+    } else {
+        loop_tries = 0;
+        last_instr_count = rr_get_guest_instr_count();
+    }
+}
+
 /* main execution loop */
 
 int cpu_exec(CPUState *cpu)
 {
     CPUClass *cc = CPU_GET_CLASS(cpu);
-    int ret;
-    SyncClocks sc = { 0 };
+    int ret = -1;
+    SyncClocks sc;
 
     /* replay_interrupt may need current_cpu */
     current_cpu = cpu;
@@ -634,7 +764,9 @@
 
     rcu_read_lock();
 
+    ranBlockSinceEnter = false;
     cc->cpu_exec_enter(cpu);
+    panda_callbacks_after_cpu_exec_enter(cpu);
 
     /* Calculate difference between guest clock and host clock.
      * This delay includes the delay of the last cycle, so
@@ -659,27 +791,85 @@
 #endif /* buggy compiler */
         cpu->can_do_io = 1;
         tb_lock_reset();
-        if (qemu_mutex_iothread_locked()) {
-            qemu_mutex_unlock_iothread();
-        }
     }
 
     /* if an exception is pending, we execute it here */
     while (!cpu_handle_exception(cpu, &ret)) {
+
+        if (panda_exit_loop) {
+            printf ("Exiting cpu_handle_execption loop\n");
+            break;
+        }
+
         TranslationBlock *last_tb = NULL;
         int tb_exit = 0;
 
-        while (!cpu_handle_interrupt(cpu, &last_tb)) {
+        /* Note: We usually break out of the loop manually and
+         * not because panda_exit_loop is true. */
+        while (likely(!panda_exit_loop)) {
+            bool panda_invalidate_tb = false;
+            debug_checkpoint(cpu);
+            detect_infinite_loops();
+            rr_maybe_progress();
+
+            /* Replay skipped calls from the I/O thread here. */
+            if (rr_in_replay()) {
+                rr_skipped_callsite_location = RR_CALLSITE_MAIN_LOOP_WAIT;
+                rr_replay_skipped_calls();
+            }
+
+            if (cpu_handle_interrupt(cpu, &last_tb)) {
+                break;
+            }
+
+            panda_callbacks_before_find_fast();
             TranslationBlock *tb = tb_find(cpu, last_tb, tb_exit);
-            cpu_loop_exec_tb(cpu, tb, &last_tb, &tb_exit);
+            panda_bb_invalidate_done = panda_callbacks_after_find_fast(
+                    cpu, tb, panda_bb_invalidate_done, &panda_invalidate_tb);
+        
+            if (unlikely(cpu->temp_rr_bp_instr) && rr_get_guest_instr_count() > cpu->temp_rr_bp_instr) {
+                // Restore rr breakpoint if one was disabled for continue
+                cpu_rr_breakpoint_insert(cpu, cpu->temp_rr_bp_instr, BP_GDB, NULL);
+                cpu->temp_rr_bp_instr = 0;
+            }
+
+            qemu_log_rr(tb->pc);
+
+#ifdef CONFIG_SOFTMMU
+            uint64_t until_interrupt = rr_num_instr_before_next_interrupt();
+            if (panda_invalidate_tb
+                    || (rr_in_replay() && until_interrupt > 0
+                        && tb->icount > until_interrupt)) {
+                /* Retranslate so that basic block boundary matches
+                 * record & replay for interrupt delivery. */
+                tb_lock();
+                tb_phys_invalidate(tb, -1);
+                tb_unlock();
+                continue;
+            }
+#endif // CONFIG_SOFTMMU
+            if (rr_in_replay() && rr_replay_finished()) {
+                rr_do_end_replay(0);
+                qemu_cpu_kick(cpu);
+                panda_exit_loop = true;
+                break;
+            }
+
+            if (!rr_in_replay() || until_interrupt > 0) {
+                cpu_loop_exec_tb(cpu, tb, &last_tb, &tb_exit, &sc);
             /* Try to align the host and virtual clocks
                if the guest is in advance */
             align_clocks(&sc, cpu);
         }
     }
+    }
 
+    panda_callbacks_before_cpu_exec_exit(cpu, ranBlockSinceEnter);
     cc->cpu_exec_exit(cpu);
     rcu_read_unlock();
 
+    /* fail safe : never use current_cpu outside cpu_exec() */
+    current_cpu = NULL;
+
     return ret;
 }

diff -bur qemu-2.9.1/cpus.c panda/cpus.c
--- qemu-2.9.1/cpus.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/cpus.c	2020-01-22 10:59:21.890782321 -0500
@@ -51,6 +51,9 @@
 #include "hw/nmi.h"
 #include "sysemu/replay.h"
 
+#include "panda/rr/rr_log.h"
+#include "panda/callbacks/cb-support.h"
+
 #ifdef CONFIG_LINUX
 
 #include <sys/prctl.h>
@@ -80,6 +83,9 @@
 #define CPU_THROTTLE_PCT_MAX 99
 #define CPU_THROTTLE_TIMESLICE_NS 10000000
 
+extern bool rr_replay_complete;
+extern bool panda_exit_loop;
+
 bool cpu_is_stopped(CPUState *cpu)
 {
     return cpu->stopped || !runstate_is_running();
@@ -223,51 +229,20 @@
     }
 }
 
-/* The current number of executed instructions is based on what we
- * originally budgeted minus the current state of the decrementing
- * icount counters in extra/u16.low.
- */
-static int64_t cpu_get_icount_executed(CPUState *cpu)
-{
-    return cpu->icount_budget - (cpu->icount_decr.u16.low + cpu->icount_extra);
-}
-
-/*
- * Update the global shared timer_state.qemu_icount to take into
- * account executed instructions. This is done by the TCG vCPU
- * thread so the main-loop can see time has moved forward.
- */
-void cpu_update_icount(CPUState *cpu)
-{
-    int64_t executed = cpu_get_icount_executed(cpu);
-    cpu->icount_budget -= executed;
-
-#ifdef CONFIG_ATOMIC64
-    atomic_set__nocheck(&timers_state.qemu_icount,
-                        atomic_read__nocheck(&timers_state.qemu_icount) +
-                        executed);
-#else /* FIXME: we need 64bit atomics to do this safely */
-    timers_state.qemu_icount += executed;
-#endif
-}
-
 int64_t cpu_get_icount_raw(void)
 {
+    int64_t icount;
     CPUState *cpu = current_cpu;
 
-    if (cpu && cpu->running) {
+    icount = timers_state.qemu_icount;
+    if (cpu) {
         if (!cpu->can_do_io) {
             fprintf(stderr, "Bad icount read\n");
             exit(1);
         }
-        /* Take into account what has run */
-        cpu_update_icount(cpu);
+        icount -= (cpu->icount_decr.u16.low + cpu->icount_extra);
     }
-#ifdef CONFIG_ATOMIC64
-    return atomic_read__nocheck(&timers_state.qemu_icount);
-#else /* FIXME: we need 64bit atomics to do this safely */
-    return timers_state.qemu_icount;
-#endif
+    return icount;
 }
 
 /* Return the virtual CPU time, based on the instruction counter.  */
@@ -831,25 +806,9 @@
     } while (cpu != atomic_mb_read(&tcg_current_rr_cpu));
 }
 
-static void do_nothing(CPUState *cpu, run_on_cpu_data unused)
-{
-}
-
 void qemu_timer_notify_cb(void *opaque, QEMUClockType type)
 {
-    if (!use_icount || type != QEMU_CLOCK_VIRTUAL) {
         qemu_notify_event();
-        return;
-    }
-
-    if (!qemu_in_vcpu_thread() && first_cpu) {
-        /* qemu_cpu_kick is not enough to kick a halted CPU out of
-         * qemu_tcg_wait_io_event.  async_run_on_cpu, instead,
-         * causes cpu_thread_is_idle to return false.  This way,
-         * handle_icount_deadline can run.
-         */
-        async_run_on_cpu(first_cpu, do_nothing, RUN_ON_CPU_NULL);
-    }
 }
 
 static void kick_tcg_thread(void *opaque)
@@ -860,7 +819,7 @@
 
 static void start_tcg_kick_timer(void)
 {
-    if (!mttcg_enabled && !tcg_kick_vcpu_timer && CPU_NEXT(first_cpu)) {
+    if (!tcg_kick_vcpu_timer && CPU_NEXT(first_cpu)) {
         tcg_kick_vcpu_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,
                                            kick_tcg_thread, NULL);
         timer_mod(tcg_kick_vcpu_timer, qemu_tcg_next_kick());
@@ -920,7 +879,7 @@
     }
 }
 
-static int do_vm_stop(RunState state)
+int do_vm_stop(RunState state)
 {
     int ret = 0;
 
@@ -1012,6 +971,8 @@
 #endif /* !CONFIG_LINUX */
 
 static QemuMutex qemu_global_mutex;
+static QemuCond qemu_io_proceeded_cond;
+static unsigned iothread_requesting_mutex;
 
 static QemuThread io_thread;
 
@@ -1025,6 +986,7 @@
     qemu_init_sigbus();
     qemu_cond_init(&qemu_cpu_cond);
     qemu_cond_init(&qemu_pause_cond);
+    qemu_cond_init(&qemu_io_proceeded_cond);
     qemu_mutex_init(&qemu_global_mutex);
 
     qemu_thread_get_self(&io_thread);
@@ -1049,34 +1011,35 @@
 
 static void qemu_wait_io_event_common(CPUState *cpu)
 {
-    atomic_mb_set(&cpu->thread_kicked, false);
     if (cpu->stop) {
         cpu->stop = false;
         cpu->stopped = true;
         qemu_cond_broadcast(&qemu_pause_cond);
     }
     process_queued_cpu_work(cpu);
-}
-
-static bool qemu_tcg_should_sleep(CPUState *cpu)
-{
-    if (mttcg_enabled) {
-        return cpu_thread_is_idle(cpu);
-    } else {
-        return all_cpu_threads_idle();
-    }
+    cpu->thread_kicked = false;
 }
 
 static void qemu_tcg_wait_io_event(CPUState *cpu)
 {
-    while (qemu_tcg_should_sleep(cpu)) {
+    while (all_cpu_threads_idle()) {
+        // We're in replay, so replay the interrupt!
+        // Otherwise e.g. if the CPU has HLTd it will just sit here forever.
+        if (rr_in_replay() && rr_num_instr_before_next_interrupt() == 0) break;
+
         stop_tcg_kick_timer();
         qemu_cond_wait(cpu->halt_cond, &qemu_global_mutex);
     }
 
     start_tcg_kick_timer();
 
+    while (iothread_requesting_mutex) {
+        qemu_cond_wait(&qemu_io_proceeded_cond, &qemu_global_mutex);
+    }
+
+    CPU_FOREACH(cpu) {
     qemu_wait_io_event_common(cpu);
+    }
 }
 
 static void qemu_kvm_wait_io_event(CPUState *cpu)
@@ -1146,7 +1109,6 @@
     qemu_thread_get_self(cpu->thread);
     cpu->thread_id = qemu_get_thread_id();
     cpu->can_do_io = 1;
-    current_cpu = cpu;
 
     sigemptyset(&waitset);
     sigaddset(&waitset, SIG_IPI);
@@ -1155,7 +1117,9 @@
     cpu->created = true;
     qemu_cond_signal(&qemu_cpu_cond);
 
+    current_cpu = cpu;
     while (1) {
+        current_cpu = NULL;
         qemu_mutex_unlock_iothread();
         do {
             int sig;
@@ -1166,6 +1130,7 @@
             exit(1);
         }
         qemu_mutex_lock_iothread();
+        current_cpu = cpu;
         qemu_wait_io_event_common(cpu);
     }
 
@@ -1197,54 +1162,16 @@
 
 static void handle_icount_deadline(void)
 {
-    assert(qemu_in_vcpu_thread());
     if (use_icount) {
         int64_t deadline =
             qemu_clock_deadline_ns_all(QEMU_CLOCK_VIRTUAL);
 
         if (deadline == 0) {
-            /* Wake up other AioContexts.  */
             qemu_clock_notify(QEMU_CLOCK_VIRTUAL);
-            qemu_clock_run_timers(QEMU_CLOCK_VIRTUAL);
-        }
-    }
-}
-
-static void prepare_icount_for_run(CPUState *cpu)
-{
-    if (use_icount) {
-        int insns_left;
-
-        /* These should always be cleared by process_icount_data after
-         * each vCPU execution. However u16.high can be raised
-         * asynchronously by cpu_exit/cpu_interrupt/tcg_handle_interrupt
-         */
-        g_assert(cpu->icount_decr.u16.low == 0);
-        g_assert(cpu->icount_extra == 0);
-
-        cpu->icount_budget = tcg_get_icount_limit();
-        insns_left = MIN(0xffff, cpu->icount_budget);
-        cpu->icount_decr.u16.low = insns_left;
-        cpu->icount_extra = cpu->icount_budget - insns_left;
     }
-}
-
-static void process_icount_data(CPUState *cpu)
-{
-    if (use_icount) {
-        /* Account for executed instructions */
-        cpu_update_icount(cpu);
-
-        /* Reset the counters */
-        cpu->icount_decr.u16.low = 0;
-        cpu->icount_extra = 0;
-        cpu->icount_budget = 0;
-
-        replay_account_executed_instructions();
     }
 }
 
-
 static int tcg_cpu_exec(CPUState *cpu)
 {
     int ret;
@@ -1255,14 +1182,35 @@
 #ifdef CONFIG_PROFILER
     ti = profile_getclock();
 #endif
-    qemu_mutex_unlock_iothread();
+    if (use_icount) {
+        int64_t count;
+        int decr;
+        timers_state.qemu_icount -= (cpu->icount_decr.u16.low
+                                    + cpu->icount_extra);
+        cpu->icount_decr.u16.low = 0;
+        cpu->icount_extra = 0;
+        count = tcg_get_icount_limit();
+        timers_state.qemu_icount += count;
+        decr = (count > 0xffff) ? 0xffff : count;
+        count -= decr;
+        cpu->icount_decr.u16.low = decr;
+        cpu->icount_extra = count;
+    }
     cpu_exec_start(cpu);
     ret = cpu_exec(cpu);
     cpu_exec_end(cpu);
-    qemu_mutex_lock_iothread();
 #ifdef CONFIG_PROFILER
     tcg_time += profile_getclock() - ti;
 #endif
+    if (use_icount) {
+        /* Fold pending instructions back into the
+           instruction counter, and clear the interrupt flag.  */
+        timers_state.qemu_icount -= (cpu->icount_decr.u16.low
+                        + cpu->icount_extra);
+        cpu->icount_decr.u32 = 0;
+        cpu->icount_extra = 0;
+        replay_account_executed_instructions();
+    }
     return ret;
 }
 
@@ -1292,7 +1240,7 @@
  * elsewhere.
  */
 
-static void *qemu_tcg_rr_cpu_thread_fn(void *arg)
+static void *qemu_tcg_cpu_thread_fn(void *arg)
 {
     CPUState *cpu = arg;
 
@@ -1314,7 +1262,6 @@
 
         /* process any pending work */
         CPU_FOREACH(cpu) {
-            current_cpu = cpu;
             qemu_wait_io_event_common(cpu);
         }
     }
@@ -1327,14 +1274,14 @@
     cpu->exit_request = 1;
 
     while (1) {
+
+        if (!rr_replay_complete) {
+            panda_callbacks_top_loop(cpu);
+        }
+
         /* Account partial waits to QEMU_CLOCK_VIRTUAL.  */
         qemu_account_warp_timer();
 
-        /* Run the timers here.  This is much more efficient than
-         * waking up the I/O thread and waiting for completion.
-         */
-        handle_icount_deadline();
-
         if (!cpu) {
             cpu = first_cpu;
         }
@@ -1342,30 +1289,18 @@
         while (cpu && !cpu->queued_work_first && !cpu->exit_request) {
 
             atomic_mb_set(&tcg_current_rr_cpu, cpu);
-            current_cpu = cpu;
 
             qemu_clock_enable(QEMU_CLOCK_VIRTUAL,
                               (cpu->singlestep_enabled & SSTEP_NOTIMER) == 0);
 
             if (cpu_can_run(cpu)) {
                 int r;
-
-                prepare_icount_for_run(cpu);
-
                 r = tcg_cpu_exec(cpu);
-
-                process_icount_data(cpu);
-
                 if (r == EXCP_DEBUG) {
                     cpu_handle_guest_debug(cpu);
                     break;
-                } else if (r == EXCP_ATOMIC) {
-                    qemu_mutex_unlock_iothread();
-                    cpu_exec_step_atomic(cpu);
-                    qemu_mutex_lock_iothread();
-                    break;
                 }
-            } else if (cpu->stop) {
+            } else if (cpu->stop || cpu->stopped) {
                 if (cpu->unplug) {
                     cpu = CPU_NEXT(cpu);
                 }
@@ -1373,6 +1308,14 @@
             }
 
             cpu = CPU_NEXT(cpu);
+
+            if (panda_exit_loop) { // If we have a request to break, do so and
+                                   // unset panda_exit_loop
+                panda_exit_loop = false;
+                //atomic_mb_set(&cpu->exit_request, 1); // XXX: Should we set an exit request?
+                break;
+            }
+
         } /* while (cpu && !cpu->exit_request).. */
 
         /* Does not need atomic_mb_set because a spurious wakeup is okay.  */
@@ -1382,8 +1325,11 @@
             atomic_mb_set(&cpu->exit_request, 0);
         }
 
-        qemu_tcg_wait_io_event(cpu ? cpu : QTAILQ_FIRST(&cpus));
+        handle_icount_deadline();
+
+        qemu_tcg_wait_io_event(QTAILQ_FIRST(&cpus));
         deal_with_unplugged_cpus();
+
     }
 
     return NULL;
@@ -1430,68 +1376,6 @@
 }
 #endif
 
-/* Multi-threaded TCG
- *
- * In the multi-threaded case each vCPU has its own thread. The TLS
- * variable current_cpu can be used deep in the code to find the
- * current CPUState for a given thread.
- */
-
-static void *qemu_tcg_cpu_thread_fn(void *arg)
-{
-    CPUState *cpu = arg;
-
-    g_assert(!use_icount);
-
-    rcu_register_thread();
-
-    qemu_mutex_lock_iothread();
-    qemu_thread_get_self(cpu->thread);
-
-    cpu->thread_id = qemu_get_thread_id();
-    cpu->created = true;
-    cpu->can_do_io = 1;
-    current_cpu = cpu;
-    qemu_cond_signal(&qemu_cpu_cond);
-
-    /* process any pending work */
-    cpu->exit_request = 1;
-
-    while (1) {
-        if (cpu_can_run(cpu)) {
-            int r;
-            r = tcg_cpu_exec(cpu);
-            switch (r) {
-            case EXCP_DEBUG:
-                cpu_handle_guest_debug(cpu);
-                break;
-            case EXCP_HALTED:
-                /* during start-up the vCPU is reset and the thread is
-                 * kicked several times. If we don't ensure we go back
-                 * to sleep in the halted state we won't cleanly
-                 * start-up when the vCPU is enabled.
-                 *
-                 * cpu->halted should ensure we sleep in wait_io_event
-                 */
-                g_assert(cpu->halted);
-                break;
-            case EXCP_ATOMIC:
-                qemu_mutex_unlock_iothread();
-                cpu_exec_step_atomic(cpu);
-                qemu_mutex_lock_iothread();
-            default:
-                /* Ignore everything else? */
-                break;
-            }
-        }
-
-        atomic_mb_set(&cpu->exit_request, 0);
-        qemu_tcg_wait_io_event(cpu);
-    }
-
-    return NULL;
-}
-
 static void qemu_cpu_kick_thread(CPUState *cpu)
 {
 #ifndef _WIN32
@@ -1522,7 +1406,7 @@
     qemu_cond_broadcast(cpu->halt_cond);
     if (tcg_enabled()) {
         cpu_exit(cpu);
-        /* NOP unless doing single-thread RR */
+        /* Also ensure current RR cpu is kicked */
         qemu_cpu_kick_rr_cpu();
     } else {
         if (hax_enabled()) {
@@ -1561,14 +1445,27 @@
 
 void qemu_mutex_lock_iothread(void)
 {
-    g_assert(!qemu_mutex_iothread_locked());
+    atomic_inc(&iothread_requesting_mutex);
+    /* In the simple case there is no need to bump the VCPU thread out of
+     * TCG code execution.
+     */
+    if (!tcg_enabled() || qemu_in_vcpu_thread() ||
+        !first_cpu || !first_cpu->created) {
+        qemu_mutex_lock(&qemu_global_mutex);
+        atomic_dec(&iothread_requesting_mutex);
+    } else {
+        if (qemu_mutex_trylock(&qemu_global_mutex)) {
+            qemu_cpu_kick_rr_cpu();
     qemu_mutex_lock(&qemu_global_mutex);
+        }
+        atomic_dec(&iothread_requesting_mutex);
+        qemu_cond_broadcast(&qemu_io_proceeded_cond);
+    }
     iothread_locked = true;
 }
 
 void qemu_mutex_unlock_iothread(void)
 {
-    g_assert(qemu_mutex_iothread_locked());
     iothread_locked = false;
     qemu_mutex_unlock(&qemu_global_mutex);
 }
@@ -1598,6 +1495,13 @@
 
     if (qemu_in_vcpu_thread()) {
         cpu_stop_current();
+        if (!kvm_enabled()) {
+            CPU_FOREACH(cpu) {
+                cpu->stop = false;
+                cpu->stopped = true;
+            }
+            return;
+        }
     }
 
     while (!all_vcpus_paused()) {
@@ -1646,43 +1550,29 @@
 static void qemu_tcg_init_vcpu(CPUState *cpu)
 {
     char thread_name[VCPU_THREAD_NAME_SIZE];
-    static QemuCond *single_tcg_halt_cond;
-    static QemuThread *single_tcg_cpu_thread;
+    static QemuCond *tcg_halt_cond;
+    static QemuThread *tcg_cpu_thread;
 
-    if (qemu_tcg_mttcg_enabled() || !single_tcg_cpu_thread) {
+    /* share a single thread for all cpus with TCG */
+    if (!tcg_cpu_thread) {
         cpu->thread = g_malloc0(sizeof(QemuThread));
         cpu->halt_cond = g_malloc0(sizeof(QemuCond));
         qemu_cond_init(cpu->halt_cond);
-
-        if (qemu_tcg_mttcg_enabled()) {
-            /* create a thread per vCPU with TCG (MTTCG) */
-            parallel_cpus = true;
+        tcg_halt_cond = cpu->halt_cond;
             snprintf(thread_name, VCPU_THREAD_NAME_SIZE, "CPU %d/TCG",
                  cpu->cpu_index);
-
             qemu_thread_create(cpu->thread, thread_name, qemu_tcg_cpu_thread_fn,
                                cpu, QEMU_THREAD_JOINABLE);
-
-        } else {
-            /* share a single thread for all cpus with TCG */
-            snprintf(thread_name, VCPU_THREAD_NAME_SIZE, "ALL CPUs/TCG");
-            qemu_thread_create(cpu->thread, thread_name,
-                               qemu_tcg_rr_cpu_thread_fn,
-                               cpu, QEMU_THREAD_JOINABLE);
-
-            single_tcg_halt_cond = cpu->halt_cond;
-            single_tcg_cpu_thread = cpu->thread;
-        }
 #ifdef _WIN32
         cpu->hThread = qemu_thread_get_handle(cpu->thread);
 #endif
         while (!cpu->created) {
             qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);
         }
+        tcg_cpu_thread = cpu->thread;
     } else {
-        /* For non-MTTCG cases we share the thread */
-        cpu->thread = single_tcg_cpu_thread;
-        cpu->halt_cond = single_tcg_halt_cond;
+        cpu->thread = tcg_cpu_thread;
+        cpu->halt_cond = tcg_halt_cond;
     }
 }
 
diff -bur qemu-2.9.1/cputlb.c panda/cputlb.c
--- qemu-2.9.1/cputlb.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/cputlb.c	2020-01-22 10:59:21.890782321 -0500
@@ -18,7 +18,6 @@
  */
 
 #include "qemu/osdep.h"
-#include "qemu/main-loop.h"
 #include "cpu.h"
 #include "exec/exec-all.h"
 #include "exec/memory.h"
@@ -33,6 +32,10 @@
 #include "exec/helper-proto.h"
 #include "qemu/atomic.h"
 
+#include "panda/rr/rr_log_all.h"
+#include "panda/rr/rr_log.h"
+#include "panda/callbacks/cb-support.h"
+
 /* DEBUG defines, enable DEBUG_TLB_LOG to log to the CPU_LOG_MMU target */
 /* #define DEBUG_TLB */
 /* #define DEBUG_TLB_LOG */
@@ -788,7 +791,6 @@
     hwaddr physaddr = iotlbentry->addr;
     MemoryRegion *mr = iotlb_to_region(cpu, physaddr, iotlbentry->attrs);
     uint64_t val;
-    bool locked = false;
 
     physaddr = (physaddr & TARGET_PAGE_MASK) + addr;
     cpu->mem_io_pc = retaddr;
@@ -797,16 +799,20 @@
     }
 
     cpu->mem_io_vaddr = addr;
-
-    if (mr->global_locking) {
-        qemu_mutex_lock_iothread();
-        locked = true;
-    }
+    if (mr->name && !strcmp(mr->name, "watch")){
     memory_region_dispatch_read(mr, physaddr, &val, size, iotlbentry->attrs);
-    if (locked) {
-        qemu_mutex_unlock_iothread();
+        return val;
     }
 
+    RR_DO_RECORD_OR_REPLAY(
+        /* action= */
+        memory_region_dispatch_read(mr, physaddr, &val, size, iotlbentry->attrs),
+        /* record= */ rr_input_8(&val),
+        /* replay= */ rr_input_8(&val),
+        /* location= */ RR_CALLSITE_IO_READ_ALL);
+
+    panda_callbacks_mmio_after_read(cpu, physaddr, size, val);
+
     return val;
 }
 
@@ -817,23 +823,32 @@
     CPUState *cpu = ENV_GET_CPU(env);
     hwaddr physaddr = iotlbentry->addr;
     MemoryRegion *mr = iotlb_to_region(cpu, physaddr, iotlbentry->attrs);
-    bool locked = false;
 
     physaddr = (physaddr & TARGET_PAGE_MASK) + addr;
     if (mr != &io_mem_rom && mr != &io_mem_notdirty && !cpu->can_do_io) {
         cpu_io_recompile(cpu, retaddr);
     }
+
     cpu->mem_io_vaddr = addr;
     cpu->mem_io_pc = retaddr;
 
-    if (mr->global_locking) {
-        qemu_mutex_lock_iothread();
-        locked = true;
+    if (mr->name && !strcmp(mr->name, "watch")){
+        memory_region_dispatch_write(mr, physaddr, val, size, iotlbentry->attrs);
+        return;
     }
+
+    if (mr != &io_mem_rom && mr != &io_mem_notdirty) {
+        RR_DO_RECORD_OR_REPLAY(
+            /* action= */
+            memory_region_dispatch_write(mr, physaddr, val, size, iotlbentry->attrs),
+            /* record= */ RR_NO_ACTION,
+            /* replay= */ RR_NO_ACTION,
+            /* location= */ RR_CALLSITE_IO_WRITE_ALL);
+    } else {
     memory_region_dispatch_write(mr, physaddr, val, size, iotlbentry->attrs);
-    if (locked) {
-        qemu_mutex_unlock_iothread();
     }
+
+    panda_callbacks_mmio_after_write(cpu, physaddr, size, val);
 }
 
 /* Return true if ADDR is present in the victim tlb, and has been copied

diff -bur qemu-2.9.1/disas.c panda/disas.c
--- qemu-2.9.1/disas.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/disas.c	2019-12-05 17:27:34.255984407 -0500
@@ -207,11 +207,11 @@
 
 #if defined(TARGET_I386)
     if (flags == 2) {
-        s.info.mach = bfd_mach_x86_64;
+        s.info.mach = bfd_mach_x86_64_intel_syntax;
     } else if (flags == 1) {
         s.info.mach = bfd_mach_i386_i8086;
     } else {
-        s.info.mach = bfd_mach_i386_i386;
+        s.info.mach = bfd_mach_i386_i386_intel_syntax;
     }
     s.info.print_insn = print_insn_i386;
 #elif defined(TARGET_PPC)

Only in panda/dtc: .git

diff -bur qemu-2.9.1/exec.c panda/exec.c
--- qemu-2.9.1/exec.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/exec.c	2019-12-12 11:07:05.624456348 -0500
@@ -48,6 +48,8 @@
 #include "sysemu/xen-mapcache.h"
 #include "trace-root.h"
 
+#include "panda/rr/rr_log.h"
+
 #ifdef CONFIG_FALLOCATE_PUNCH_HOLE
 #include <fcntl.h>
 #include <linux/falloc.h>
@@ -71,6 +73,10 @@
 #include "qemu/mmap-alloc.h"
 #endif
 
+#include <zlib.h>
+#include "panda/callbacks/cb-support.h"
+#include "panda/checkpoint.h"
+
 //#define DEBUG_SUBPAGE
 
 #if !defined(CONFIG_USER_ONLY)
@@ -636,6 +642,34 @@
 }
 
 #if !defined(CONFIG_USER_ONLY)
+
+MemoryListener rr_listener;
+
+static RR_mem_type rr_mem_region_type(MemoryRegion* mr) {
+    RR_mem_type mtype = RR_MEM_UNKNOWN;
+    if (!(memory_region_is_ram(mr) || memory_region_is_romd(mr))) {
+        mtype = RR_MEM_IO;
+    } else if (memory_region_is_ram(mr)) {
+        mtype = RR_MEM_RAM;
+    }
+    return mtype;
+}
+
+static void rr_mem_region_added_cb(MemoryListener *listener, MemoryRegionSection *section) {
+    if (!rr_in_record()) return;
+    RR_mem_type mtype = rr_mem_region_type(section->mr);
+
+    rr_mem_region_change_record(section->offset_within_address_space, int128_get64(section->size),
+                                section->mr->name, mtype, true);
+}
+
+static void rr_mem_region_deleted_cb(MemoryListener *listener, MemoryRegionSection *section) {
+    if (!rr_in_record()) return;
+    RR_mem_type mtype = rr_mem_region_type(section->mr);
+    rr_mem_region_change_record(section->offset_within_address_space, int128_get64(section->size),
+                                section->mr->name, mtype, false);
+}
+
 void cpu_address_space_init(CPUState *cpu, AddressSpace *as, int asidx)
 {
     CPUAddressSpace *newas;
@@ -661,6 +695,11 @@
     if (tcg_enabled()) {
         newas->tcg_as_listener.commit = tcg_commit;
         memory_listener_register(&newas->tcg_as_listener, as);
+
+        // PANDA Record and Replay
+        rr_listener.region_add = rr_mem_region_added_cb;
+        rr_listener.region_del = rr_mem_region_deleted_cb;
+        memory_listener_register(&rr_listener, as);
     }
 }
 
@@ -757,6 +796,8 @@
     return -ENOSYS;
 }
 #else
+
+
 /* Add a watchpoint.  */
 int cpu_watchpoint_insert(CPUState *cpu, vaddr addr, vaddr len,
                           int flags, CPUWatchpoint **watchpoint)
@@ -771,7 +812,7 @@
     }
     wp = g_malloc(sizeof(*wp));
 
-    wp->vaddr = addr;
+    wp->virtaddr = addr;
     wp->len = len;
     wp->flags = flags;
 
@@ -796,7 +837,7 @@
     CPUWatchpoint *wp;
 
     QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {
-        if (addr == wp->vaddr && len == wp->len
+        if (addr == wp->virtaddr && len == wp->len
                 && flags == (wp->flags & ~BP_WATCHPOINT_HIT)) {
             cpu_watchpoint_remove_by_ref(cpu, wp);
             return 0;
@@ -810,7 +851,7 @@
 {
     QTAILQ_REMOVE(&cpu->watchpoints, watchpoint, entry);
 
-    tlb_flush_page(cpu, watchpoint->vaddr);
+    tlb_flush_page(cpu, watchpoint->virtaddr);
 
     g_free(watchpoint);
 }
@@ -841,10 +882,10 @@
      * exactly at the top of the address space and so addr + len
      * wraps round to zero.
      */
-    vaddr wpend = wp->vaddr + wp->len - 1;
+    vaddr wpend = wp->virtaddr + wp->len - 1;
     vaddr addrend = addr + len - 1;
 
-    return !(addr > wpend || wp->vaddr > addrend);
+    return !(addr > wpend || wp->virtaddr > addrend);
 }
 
 #endif
@@ -858,6 +899,7 @@
     bp = g_malloc(sizeof(*bp));
 
     bp->pc = pc;
+    bp->rr_instr_count = 0;
     bp->flags = flags;
 
     /* keep all GDB-injected breakpoints in front */
@@ -875,6 +917,35 @@
     return 0;
 }
 
+int cpu_rr_breakpoint_insert(CPUState *cpu, uint64_t rr_instr_count, int flags,
+                          CPUBreakpoint **breakpoint)
+{
+    CPUBreakpoint *bp;
+
+    bp = g_malloc(sizeof(*bp));
+
+    bp->pc = 0;
+    bp->rr_instr_count = rr_instr_count;
+    bp->flags = flags;
+
+    /* keep all GDB-injected breakpoints in front */
+    if (flags & BP_GDB) {
+        QTAILQ_INSERT_HEAD(&cpu->breakpoints, bp, entry);
+    } else {
+        QTAILQ_INSERT_TAIL(&cpu->breakpoints, bp, entry);
+    }
+
+    //breakpoint_invalidate(cpu, pc);
+    tb_flush(cpu);
+    
+    printf("Inserted bp @ instr count %" PRIu64 "\n", rr_instr_count);
+
+    if (breakpoint) {
+        *breakpoint = bp;
+    }
+    return 0;
+}
+
 /* Remove a specific breakpoint.  */
 int cpu_breakpoint_remove(CPUState *cpu, vaddr pc, int flags)
 {
@@ -889,12 +960,26 @@
     return -ENOENT;
 }
 
+/* Remove a specific breakpoint by rr instr count.  */
+int cpu_breakpoint_remove_by_instr(CPUState *cpu, uint64_t rr_instr_count, int flags)
+{
+    CPUBreakpoint *bp;
+
+    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {
+        if (bp->rr_instr_count == rr_instr_count && bp->flags == flags) {
+            cpu_breakpoint_remove_by_ref(cpu, bp);
+            return 0;
+        }
+    }
+    return -ENOENT;
+}
+
 /* Remove a specific breakpoint by reference.  */
 void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint)
 {
     QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry);
 
-    breakpoint_invalidate(cpu, breakpoint->pc);
+    //breakpoint_invalidate(cpu, breakpoint->pc);
 
     g_free(breakpoint);
 }
@@ -911,6 +996,50 @@
     }
 }
 
+/*
+ * rw: Handles reverse-continue logic. Checks whether we are in first or second pass
+ * and whether we've finished scanning an entire checkpoint
+ */
+void cpu_rcont_check_restore(CPUState* cpu, uint64_t rr_instr_count){
+    
+    if (unlikely(cpu->reverse_flags & GDB_RCONT)) {
+        // If we've reached the end of this checkpoint region
+        if (rr_instr_count >= cpu->last_gdb_instr-1) {
+             int closest_num;
+             if ((closest_num = get_closest_checkpoint_num(cpu->last_gdb_instr-1)) < 0) {
+                fprintf(stderr, "get_closest_checkpoint_num %d\n", closest_num); 
+                abort();
+             }
+
+            if (cpu->last_bp_hit_instr == 0) {
+                // let's restart from the previous checkpoint
+
+                 if (closest_num == 1) {
+                    // No more checkpoints before this one! Insert bp at beginning
+                    cpu_rr_breakpoint_insert(cpu, 1, BP_GDB, NULL);
+                    cpu->reverse_flags = 0;
+                    panda_restore_by_num(1);
+                 }
+
+                 Checkpoint* prev_checkpoint;
+                 if ((prev_checkpoint = get_checkpoint(closest_num-1)) == NULL) {
+                     fprintf(stderr, "gen_intmed_code: get_checkpoint fail\n");
+                     abort();
+                 }
+
+                 cpu->last_gdb_instr = get_checkpoint(closest_num)->guest_instr_count;
+                 tb_flush(cpu);
+                 tlb_flush(cpu);
+                 panda_restore(prev_checkpoint);
+            } else {
+                // Re-run from checkpoint to latest breakpoint!
+                cpu->reverse_flags = GDB_RCONT_BREAK;
+                panda_restore_by_num(closest_num);
+            }
+        }
+    }
+}
+
 /* enable or disable single step mode. EXCP_DEBUG is returned by the
    CPU loop after each instruction */
 void cpu_single_step(CPUState *cpu, int enabled)
@@ -2214,6 +2343,17 @@
     CPUWatchpoint *wp;
     uint32_t cpu_flags;
 
+    uint64_t rr_instr_count = rr_get_guest_instr_count();
+
+    // If we disabled watchpoints in gdbstub for a step or continue, reenable
+    if (cpu->watchpoints_disabled){
+        cpu->watchpoints_disabled = false;
+        return;
+    }
+
+    // Handle reverse-continue action and possibly restore checkpoint
+    cpu_rcont_check_restore(cpu, rr_instr_count);
+
     if (cpu->watchpoint_hit) {
         /* We re-entered the check after replacing the TB. Now raise
          * the debug interrupt so that is will trigger after the
@@ -2221,8 +2361,10 @@
         cpu_interrupt(cpu, CPU_INTERRUPT_DEBUG);
         return;
     }
+
     vaddr = (cpu->mem_io_vaddr & TARGET_PAGE_MASK) + offset;
     vaddr = cc->adjust_watchpoint_address(cpu, vaddr, len);
+    
     QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {
         if (cpu_watchpoint_address_matches(wp, vaddr, len)
             && (wp->flags & flags)) {
@@ -2233,6 +2375,26 @@
             }
             wp->hitaddr = vaddr;
             wp->hitattrs = attrs;
+
+            if (unlikely(cpu->reverse_flags & GDB_RCONT)) {
+                // first pass of reverse-continue
+                // skip this watchpoint and record it
+                cpu->last_bp_hit_instr = rr_instr_count;
+                return;
+            }  else if (cpu->reverse_flags & GDB_RCONT_BREAK) {
+                // We are doing second pass of reverse-continue
+                // break on latest breakpoint/watchpoint 
+                if (rr_instr_count > cpu->last_bp_hit_instr) {
+                    fprintf(stderr, "GDB_RCONT_BREAK went too far");
+                    abort();
+                }
+
+                if  (!(rr_instr_count == cpu->last_bp_hit_instr)) {
+                    // if we're reverse-continuing to a certain point, ignore all other bps except the last one
+                    return;
+                }
+            }
+
             if (!cpu->watchpoint_hit) {
                 if (wp->flags & BP_CPU &&
                     !cc->debug_check_watchpoint(cpu, wp)) {
@@ -2241,14 +2403,20 @@
                 }
                 cpu->watchpoint_hit = wp;
 
-                /* Both tb_lock and iothread_mutex will be reset when
-                 * cpu_loop_exit or cpu_loop_exit_noexc longjmp
-                 * back into the cpu_exec main loop.
+                /* The tb_lock will be reset when cpu_loop_exit or
+                 * cpu_loop_exit_noexc longjmp back into the cpu_exec
+                 * main loop.
                  */
                 tb_lock();
                 tb_check_watchpoint(cpu);
-                if (wp->flags & BP_STOP_BEFORE_ACCESS) {
+
+                // We're done with reverse-continue, clear the flag
+                cpu->reverse_flags = 0;
+
+                // rw: Let's just break before access if we're in RR replay
+                if (wp->flags & BP_STOP_BEFORE_ACCESS || rr_in_replay()) {
                     cpu->exception_index = EXCP_DEBUG;
+                    cpu->rr_guest_instr_count -= 1;
                     cpu_loop_exit(cpu);
                 } else {
                     cpu_get_tb_cpu_state(env, &pc, &cs_base, &cpu_flags);
@@ -2475,19 +2643,13 @@
 
 static void io_mem_init(void)
 {
-    memory_region_init_io(&io_mem_rom, NULL, &unassigned_mem_ops, NULL, NULL, UINT64_MAX);
+    memory_region_init_io(&io_mem_rom, NULL, &unassigned_mem_ops, NULL, "rom", UINT64_MAX);
     memory_region_init_io(&io_mem_unassigned, NULL, &unassigned_mem_ops, NULL,
-                          NULL, UINT64_MAX);
-
-    /* io_mem_notdirty calls tb_invalidate_phys_page_fast,
-     * which can be called without the iothread mutex.
-     */
+                          "unassigned", UINT64_MAX);
     memory_region_init_io(&io_mem_notdirty, NULL, &notdirty_mem_ops, NULL,
-                          NULL, UINT64_MAX);
-    memory_region_clear_global_locking(&io_mem_notdirty);
-
+                          "notdirty", UINT64_MAX);
     memory_region_init_io(&io_mem_watch, NULL, &watch_mem_ops, NULL,
-                          NULL, UINT64_MAX);
+                          "watch", UINT64_MAX);
 }
 
 static void mem_begin(MemoryListener *listener)
@@ -2717,6 +2879,7 @@
     return release_lock;
 }
 
+
 /* Called within RCU critical section.  */
 static MemTxResult address_space_write_continue(AddressSpace *as, hwaddr addr,
                                                 MemTxAttrs attrs,
@@ -2735,30 +2898,51 @@
             l = memory_access_size(mr, l, addr1);
             /* XXX: could force current_cpu to NULL to avoid
                potential bugs */
+            /* Maybe we want to record the value of result in this switch statement */
             switch (l) {
             case 8:
                 /* 64 bit write access */
                 val = ldq_p(buf);
+                RR_DO_RECORD_OR_REPLAY(
+                /*action=*/
                 result |= memory_region_dispatch_write(mr, addr1, val, 8,
-                                                       attrs);
+                                                       attrs),
+                /*record=*/RR_NO_ACTION,
+                /*replay=*/RR_NO_ACTION,
+                /*location=*/RR_CALLSITE_WRITE_8);
                 break;
             case 4:
                 /* 32 bit write access */
                 val = (uint32_t)ldl_p(buf);
+                RR_DO_RECORD_OR_REPLAY(
+                /*action=*/
                 result |= memory_region_dispatch_write(mr, addr1, val, 4,
-                                                       attrs);
+                                                       attrs),
+                /*record=*/RR_NO_ACTION,
+                /*replay=*/RR_NO_ACTION,
+                /*location=*/RR_CALLSITE_WRITE_4);
                 break;
             case 2:
                 /* 16 bit write access */
                 val = lduw_p(buf);
+                RR_DO_RECORD_OR_REPLAY(
+                /*action=*/
                 result |= memory_region_dispatch_write(mr, addr1, val, 2,
-                                                       attrs);
+                                                       attrs),
+                /*record=*/RR_NO_ACTION,
+                /*replay=*/RR_NO_ACTION,
+                /*location=*/RR_CALLSITE_WRITE_2);
                 break;
             case 1:
                 /* 8 bit write access */
                 val = ldub_p(buf);
+                RR_DO_RECORD_OR_REPLAY(
+                /*action=*/
                 result |= memory_region_dispatch_write(mr, addr1, val, 1,
-                                                       attrs);
+                                                       attrs),
+                /*record=*/RR_NO_ACTION,
+                /*replay=*/RR_NO_ACTION,
+                /*location=*/RR_CALLSITE_WRITE_1);
                 break;
             default:
                 abort();
@@ -2766,7 +2950,14 @@
         } else {
             /* RAM case */
             ptr = qemu_ram_ptr_length(mr->ram_block, addr1, &l, false);
+            if (rr_in_record() && (rr_record_in_progress || rr_record_in_main_loop_wait)) {
+                // We should record the memory address relative to the address space, not physical memory.
+                // During replay, this address will be translated into the physical address.
+                rr_device_mem_rw_call_record(addr, buf, l, /*is_write*/1);
+            }
+            panda_callbacks_replay_before_dma(first_cpu, buf, addr1, l, true);
             memcpy(ptr, buf, l);
+            panda_callbacks_replay_after_dma(first_cpu, buf, addr1, l, true);
             invalidate_and_set_dirty(mr, addr1, l);
         }
 
@@ -2820,7 +3011,7 @@
     uint64_t val;
     MemTxResult result = MEMTX_OK;
     bool release_lock = false;
-
+    _Static_assert(sizeof(MemTxResult) == 4, "Unexpected size of MemTxResult (does not match rr_input_4)");
     for (;;) {
         if (!memory_access_is_direct(mr, false)) {
             /* I/O case */
@@ -2829,26 +3020,42 @@
             switch (l) {
             case 8:
                 /* 64 bit read access */
-                result |= memory_region_dispatch_read(mr, addr1, &val, 8,
-                                                      attrs);
+                RR_DO_RECORD_OR_REPLAY(
+                /*action=*/result |= memory_region_dispatch_read(mr, addr1, &val, 8,
+                                                      attrs),
+                /*record=*/rr_input_4(&result); rr_input_8(&val),
+                /*replay=*/rr_input_4(&result); rr_input_8(&val),
+                /*location=*/RR_CALLSITE_READ_8);
                 stq_p(buf, val);
                 break;
             case 4:
                 /* 32 bit read access */
-                result |= memory_region_dispatch_read(mr, addr1, &val, 4,
-                                                      attrs);
+                RR_DO_RECORD_OR_REPLAY(
+                /*action=*/result |= memory_region_dispatch_read(mr, addr1, &val, 4,
+                                                      attrs),
+                /*record=*/rr_input_4(&result); rr_input_8(&val),
+                /*replay=*/rr_input_4(&result); rr_input_8(&val),
+                /*location=*/RR_CALLSITE_READ_4);
                 stl_p(buf, val);
                 break;
             case 2:
                 /* 16 bit read access */
-                result |= memory_region_dispatch_read(mr, addr1, &val, 2,
-                                                      attrs);
+                RR_DO_RECORD_OR_REPLAY(
+                /*action=*/result |= memory_region_dispatch_read(mr, addr1, &val, 2,
+                                                      attrs),
+                /*record=*/rr_input_4(&result); rr_input_8(&val),
+                /*replay=*/rr_input_4(&result); rr_input_8(&val),
+                /*location=*/RR_CALLSITE_READ_2);
                 stw_p(buf, val);
                 break;
             case 1:
                 /* 8 bit read access */
-                result |= memory_region_dispatch_read(mr, addr1, &val, 1,
-                                                      attrs);
+                RR_DO_RECORD_OR_REPLAY(
+                /*action=*/result |= memory_region_dispatch_read(mr, addr1, &val, 1,
+                                                      attrs),
+                /*record=*/rr_input_4(&result); rr_input_8(&val),
+                /*replay=*/rr_input_4(&result); rr_input_8(&val),
+                /*location=*/RR_CALLSITE_READ_1);
                 stb_p(buf, val);
                 break;
             default:
@@ -2857,7 +3064,9 @@
         } else {
             /* RAM case */
             ptr = qemu_ram_ptr_length(mr->ram_block, addr1, &l, false);
+            panda_callbacks_replay_before_dma(first_cpu, buf, addr1, l, false);
             memcpy(buf, ptr, l);
+            panda_callbacks_replay_after_dma(first_cpu, buf, addr1, l, false);
         }
 
         if (release_lock) {
@@ -2910,13 +3119,29 @@
     }
 }
 
+
 void cpu_physical_memory_rw(hwaddr addr, uint8_t *buf,
                             int len, int is_write)
 {
     address_space_rw(&address_space_memory, addr, MEMTXATTRS_UNSPECIFIED,
                      buf, len, is_write);
+
+}
+
+// if safe == true that means we want this to fail for IO mem
+MemTxResult cpu_physical_memory_rw_ex(hwaddr addr, uint8_t *buf,
+                                     int len, int is_write, bool safe) {
+    hwaddr l = len;
+    hwaddr addr1;
+    MemoryRegion *mr = address_space_translate(&address_space_memory, addr, &addr1, &l, is_write);
+    if (safe && !memory_access_is_direct(mr, is_write)) {
+        return MEMTX_ERROR;
+    }
+    return address_space_rw(&address_space_memory, addr, MEMTXATTRS_UNSPECIFIED,
+                            buf, len, is_write);
 }
 
+
 enum write_rom_type {
     WRITE_DATA,
     FLUSH_CACHE,
@@ -2943,6 +3168,9 @@
             ptr = qemu_map_ram_ptr(mr->ram_block, addr1);
             switch (type) {
             case WRITE_DATA:
+                if (rr_in_record() && (rr_record_in_progress || rr_record_in_main_loop_wait)) {
+                    rr_device_mem_rw_call_record(addr1, buf, l, 1);
+                }
                 memcpy(ptr, buf, l);
                 invalidate_and_set_dirty(mr, addr1, l);
                 break;
@@ -3116,6 +3344,9 @@
     }
 }
 
+QLIST_HEAD(rr_map_list, RR_MapList) rr_map_list
+    = QLIST_HEAD_INITIALIZER(rr_map_list);
+
 /* Map a physical memory region into a host virtual address.
  * May map a subset of the requested range, given by and returned in *plen.
  * May return NULL if resources needed to perform the mapping are exhausted.
@@ -3170,6 +3401,16 @@
     ptr = qemu_ram_ptr_length(mr->ram_block, xlat, plen, true);
     rcu_read_unlock();
 
+    if (!rr_in_replay()) {
+        // Keep a list of these so we can find out when they change
+        RR_MapList *region = g_malloc(sizeof(*region));
+        region->addr = addr;
+        region->len = *plen; // can't use len because it was modified
+        region->ptr = ptr;
+        region->crc = crc32(crc32(0, Z_NULL, 0), region->ptr, region->len);
+        QLIST_INSERT_HEAD(&rr_map_list, region, link);
+    }
+
     return ptr;
 }
 
@@ -3187,12 +3428,33 @@
         mr = memory_region_from_host(buffer, &addr1);
         assert(mr != NULL);
         if (is_write) {
+            //bdg Save addr1,access_len,buffer contents
+            if (rr_in_record()) {
+                rr_device_mem_unmap_call_record(addr1, buffer, access_len, is_write);
+            }
             invalidate_and_set_dirty(mr, addr1, access_len);
         }
         if (xen_enabled()) {
             xen_invalidate_map_cache_entry(buffer);
         }
         memory_region_unref(mr);
+
+        // Remove it from the tracked map regions for rec/replay
+        if (!rr_in_replay()) {
+            RR_MapList *region;
+            bool found = false;
+            QLIST_FOREACH(region, &rr_map_list, link) {
+                if (region->ptr == buffer && region->len == len) {
+                    found = true;
+                    break;
+                }
+            }
+            if (found) {
+                QLIST_REMOVE(region, link);
+                g_free(region);
+            }
+        }
+
         return;
     }
     if (is_write) {

diff -bur qemu-2.9.1/gdbstub.c panda/gdbstub.c
--- qemu-2.9.1/gdbstub.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/gdbstub.c	2019-12-12 11:07:05.624456348 -0500
@@ -37,15 +37,14 @@
 #include "sysemu/kvm.h"
 #include "exec/semihost.h"
 #include "exec/exec-all.h"
+#include "panda/checkpoint.h"
 
 #ifdef CONFIG_USER_ONLY
 #define GDB_ATTACHED "0"
 #else
 #define GDB_ATTACHED "1"
 #endif
-
-static inline int target_memory_rw_debug(CPUState *cpu, target_ulong addr,
-                                         uint8_t *buf, int len, bool is_write)
+static inline int target_memory_rw_debug(CPUState *cpu, target_ulong addr, uint8_t *buf, int len, bool is_write)
 {
     CPUClass *cc = CPU_GET_CLASS(cpu);
 
@@ -271,7 +270,7 @@
         return -1;
 }
 
-//#define DEBUG_GDB
+/*#define DEBUG_GDB*/
 
 typedef struct GDBRegisterState {
     int base_reg;
@@ -387,6 +386,21 @@
 #endif
 }
 
+static void disable_cur_rr_bp_and_wp(CPUState* cpu) {
+	CPUBreakpoint* bp;
+	QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {
+		if (bp->rr_instr_count != 0 && rr_get_guest_instr_count() == bp->rr_instr_count) {
+			printf("temp removing bp at rr instr %" PRIu64 "\n", bp->rr_instr_count);
+			cpu_breakpoint_remove_by_instr(cpu, bp->rr_instr_count, BP_GDB);
+			cpu->temp_rr_bp_instr = bp->rr_instr_count;
+		}
+	}
+
+	// If we are currently broken at watchpoint, disable it until we get past it
+	// reenabled in exec.c: check_watchpoint
+	cpu->watchpoints_disabled = true;
+}
+
 /*
  * Resume execution, per CPU actions. For user-mode emulation it's
  * equivalent to gdb_continue.
@@ -422,10 +436,18 @@
             case 's':
                 cpu_single_step(cpu, sstep_flags);
                 cpu_resume(cpu);
+                
+				// If we are broken at an rr breakpoint, disable it before continuing
+                // and reenable it after we get past the instruction
+				disable_cur_rr_bp_and_wp(cpu);
                 flag = 1;
                 break;
             case 'c':
                 cpu_resume(cpu);
+				
+				// If we are broken at an rr breakpoint, disable it before continuing
+                // and reenable it after we get past the instruction
+				disable_cur_rr_bp_and_wp(cpu);
                 flag = 1;
                 break;
             default:
@@ -441,6 +463,7 @@
     return res;
 }
 
+
 static void put_buffer(GDBState *s, const uint8_t *buf, int len)
 {
 #ifdef CONFIG_USER_ONLY
@@ -641,22 +664,30 @@
     return 0;
 }
 
-static int gdb_write_register(CPUState *cpu, uint8_t *mem_buf, int reg)
+int gdb_write_register(CPUState *cpu, uint8_t *mem_buf, int reg)
 {
     CPUClass *cc = CPU_GET_CLASS(cpu);
     CPUArchState *env = cpu->env_ptr;
     GDBRegisterState *r;
+    int ret = 0;
+
 
     if (reg < cc->gdb_num_core_regs) {
-        return cc->gdb_write_register(cpu, mem_buf, reg);
+        ret = cc->gdb_write_register(cpu, mem_buf, reg);
     }
 
     for (r = cpu->gdb_regs; r; r = r->next) {
         if (r->base_reg <= reg && reg < r->base_reg + r->num_regs) {
-            return r->set_reg(env, mem_buf, reg - r->base_reg);
+            ret = r->set_reg(env, mem_buf, reg - r->base_reg);
         }
     }
-    return 0;
+    if (rr_in_record()) {
+        /* mm: to play along with the gdb rsp, the return value of 
+         * gdb_write_register *should* return the size of the register, which
+         * give us insight about the expected size of mem_buf */
+        rr_cpu_reg_write_call_record(cpu->cpu_index, mem_buf, reg, ret);
+    }
+    return ret;
 }
 
 /* Register a supplemental set of CPU registers.  If g_pos is nonzero it
@@ -720,6 +751,38 @@
 }
 #endif
 
+static int gdb_rr_breakpoint_insert(uint64_t instr_count, int type) {
+    CPUState* cpu;
+    int err = 0;
+
+    switch (type) {
+    case GDB_BREAKPOINT_SW:
+    case GDB_BREAKPOINT_HW:
+        CPU_FOREACH(cpu) {
+            err = cpu_rr_breakpoint_insert(cpu, instr_count, BP_GDB, NULL);
+            if (err) {
+                break;
+            }
+        }
+        return err;
+//#ifndef CONFIG_USER_ONLY
+    //case GDB_WATCHPOINT_WRITE:
+    //case GDB_WATCHPOINT_READ:
+    //case GDB_WATCHPOINT_ACCESS:
+        //CPU_FOREACH(cpu) {
+            //err = cpu_rrwatchpoint_insert(cpu, addr, len,
+                                        //xlat_gdb_type(cpu, type), NULL);
+            //if (err) {
+                //break;
+            //}
+        //}
+        //return err;
+//#endif
+    default:
+        return -ENOSYS;
+    }
+}
+
 static int gdb_breakpoint_insert(target_ulong addr, target_ulong len, int type)
 {
     CPUState *cpu;
@@ -757,6 +820,38 @@
     }
 }
 
+static int gdb_rr_breakpoint_remove(uint64_t instr, int type) {
+    CPUState *cpu;
+    int err = 0;
+
+    switch (type) {
+    case GDB_BREAKPOINT_SW:
+    case GDB_BREAKPOINT_HW:
+        CPU_FOREACH(cpu) {
+            err = cpu_breakpoint_remove_by_instr(cpu, instr, BP_GDB);
+            if (err) {
+                break;
+            }
+        }
+        return err;
+//#ifndef CONFIG_USER_ONLY
+    //case GDB_WATCHPOINT_WRITE:
+    //case GDB_WATCHPOINT_READ:
+    //case GDB_WATCHPOINT_ACCESS:
+        //CPU_FOREACH(cpu) {
+            //err = cpu_watchpoint_remove(cpu, addr, len,
+                                        //xlat_gdb_type(cpu, type));
+            //if (err)
+                //break;
+		/*}*/
+		/*return err;*/
+//#endif
+    default:
+        return -ENOSYS;
+    }
+	
+}
+
 static int gdb_breakpoint_remove(target_ulong addr, target_ulong len, int type)
 {
     CPUState *cpu;
@@ -940,6 +1035,110 @@
     return res;
 }
 
+static void gdb_handle_reverse(GDBState *s, const char *p) {
+	uint64_t cur_instr_count = rr_get_guest_instr_count();
+
+	if (*p == 's') {
+		// Reverse step
+		int res = gdb_rr_breakpoint_insert(cur_instr_count-1, GDB_BREAKPOINT_SW);
+		if (res < 0) {
+			put_packet(s, "E22");
+			return;
+		}
+		s->c_cpu->reverse_flags = GDB_RSTEP;
+		s->c_cpu->last_gdb_instr = cur_instr_count; 
+	} else if (*p == 'c') {
+		// Reverse continue
+		s->c_cpu->reverse_flags = GDB_RCONT ;
+		s->c_cpu->last_gdb_instr = cur_instr_count; 
+		s->c_cpu->last_bp_hit_instr = 0;
+	}
+
+	// revert to most recent checkpoint 
+	int closest_num;
+	if ((closest_num = get_closest_checkpoint_num(cur_instr_count)) < 0) {
+		fprintf(stderr, "gdb_handle_reverse: get_closest_checkpoint_num %d\n", closest_num); 
+		abort();
+	}
+
+	tb_flush(s->c_cpu);
+	tlb_flush(s->c_cpu);
+	panda_restore_by_num(closest_num);
+	gdb_continue(s);
+}
+
+static void gdb_handle_panda_cmd(GDBState *s, const char* p) {
+    char buf[MAX_PACKET_LENGTH] = {0};
+	char membuf[MAX_PACKET_LENGTH] = {0};
+
+    int chars_written;
+    if (!strncmp(p, "when", 4)) {
+        snprintf(membuf, sizeof(membuf), "%" PRIu64, rr_get_guest_instr_count());
+		
+		memtohex(buf, (uint8_t*)membuf, strlen(membuf));
+        put_packet(s, buf);
+    } else if (!strncmp(p, "rrbreakpoint", 12)) {
+        p+=12;
+        int membufsize = 0;
+        const char msg[] = "Added breakpoints at instructions";
+        snprintf(membuf, sizeof(membuf), msg); 
+        membufsize += sizeof(msg)-1;
+        while (*p == ':') {
+            p++;
+            uint64_t bpinstr = strtoull(p, (char **)&p, 10);
+            chars_written = snprintf(membuf+membufsize, sizeof(membuf), " %" PRIu64 ",", bpinstr); 
+            membufsize += chars_written;
+            gdb_rr_breakpoint_insert(bpinstr, GDB_BREAKPOINT_SW);
+        }
+
+		if (membufsize > MAX_PACKET_LENGTH/2)
+			membufsize = MAX_PACKET_LENGTH/2;
+        
+		memtohex(buf, (uint8_t*)membuf, membufsize);
+        put_packet(s, buf);
+    } else if (!strncmp(p, "rrdelete", 8)) {
+		// delete rr instr breakpoint
+		p += 8;
+        int membufsize = 0;
+        const char msg[] = "Deleted breakpoints at instructions";
+        snprintf(membuf, sizeof(membuf), msg); 
+        membufsize += sizeof(msg)-1;
+
+        while (*p == ':') {
+            p++;
+            uint64_t bpinstr = strtoull(p, (char **)&p, 10);
+            chars_written = snprintf(membuf+membufsize, sizeof(membuf), " %" PRIu64 ",", bpinstr); 
+            membufsize += chars_written;
+            gdb_rr_breakpoint_remove(bpinstr, GDB_BREAKPOINT_SW);
+        }
+
+		if (membufsize > MAX_PACKET_LENGTH/2)
+			membufsize = MAX_PACKET_LENGTH/2;
+        
+		memtohex(buf, (uint8_t*)membuf, membufsize);
+        put_packet(s, buf);
+	} else if (!strncmp(p, "rrlist", 6)) {
+		CPUBreakpoint *bp;
+        int membufsize = 0;
+        const char msg[] = "rr breakpoints: \n";
+        snprintf(membuf, sizeof(membuf), msg); 
+        membufsize += sizeof(msg)-1;
+
+        QTAILQ_FOREACH(bp, &s->c_cpu->breakpoints, entry) {
+           if (bp->rr_instr_count != 0) {
+				chars_written = snprintf(membuf+membufsize, sizeof(membuf), "%" PRIu64 "\n", bp->rr_instr_count);
+				membufsize += chars_written;
+            }
+		}
+        
+		if (membufsize > MAX_PACKET_LENGTH/2)
+			membufsize = MAX_PACKET_LENGTH/2;
+        
+		memtohex(buf, (uint8_t*)membuf, membufsize);
+        put_packet(s, buf);
+	}
+}
+
 static int gdb_handle_packet(GDBState *s, const char *line_buf)
 {
     CPUState *cpu;
@@ -958,6 +1157,10 @@
     p = line_buf;
     ch = *p++;
     switch(ch) {
+    case 'b':
+        gdb_handle_reverse(s, p);
+		put_packet(s, "OK");
+        break;
     case '?':
         /* TODO: Make this return the correct value for user-mode.  */
         snprintf(buf, sizeof(buf), "T%02xthread:%02x;", GDB_SIGNAL_TRAP,
@@ -1196,7 +1399,11 @@
     case 'q':
     case 'Q':
         /* parse any 'q' packets here */
-        if (!strcmp(p,"qemu.sstepbits")) {
+        if (!strncmp(p, "PandaCmd:", 9)) {
+            p += 9;
+            gdb_handle_panda_cmd(s, p);
+            break;
+        } else if (!strcmp(p,"qemu.sstepbits")) {
             /* Query Breakpoint bit definitions */
             snprintf(buf, sizeof(buf), "ENABLE=%x,NOIRQ=%x,NOTIMER=%x",
                      SSTEP_ENABLE,
@@ -1279,7 +1486,7 @@
         }
 #endif /* !CONFIG_USER_ONLY */
         if (is_query_packet(p, "Supported", ':')) {
-            snprintf(buf, sizeof(buf), "PacketSize=%x", MAX_PACKET_LENGTH);
+            snprintf(buf, sizeof(buf), "PacketSize=%x;ReverseContinue+;ReverseStep+", MAX_PACKET_LENGTH);
             cc = CPU_GET_CLASS(first_cpu);
             if (cc->gdb_core_xml_file != NULL) {
                 pstrcat(buf, sizeof(buf), ";qXfer:features:read+");
@@ -1387,7 +1594,7 @@
             snprintf(buf, sizeof(buf),
                      "T%02xthread:%02x;%swatch:" TARGET_FMT_lx ";",
                      GDB_SIGNAL_TRAP, cpu_index(cpu), type,
-                     (target_ulong)cpu->watchpoint_hit->vaddr);
+                     (target_ulong)cpu->watchpoint_hit->virtaddr);
             cpu->watchpoint_hit = NULL;
             goto send_packet;
         }

Only in panda/gdb-xml: i386-32bit-core.xml
Only in panda/gdb-xml: i386-64bit-core.xml
Only in panda: .git

diff -bur qemu-2.9.1/.gitignore panda/.gitignore
--- qemu-2.9.1/.gitignore	2017-09-07 12:25:12.000000000 -0400
+++ panda/.gitignore	2020-01-22 10:59:21.890782321 -0500
@@ -1,3 +1,5 @@
+venv
+/build
 /config-devices.*
 /config-all-devices.*
 /config-all-disas.*
@@ -79,6 +81,7 @@
 .sdk
 *.gcda
 *.gcno
+*.swp
 /pc-bios/bios-pq/status
 /pc-bios/vgabios-pq/status
 /pc-bios/optionrom/linuxboot.asm
@@ -108,6 +111,7 @@
 /docs/qemu-qmp-ref.info*
 /docs/qemu-qmp-ref.txt
 /docs/version.texi
+/panda/plugins/*/docs/
 *.tps
 .stgit-*
 cscope.*
@@ -115,6 +119,12 @@
 TAGS
 docker-src.*
 *~
+*.plist
+.gdb_history
+*plog.pb-c.c
+*plog.pb-c.h
+plog.proto
+build.inc.sh
 trace.h
 trace.c
 trace-ust.h

diff -bur qemu-2.9.1/.gitmodules panda/.gitmodules
--- qemu-2.9.1/.gitmodules	2017-09-07 12:25:12.000000000 -0400
+++ panda/.gitmodules	2019-12-05 18:07:39.503885772 -0500
@@ -18,7 +18,8 @@
 	url = git://git.qemu-project.org/openhackware.git
 [submodule "roms/qemu-palcode"]
 	path = roms/qemu-palcode
-	url = git://github.com/rth7680/qemu-palcode.git
+    # url = git://github.com/rth7680/qemu-palcode.git
+	url = https://github.com/rth7680/qemu-palcode.git
 [submodule "roms/sgabios"]
 	path = roms/sgabios
 	url = git://git.qemu-project.org/sgabios.git
@@ -27,7 +28,9 @@
 	url = git://anongit.freedesktop.org/pixman
 [submodule "dtc"]
 	path = dtc
-	url = git://git.qemu-project.org/dtc.git
+    #url = git://git.qemu-project.org/dtc.git
+    # url = git://git.qemu.org/dtc.git
+    url = https://github.com/qemu/dtc.git
 [submodule "roms/u-boot"]
 	path = roms/u-boot
 	url = git://git.qemu-project.org/u-boot.git

diff -bur qemu-2.9.1/hmp-commands.hx panda/hmp-commands.hx
--- qemu-2.9.1/hmp-commands.hx	2017-09-07 12:25:12.000000000 -0400
+++ panda/hmp-commands.hx	2019-12-05 17:27:34.279984406 -0500
@@ -1774,6 +1774,78 @@
         .sub_table  = info_cmds,
     },
 
+    {
+        .name       = "begin_record",
+        .args_type  = "file_name:s",
+        .params     = "[file_name]",
+        .help       = "begin recording for later replay",
+        .cmd = hmp_begin_record,
+    },
+
+    {
+        .name       = "begin_record_from",
+        .args_type  = "snapshot:s,file_name:s",
+        .params     = "[snapshot] [file_name]",
+        .help       = "begin recording from given snapshot for later replay",
+        .cmd = hmp_begin_record_from,
+    },
+
+    {
+        .name       = "end_record",
+        .args_type  = "",
+        .params     = "",
+        .help       = "end recording for later replay",
+        .cmd = hmp_end_record,
+    },
+
+    {
+        .name       = "begin_replay",
+        .args_type  = "file_name:s",
+        .params     = "[file_name]",
+        .help       = "begin to replay a record",
+        .cmd = hmp_begin_replay,
+    },
+
+    {
+        .name       = "load_plugin",
+        .args_type  = "plugin_name:s,plugin_args:s?",
+        .params     = "plugin_name [plugin_args]",
+        .help       = "Load a panda plugin",
+        .cmd = hmp_panda_load_plugin,
+    },
+
+    {
+        .name       = "unload_plugin",
+        .args_type  = "index:i",
+        .params     = "index",
+        .help       = "Unload a panda plugin",
+        .cmd = hmp_panda_unload_plugin,
+    },
+
+    {
+        .name       = "list_plugins",
+        .args_type  = "",
+        .params     = "",
+        .help       = "list the loaded plugins",
+        .cmd = hmp_panda_list_plugins,
+    },
+
+    {
+        .name       = "end_replay",
+        .args_type  = "",
+        .params     = "",
+        .help       = "end replay",
+        .cmd = hmp_end_replay,
+    },
+
+    {
+        .name       = "plugin_cmd",
+        .args_type  = "cmd:s",
+        .params     = "cmd",
+        .help       = "Execute a plugin monitor command",
+        .cmd        = hmp_panda_plugin_cmd,
+    },
+
 STEXI
 @end table
 ETEXI

diff -bur qemu-2.9.1/hmp.h panda/hmp.h
--- qemu-2.9.1/hmp.h	2017-09-07 12:25:12.000000000 -0400
+++ panda/hmp.h	2019-12-05 17:27:34.279984406 -0500
@@ -139,4 +139,17 @@
 void hmp_hotpluggable_cpus(Monitor *mon, const QDict *qdict);
 void hmp_info_vm_generation_id(Monitor *mon, const QDict *qdict);
 
+// PANDA Record/Replay HMP
+void hmp_begin_record(Monitor *mon, const QDict *qdict);
+void hmp_begin_record_from(Monitor *mon, const QDict *qdict);
+void hmp_begin_replay(Monitor *mon, const QDict *qdict);
+void hmp_end_record(Monitor *mon, const QDict *qdict);
+void hmp_end_replay(Monitor *mon, const QDict *qdict);
+
+// PANDA Plugins
+void hmp_panda_load_plugin(Monitor *mon, const QDict *qdict);
+void hmp_panda_unload_plugin(Monitor *mon, const QDict *qdict);
+void hmp_panda_list_plugins(Monitor *mon, const QDict *qdict);
+void hmp_panda_plugin_cmd(Monitor *mon, const QDict *qdict);
+
 #endif

diff -bur qemu-2.9.1/hw/arm/Makefile.objs panda/hw/arm/Makefile.objs
--- qemu-2.9.1/hw/arm/Makefile.objs	2017-09-07 12:25:12.000000000 -0400
+++ panda/hw/arm/Makefile.objs	2020-01-22 10:59:21.894782430 -0500
@@ -18,3 +18,4 @@
 obj-$(CONFIG_FSL_IMX31) += fsl-imx31.o kzm.o
 obj-$(CONFIG_FSL_IMX6) += fsl-imx6.o sabrelite.o
 obj-$(CONFIG_ASPEED_SOC) += aspeed_soc.o aspeed.o
+obj-y += rehosting.o

Only in panda/hw/arm: rehosting.c

diff -bur qemu-2.9.1/hw/char/serial.c panda/hw/char/serial.c
--- qemu-2.9.1/hw/char/serial.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/hw/char/serial.c	2019-12-12 11:07:05.624456348 -0500
@@ -31,6 +31,8 @@
 #include "exec/address-spaces.h"
 #include "qemu/error-report.h"
 
+#include "panda/rr/rr_log_all.h"
+
 //#define DEBUG_SERIAL
 
 #define UART_LCR_DLAB	0x80	/* Divisor latch access bit */
@@ -244,13 +246,23 @@
 
             if (s->fcr & UART_FCR_FE) {
                 assert(!fifo8_is_empty(&s->xmit_fifo));
+                uintptr_t fifo_addr =
+                    (uintptr_t)&s->xmit_fifo.data[s->xmit_fifo.head];
                 s->tsr = fifo8_pop(&s->xmit_fifo);
+                if (rr_in_record()) {
+                    rr_record_serial_send(RR_CALLSITE_SERIAL_SEND, fifo_addr,
+                                          s->tsr);
+                }
                 if (!s->xmit_fifo.num) {
                     s->lsr |= UART_LSR_THRE;
                 }
             } else {
                 s->tsr = s->thr;
                 s->lsr |= UART_LSR_THRE;
+                if (rr_in_record()) {
+                    rr_record_serial_send(RR_CALLSITE_SERIAL_SEND,
+                                          (uintptr_t)&s->thr, s->tsr);
+                }
             }
             if ((s->lsr & UART_LSR_THRE) && !s->thr_ipending) {
                 s->thr_ipending = 1;
@@ -327,13 +339,22 @@
             serial_update_parameters(s);
         } else {
             s->thr = (uint8_t) val;
+            uintptr_t iob_addr = (uintptr_t)&s->thr;
             if(s->fcr & UART_FCR_FE) {
                 /* xmit overruns overwrite data, so make space if needed */
                 if (fifo8_is_full(&s->xmit_fifo)) {
                     fifo8_pop(&s->xmit_fifo);
                 }
+                // FIFO is enabled, override the default IO buffer address.
+                iob_addr = (uintptr_t)&s->xmit_fifo
+                               .data[(s->xmit_fifo.head + s->xmit_fifo.num) %
+                                     s->xmit_fifo.capacity];
                 fifo8_push(&s->xmit_fifo, s->thr);
             }
+            if (rr_in_record()) {
+                rr_record_serial_write(RR_CALLSITE_SERIAL_WRITE, iob_addr,
+                                       s->io.addr, s->thr);
+            }
             s->thr_ipending = 0;
             s->lsr &= ~UART_LSR_THRE;
             s->lsr &= ~UART_LSR_TEMT;
@@ -473,8 +494,15 @@
             ret = s->divider & 0xff;
         } else {
             if(s->fcr & UART_FCR_FE) {
+                bool record = rr_in_record() && !fifo8_is_empty(&s->recv_fifo);
+                uintptr_t fifo_addr =
+                    (uintptr_t)&s->recv_fifo.data[s->recv_fifo.head];
                 ret = fifo8_is_empty(&s->recv_fifo) ?
                             0 : fifo8_pop(&s->recv_fifo);
+                if (record) {
+                    rr_record_serial_read(RR_CALLSITE_SERIAL_READ, fifo_addr,
+                                          s->io.addr, ret);
+                }
                 if (s->recv_fifo.num == 0) {
                     s->lsr &= ~(UART_LSR_DR | UART_LSR_BI);
                 } else {
@@ -483,6 +511,10 @@
                 s->timeout_ipending = 0;
             } else {
                 ret = s->rbr;
+                if (rr_in_record()) {
+                    rr_record_serial_read(RR_CALLSITE_SERIAL_READ,
+                                          (uintptr_t)&s->rbr, s->io.addr, ret);
+                }
                 s->lsr &= ~(UART_LSR_DR | UART_LSR_BI);
             }
             serial_update_irq(s);
@@ -601,7 +633,16 @@
     if(s->fcr & UART_FCR_FE) {
         int i;
         for (i = 0; i < size; i++) {
+            uintptr_t fifo_addr =
+                (uintptr_t)&s->recv_fifo
+                    .data[(s->recv_fifo.head + s->recv_fifo.num) %
+                          s->recv_fifo.capacity];
+
             recv_fifo_put(s, buf[i]);
+            if (rr_in_record()) {
+                rr_record_serial_receive(RR_CALLSITE_SERIAL_RECEIVE, fifo_addr,
+                                         buf[i]);
+            }
         }
         s->lsr |= UART_LSR_DR;
         /* call the timeout receive callback in 4 char transmit time */
@@ -610,6 +651,10 @@
         if (s->lsr & UART_LSR_DR)
             s->lsr |= UART_LSR_OE;
         s->rbr = buf[0];
+        if (rr_in_record()) {
+            rr_record_serial_receive(RR_CALLSITE_SERIAL_RECEIVE,
+                                     (uintptr_t)&s->rbr, buf[0]);
+        }
         s->lsr |= UART_LSR_DR;
     }
     serial_update_irq(s);

diff -bur qemu-2.9.1/hw/core/irq.c panda/hw/core/irq.c
--- qemu-2.9.1/hw/core/irq.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/hw/core/irq.c	2019-12-05 17:27:34.299984405 -0500
@@ -22,7 +22,6 @@
  * THE SOFTWARE.
  */
 #include "qemu/osdep.h"
-#include "qemu/main-loop.h"
 #include "qemu-common.h"
 #include "hw/irq.h"
 #include "qom/object.h"

diff -bur qemu-2.9.1/hw/i386/kvmvapic.c panda/hw/i386/kvmvapic.c
--- qemu-2.9.1/hw/i386/kvmvapic.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/hw/i386/kvmvapic.c	2019-12-05 17:27:34.315984404 -0500
@@ -457,8 +457,8 @@
     resume_all_vcpus();
 
     if (!kvm_enabled()) {
-        /* Both tb_lock and iothread_mutex will be reset when
-         *  longjmps back into the cpu_exec loop. */
+        /* tb_lock will be reset when cpu_loop_exit_noexc longjmps
+         * back into the cpu_exec loop. */
         tb_lock();
         tb_gen_code(cs, current_pc, current_cs_base, current_flags, 1);
         cpu_loop_exit_noexc(cs);

diff -bur qemu-2.9.1/hw/i386/pc_piix.c panda/hw/i386/pc_piix.c
--- qemu-2.9.1/hw/i386/pc_piix.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/hw/i386/pc_piix.c	2019-12-05 17:27:34.315984404 -0500
@@ -230,7 +230,7 @@
 
     assert(pcms->vmport != ON_OFF_AUTO__MAX);
     if (pcms->vmport == ON_OFF_AUTO_AUTO) {
-        pcms->vmport = xen_enabled() ? ON_OFF_AUTO_OFF : ON_OFF_AUTO_ON;
+        pcms->vmport = ON_OFF_AUTO_OFF;
     }
 
     /* init basic PC hardware */
@@ -441,7 +441,7 @@
 {
     pc_i440fx_machine_options(m);
     m->alias = "pc";
-    m->is_default = 1;
+    m->is_default = 0;
 }
 
 DEFINE_I440FX_MACHINE(v2_9, "pc-i440fx-2.9", NULL,
@@ -450,7 +450,7 @@
 static void pc_i440fx_2_8_machine_options(MachineClass *m)
 {
     pc_i440fx_2_9_machine_options(m);
-    m->is_default = 0;
+    m->is_default = 1;
     m->alias = NULL;
     SET_MACHINE_COMPAT(m, PC_COMPAT_2_8);
 }
@@ -462,6 +462,7 @@
 static void pc_i440fx_2_7_machine_options(MachineClass *m)
 {
     pc_i440fx_2_8_machine_options(m);
+    m->is_default = 0;
     SET_MACHINE_COMPAT(m, PC_COMPAT_2_7);
 }
 
diff -bur qemu-2.9.1/hw/i386/pc_q35.c panda/hw/i386/pc_q35.c
--- qemu-2.9.1/hw/i386/pc_q35.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/hw/i386/pc_q35.c	2019-12-05 17:27:34.319984404 -0500
@@ -222,7 +222,7 @@
 
     assert(pcms->vmport != ON_OFF_AUTO__MAX);
     if (pcms->vmport == ON_OFF_AUTO_AUTO) {
-        pcms->vmport = xen_enabled() ? ON_OFF_AUTO_OFF : ON_OFF_AUTO_ON;
+        pcms->vmport = ON_OFF_AUTO_OFF;
     }
 
     /* init basic PC hardware */

diff -bur qemu-2.9.1/hw/ide/core.c panda/hw/ide/core.c
--- qemu-2.9.1/hw/ide/core.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/hw/ide/core.c	2019-12-12 11:07:05.624456348 -0500
@@ -37,6 +37,32 @@
 
 #include "hw/ide/internal.h"
 
+#include "panda/rr/rr_log_all.h"
+
+// RW record scatter-gather DMA transfers for taint
+static void rr_record_sg_transfer(IDEState *s, Hd_transfer_type type,
+        int64_t sector_num, int num_sectors){
+    assert(s);
+    assert(s->sg.size == num_sectors * 512);
+    int i;
+    int64_t cur_sector = sector_num;
+    for (i = 0; i < s->sg.nsg; i++){
+        if (type == HD_TRANSFER_RAM_TO_HD){
+            rr_record_hd_transfer(RR_CALLSITE_IDE_DMA_CB, type,
+                s->sg.sg[i].base, cur_sector * 512, s->sg.sg[i].len);
+        }
+        else if (type == HD_TRANSFER_HD_TO_RAM){
+            rr_record_hd_transfer(RR_CALLSITE_IDE_DMA_CB, type,
+                cur_sector * 512, s->sg.sg[i].base, s->sg.sg[i].len);
+        }
+        else {
+            // Wrong transfer type
+            assert(0);
+        }
+        cur_sector += s->sg.sg[i].len / 512;
+    }
+}
+
 /* These values were based on a Seagate ST3500418AS but have been modified
    to make more sense in QEMU */
 static const int smart_attributes[][12] = {
@@ -755,6 +781,15 @@
     s->iov.iov_len  = n * BDRV_SECTOR_SIZE;
     qemu_iovec_init_external(&s->qiov, &s->iov, 1);
 
+    if ((!(s->drive_kind == IDE_CD)) && (rr_in_record())) {
+        rr_record_hd_transfer(
+            RR_CALLSITE_IDE_SECTOR_READ,
+            HD_TRANSFER_HD_TO_IOB,
+            sector_num*512,
+            (uintptr_t)s->io_buffer,
+            n*512);
+    }
+
     block_acct_start(blk_get_stats(s->blk), &s->acct,
                      n * BDRV_SECTOR_SIZE, BLOCK_ACCT_READ);
     s->pio_aiocb = ide_buffered_readv(s, sector_num, &s->qiov, n,
@@ -881,10 +916,16 @@
     offset = sector_num << BDRV_SECTOR_BITS;
     switch (s->dma_cmd) {
     case IDE_DMA_READ:
+        if ((!(s->drive_kind == IDE_CD) && (rr_in_record()))) {
+            rr_record_sg_transfer(s, HD_TRANSFER_HD_TO_RAM, sector_num, n);
+        }
         s->bus->dma->aiocb = dma_blk_read(s->blk, &s->sg, offset,
                                           BDRV_SECTOR_SIZE, ide_dma_cb, s);
         break;
     case IDE_DMA_WRITE:
+        if ((!(s->drive_kind == IDE_CD) && (rr_in_record()))) {
+            rr_record_sg_transfer(s, HD_TRANSFER_RAM_TO_HD, sector_num, n);
+        }
         s->bus->dma->aiocb = dma_blk_write(s->blk, &s->sg, offset,
                                            BDRV_SECTOR_SIZE, ide_dma_cb, s);
         break;
@@ -1023,6 +1064,15 @@
     s->iov.iov_len  = n * BDRV_SECTOR_SIZE;
     qemu_iovec_init_external(&s->qiov, &s->iov, 1);
 
+    if ((s->drive_kind == IDE_HD) && (rr_in_record())) {
+        rr_record_hd_transfer(
+            RR_CALLSITE_IDE_SECTOR_WRITE,
+            HD_TRANSFER_IOB_TO_HD,
+            (uintptr_t)s->io_buffer,
+            sector_num*512,
+            n*512);
+    }
+
     block_acct_start(blk_get_stats(s->blk), &s->acct,
                      n * BDRV_SECTOR_SIZE, BLOCK_ACCT_WRITE);
     s->pio_aiocb = blk_aio_pwritev(s->blk, sector_num << BDRV_SECTOR_BITS,
@@ -2227,6 +2277,20 @@
         return;
     }
 
+    // TRL hd taint
+    // this is a transfer from port to io_buffer
+    // 0x1f0-0x1f7, 0x3f6-0x3f7 is hd
+    if ((rr_in_record())
+            && (((addr >= 0x1f0) && (addr <= 0x1f7))
+                || (addr == 0x3f6) || (addr == 0x3f7))){
+        rr_record_hd_transfer
+            (RR_CALLSITE_IDE_DATA_WRITEW,
+             HD_TRANSFER_PORT_TO_IOB,
+             addr,
+             (uintptr_t)s->data_ptr,
+             2);
+	}
+
     *(uint16_t *)p = le16_to_cpu(val);
     p += 2;
     s->data_ptr = p;
@@ -2254,6 +2318,20 @@
         return 0;
     }
 
+    // TRL hd taint
+    // this is transfer from io_buffer to port 
+    // 0x1f0-0x1f7, 0x3f6-0x3f7 is hd
+    if ((rr_in_record())
+            && (((addr >= 0x1f0) && (addr <= 0x1f7))
+                || (addr == 0x3f6) || (addr == 0x3f7))){
+        rr_record_hd_transfer
+            (RR_CALLSITE_IDE_DATA_READW,
+             HD_TRANSFER_IOB_TO_PORT,
+             (uintptr_t)s->data_ptr,
+             addr, 
+             2);
+    }
+
     ret = cpu_to_le16(*(uint16_t *)p);
     p += 2;
     s->data_ptr = p;
@@ -2281,6 +2359,20 @@
         return;
     }
 
+	// TRL hd taint
+    // this is a transfer from port to io_buffer
+    // 0x1f0-0x1f7, 0x3f6-0x3f7 is hd
+    if ((rr_in_record())
+            && (((addr >= 0x1f0) && (addr <= 0x1f7))
+                || (addr == 0x3f6) || (addr == 0x3f7))){
+        rr_record_hd_transfer
+            (RR_CALLSITE_IDE_DATA_WRITEL,
+             HD_TRANSFER_PORT_TO_IOB,
+             addr, 
+             (uintptr_t)s->data_ptr,
+             4);
+    }
+
     *(uint32_t *)p = le32_to_cpu(val);
     p += 4;
     s->data_ptr = p;
@@ -2308,6 +2400,20 @@
         return 0;
     }
 
+    // TRL hd taint
+    // this is transfer from io_buffer to port 
+    // 0x1f0-0x1f7, 0x3f6-0x3f7 is hd
+    if ((rr_in_record())
+            && (((addr >= 0x1f0) && (addr <= 0x1f7))
+                || (addr == 0x3f6) || (addr == 0x3f7))){
+        rr_record_hd_transfer
+            (RR_CALLSITE_IDE_DATA_READL,
+             HD_TRANSFER_IOB_TO_PORT,
+             (uintptr_t)s->data_ptr,
+             addr,
+             4);
+    }
+
     ret = cpu_to_le32(*(uint32_t *)p);
     p += 4;
     s->data_ptr = p;

diff -bur qemu-2.9.1/hw/intc/apic_common.c panda/hw/intc/apic_common.c
--- qemu-2.9.1/hw/intc/apic_common.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/hw/intc/apic_common.c	2019-12-05 17:27:34.323984404 -0500
@@ -387,6 +387,25 @@
     return s->wait_for_sipi != 0;
 }
 
+static bool apic_irq_delivered_needed(void *opaque)
+{
+    APICCommonState *s = APIC_COMMON(opaque);
+    return s->cpu == X86_CPU(first_cpu) && apic_irq_delivered != 0;
+}
+
+static void apic_irq_delivered_pre_save(void *opaque)
+{
+    APICCommonState *s = APIC_COMMON(opaque);
+    s->apic_irq_delivered = apic_irq_delivered;
+}
+
+static int apic_irq_delivered_post_load(void *opaque, int version_id)
+{
+    APICCommonState *s = APIC_COMMON(opaque);
+    apic_irq_delivered = s->apic_irq_delivered;
+    return 0;
+}
+
 static const VMStateDescription vmstate_apic_common_sipi = {
     .name = "apic_sipi",
     .version_id = 1,
@@ -399,6 +418,19 @@
     }
 };
 
+static const VMStateDescription vmstate_apic_irq_delivered = {
+    .name = "apic_irq_delivered",
+    .version_id = 1,
+    .minimum_version_id = 1,
+    .needed = apic_irq_delivered_needed,
+    .pre_save = apic_irq_delivered_pre_save,
+    .post_load = apic_irq_delivered_post_load,
+    .fields = (VMStateField[]) {
+        VMSTATE_INT32(apic_irq_delivered, APICCommonState),
+        VMSTATE_END_OF_LIST()
+    }
+};
+
 static const VMStateDescription vmstate_apic_common = {
     .name = "apic",
     .version_id = 3,
@@ -433,6 +465,7 @@
     },
     .subsections = (const VMStateDescription*[]) {
         &vmstate_apic_common_sipi,
+        &vmstate_apic_irq_delivered,
         NULL
     }
 };

diff -bur qemu-2.9.1/hw/intc/arm_gicv3_cpuif.c panda/hw/intc/arm_gicv3_cpuif.c
--- qemu-2.9.1/hw/intc/arm_gicv3_cpuif.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/hw/intc/arm_gicv3_cpuif.c	2019-12-05 17:27:34.323984404 -0500
@@ -14,7 +14,6 @@
 
 #include "qemu/osdep.h"
 #include "qemu/bitops.h"
-#include "qemu/main-loop.h"
 #include "trace.h"
 #include "gicv3_internal.h"
 #include "cpu.h"
@@ -742,8 +741,6 @@
     ARMCPU *cpu = ARM_CPU(cs->cpu);
     CPUARMState *env = &cpu->env;
 
-    g_assert(qemu_mutex_iothread_locked());
-
     trace_gicv3_cpuif_update(gicv3_redist_affid(cs), cs->hppi.irq,
                              cs->hppi.grp, cs->hppi.prio);
 
diff -bur qemu-2.9.1/hw/net/e1000.c panda/hw/net/e1000.c
--- qemu-2.9.1/hw/net/e1000.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/hw/net/e1000.c	2019-12-12 11:07:05.624456348 -0500
@@ -40,6 +40,9 @@
 
 static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
 
+#include "panda/network.h"
+#include "panda/rr/rr_log_all.h"
+
 /* #define E1000_DEBUG */
 
 #ifdef E1000_DEBUG
@@ -254,6 +257,35 @@
     }
 }
 
+#if defined(E1000_DEBUG)
+// RW Yanked from net.c
+static void hex_dump(FILE *f, const uint8_t *buf, int size)
+{
+    int len, i, j, c;
+
+    for(i=0;i<size;i+=16) {
+        len = size - i;
+        if (len > 16)
+            len = 16;
+        fprintf(f, "%08x ", i);
+        for(j=0;j<16;j++) {
+            if (j < len)
+                fprintf(f, " %02x", buf[i+j]);
+            else
+                fprintf(f, "   ");
+        }
+        fprintf(f, " ");
+        for(j=0;j<len;j++) {
+            c = buf[i+j];
+            if (c < ' ' || c > '~')
+                c = '.';
+            fprintf(f, "%c", c);
+        }
+        fprintf(f, "\n");
+    }
+}
+#endif
+
 static void
 set_interrupt_cause(E1000State *s, int index, uint32_t val)
 {
@@ -585,11 +617,29 @@
                tp->props.ipcss, tp->props.ipcse);
     }
     if (tp->vlan_needed) {
+        // RW TODO add VLAN support if necessary.  Doesn't seem necessary right
+        // now.
         memmove(tp->vlan, tp->data, 4);
         memmove(tp->data, tp->data + 4, 8);
         memcpy(tp->data + 8, tp->vlan_header, 4);
+        #ifdef E1000_DEBUG
+        printf("e1000 process_tx_desc in_xmit_seg\n");
+        hex_dump(stdout, tp->data, tp->size);
+        #endif
+        if (rr_in_record()){
+            rr_record_handle_packet_call(RR_CALLSITE_E1000_XMIT_SEG_1, tp->vlan,
+                                         tp->size + 4, PANDA_NET_TX);
+        }
         e1000_send_packet(s, tp->vlan, tp->size + 4);
     } else {
+        #ifdef E1000_DEBUG
+        printf("e1000 process_tx_desc in_xmit_seg\n");
+        hex_dump(stdout, tp->data, tp->size);
+        #endif
+        if (rr_in_record()){
+            rr_record_handle_packet_call(RR_CALLSITE_E1000_XMIT_SEG_2, tp->data,
+                                         tp->size, PANDA_NET_TX);
+        }
         e1000_send_packet(s, tp->data, tp->size);
     }
 
@@ -651,15 +701,30 @@
                 bytes = msh - tp->size;
 
             bytes = MIN(sizeof(tp->data) - tp->size, bytes);
+            // RW DMA read for packet send?
+            // taint transfer mem->io
+            if (rr_in_record()){
+                rr_record_net_transfer(RR_CALLSITE_E1000_PROCESS_TX_DESC_1,
+                                       NET_TRANSFER_RAM_TO_IOB, addr,
+                                       (uintptr_t)(tp->data + tp->size), bytes);
+            }
             pci_dma_read(d, addr, tp->data + tp->size, bytes);
             sz = tp->size + bytes;
             if (sz >= tp->props.hdr_len && tp->size < tp->props.hdr_len) {
+                if (rr_in_record()){
+                    rr_record_net_transfer(RR_CALLSITE_E1000_PROCESS_TX_DESC_MEMMOVE_1,
+                                           NET_TRANSFER_IOB_TO_IOB, (uintptr_t)tp->data, (uintptr_t)tp->header, tp->props.hdr_len);
+                }
                 memmove(tp->header, tp->data, tp->props.hdr_len);
             }
             tp->size = sz;
             addr += bytes;
             if (sz == msh) {
                 xmit_seg(s);
+                if (rr_in_record()){
+                    rr_record_net_transfer(RR_CALLSITE_E1000_PROCESS_TX_DESC_MEMMOVE_2,
+                                           NET_TRANSFER_IOB_TO_IOB, (uintptr_t)tp->header, (uintptr_t)tp->data, tp->props.hdr_len);
+                }
                 memmove(tp->data, tp->header, tp->props.hdr_len);
                 tp->size = tp->props.hdr_len;
             }
@@ -670,6 +735,13 @@
         DBGOUT(TXERR, "TCP segmentation error\n");
     } else {
         split_size = MIN(sizeof(tp->data) - tp->size, split_size);
+        // RW DMA read for packet send?
+        // taint transfer mem->io
+        if (rr_in_record()){
+            rr_record_net_transfer(RR_CALLSITE_E1000_PROCESS_TX_DESC_2,
+                                   NET_TRANSFER_RAM_TO_IOB, (uintptr_t)addr, (uintptr_t)(tp->data + tp->size),
+                                   split_size);
+        }
         pci_dma_read(d, addr, tp->data + tp->size, split_size);
         tp->size += split_size;
     }
@@ -699,6 +771,14 @@
     dp->upper.data = cpu_to_le32(txd_upper);
     pci_dma_write(d, base + ((char *)&dp->upper - (char *)dp),
                   &dp->upper, sizeof(dp->upper));
+    // RW write descriptor to DMA
+    // taint transfer io->mem
+    if (rr_in_record()){
+        rr_record_net_transfer(RR_CALLSITE_E1000_TXDESC_WRITEBACK,
+                               NET_TRANSFER_IOB_TO_RAM, (uintptr_t)(&dp->upper),
+                               (uintptr_t)(base + ((char *)&dp->upper - (char *)dp)),
+                               sizeof(dp->upper));
+    }
     return E1000_ICR_TXDW;
 }
 
@@ -726,6 +806,12 @@
     while (s->mac_reg[TDH] != s->mac_reg[TDT]) {
         base = tx_desc_base(s) +
                sizeof(struct e1000_tx_desc) * s->mac_reg[TDH];
+        // RW read descriptor from DMA
+        // taint transfer mem->io
+        if (rr_in_record()){
+            rr_record_net_transfer(RR_CALLSITE_E1000_START_XMIT,
+                                   NET_TRANSFER_RAM_TO_IOB, base, (uintptr_t)(&desc), sizeof(desc));
+        }
         pci_dma_read(d, base, &desc, sizeof(desc));
 
         DBGOUT(TX, "index %d: %p : %x %x\n", s->mac_reg[TDH],
@@ -851,6 +937,8 @@
     uint32_t rdh_start;
     uint16_t vlan_special = 0;
     uint8_t vlan_status = 0;
+    // SAC this local disappeared?
+    //uint8_t vlan_offset = 0;
     uint8_t min_buf[MIN_BUF_SIZE];
     struct iovec min_iov;
     uint8_t *filter_buf = iov->iov_base;
@@ -866,7 +954,14 @@
 
     /* Pad to minimum Ethernet frame length */
     if (size < sizeof(min_buf)) {
+        // SAC this function has changed since PANDA 1.0
+        // Hopefully this is correct
+        if (rr_in_record()){
+            rr_record_net_transfer(RR_CALLSITE_E1000_RECEIVE_MEMCPY_1,
+                                NET_TRANSFER_IOB_TO_IOB, (uintptr_t)min_buf, (uintptr_t)iov->iov_base, size);
+        }
         iov_to_buf(iov, iovcnt, 0, min_buf, size);
+        // RW shouldn't need to worry about this memset for taint
         memset(&min_buf[size], 0, sizeof(min_buf) - size);
         e1000x_inc_reg_if_not_full(s->mac_reg, RUC);
         min_iov.iov_base = filter_buf = min_buf;
@@ -874,6 +969,11 @@
         iovcnt = 1;
         iov = &min_iov;
     } else if (iov->iov_len < MAXIMUM_ETHERNET_HDR_LEN) {
+        // SAC something should also happen here, if we didnt take the other branch
+        if (rr_in_record()){
+            rr_record_net_transfer(RR_CALLSITE_E1000_RECEIVE_MEMCPY_1,
+                                NET_TRANSFER_IOB_TO_IOB, (uintptr_t)min_buf, (uintptr_t)iov->iov_base, MAXIMUM_ETHERNET_HDR_LEN);
+        }
         /* This is very unlikely, but may happen. */
         iov_to_buf(iov, iovcnt, 0, min_buf, MAXIMUM_ETHERNET_HDR_LEN);
         filter_buf = min_buf;
@@ -892,6 +992,8 @@
         e1000x_is_vlan_packet(filter_buf, le16_to_cpu(s->mac_reg[VET]))) {
         vlan_special = cpu_to_le16(lduw_be_p(filter_buf + 14));
         iov_ofs = 4;
+        // SAC this function has changed since PANDA 1.0
+        // RW TODO enable VLAN if necessary
         if (filter_buf == iov->iov_base) {
             memmove(filter_buf + 4, filter_buf, 12);
         } else {
@@ -902,6 +1004,7 @@
             }
         }
         vlan_status = E1000_RXD_STAT_VP;
+        //vlan_offset = 4; // SAC this used to be here
         size -= 4;
     }
 
@@ -918,6 +1021,12 @@
             desc_size = s->rxbuf_size;
         }
         base = rx_desc_base(s) + sizeof(desc) * s->mac_reg[RDH];
+        // RW read the receive descriptor from DMA
+        // taint transfer mem->io
+        if (rr_in_record()){
+            rr_record_net_transfer(RR_CALLSITE_E1000_RECEIVE_1,
+                                   NET_TRANSFER_RAM_TO_IOB, base, (uintptr_t)(&desc), sizeof(desc));
+        }
         pci_dma_read(d, base, &desc, sizeof(desc));
         desc.special = vlan_special;
         desc.status |= (vlan_status | E1000_RXD_STAT_DD);
@@ -929,9 +1038,33 @@
                 if (copy_size > s->rxbuf_size) {
                     copy_size = s->rxbuf_size;
                 }
+// SAC this function changed
+#ifdef E1000_DEBUG
+    printf("e1000 e1000_receive\n");
+    hex_dump(stdout, (void *)(buf + desc_offset + vlan_offset),
+             copy_size);
+#endif
+
                 do {
                     iov_copy = MIN(copy_size, iov->iov_len - iov_ofs);
+                    // RW write into the receive buffer in DMA
+                    // taint transfer io->mem
                     pci_dma_write(d, ba, iov->iov_base + iov_ofs, iov_copy);
+                    // SAC this is totally different from 1.0
+                    // should this be inside the do-while loop?
+                    // again, we have an iovec, instead of a raw buffer
+                    // maybe instead I should accumlate the copies in this loop into one buffer?
+                    if (rr_in_record()){
+                        // RW First, handle packet
+                        rr_record_handle_packet_call(RR_CALLSITE_E1000_RECEIVE_2,
+                                                     (void *)(iov->iov_base + iov_ofs), iov_copy,
+                                                     PANDA_NET_RX);
+                        // Then, record the DMA
+                        rr_record_net_transfer(RR_CALLSITE_E1000_RECEIVE_2,
+                                               NET_TRANSFER_IOB_TO_RAM,
+                                               (uintptr_t)(iov->iov_base + iov_ofs),
+                                               ba, iov_copy);
+                    }
                     copy_size -= iov_copy;
                     ba += iov_copy;
                     iov_ofs += iov_copy;
@@ -940,6 +1073,7 @@
                         iov_ofs = 0;
                     }
                 } while (copy_size);
+
             }
             desc_offset += desc_size;
             desc.length = cpu_to_le16(desc_size);
@@ -954,6 +1088,12 @@
             DBGOUT(RX, "Null RX descriptor!!\n");
         }
         pci_dma_write(d, base, &desc, sizeof(desc));
+        // RW write back the receive descriptor
+        // taint transfer io->mem
+        if (rr_in_record()){
+            rr_record_net_transfer(RR_CALLSITE_E1000_RECEIVE_3,
+                                   NET_TRANSFER_IOB_TO_RAM, (uintptr_t)(&desc), base, sizeof(desc));
+        }
 
         if (++s->mac_reg[RDH] * sizeof(desc) >= s->mac_reg[RDLEN])
             s->mac_reg[RDH] = 0;
diff -bur qemu-2.9.1/hw/ppc/ppc.c panda/hw/ppc/ppc.c
--- qemu-2.9.1/hw/ppc/ppc.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/hw/ppc/ppc.c	2019-12-05 17:27:34.355984402 -0500
@@ -39,7 +39,9 @@
 #include "kvm_ppc.h"
 #include "trace.h"
 
-//#define PPC_DEBUG_IRQ
+#ifdef CONFIG_SOFTMMU
+#include "panda/rr/rr_log.h"
+#endif
 //#define PPC_DEBUG_TB
 
 #ifdef PPC_DEBUG_IRQ
@@ -62,16 +64,7 @@
 {
     CPUState *cs = CPU(cpu);
     CPUPPCState *env = &cpu->env;
-    unsigned int old_pending;
-    bool locked = false;
-
-    /* We may already have the BQL if coming from the reset path */
-    if (!qemu_mutex_iothread_locked()) {
-        locked = true;
-        qemu_mutex_lock_iothread();
-    }
-
-    old_pending = env->pending_interrupts;
+    unsigned int old_pending = env->pending_interrupts;
 
     if (level) {
         env->pending_interrupts |= 1 << n_IRQ;
@@ -89,14 +82,9 @@
 #endif
     }
 
-
     LOG_IRQ("%s: %p n_IRQ %d level %d => pending %08" PRIx32
                 "req %08x\n", __func__, env, n_IRQ, level,
                 env->pending_interrupts, CPU(cpu)->interrupt_request);
-
-    if (locked) {
-        qemu_mutex_unlock_iothread();
-    }
 }
 
 /* PowerPC 6xx / 7xx internal IRQ controller */
@@ -476,11 +464,20 @@
 
 /*****************************************************************************/
 /* PowerPC time base and decrementer emulation */
-
 uint64_t cpu_ppc_get_tb(ppc_tb_t *tb_env, uint64_t vmclk, int64_t tb_offset)
 {
+    uint64_t tb_val;
     /* TB time in tb periods */
-    return muldiv64(vmclk, tb_env->tb_freq, NANOSECONDS_PER_SECOND) + tb_offset;
+#ifdef CONFIG_SOFTMMU
+     RR_DO_RECORD_OR_REPLAY(
+        tb_val = muldiv64(vmclk, tb_env->tb_freq, NANOSECONDS_PER_SECOND) + tb_offset;,
+        /*record=*/rr_input_8(&tb_val);,
+        /*replay=*/rr_input_8(&tb_val);,
+        /*location=*/RR_CALLSITE_RDTSC);
+#else
+    tb_val = muldiv64(vmclk, tb_env->tb_freq, NANOSECONDS_PER_SECOND) + tb_offset;
+#endif
+    return tb_val;
 }
 
 uint64_t cpu_ppc_load_tbl (CPUPPCState *env)
diff -bur qemu-2.9.1/hw/ppc/spapr.c panda/hw/ppc/spapr.c
--- qemu-2.9.1/hw/ppc/spapr.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/hw/ppc/spapr.c	2019-12-05 17:27:34.355984402 -0500
@@ -1058,9 +1058,6 @@
 {
     CPUPPCState *env = &cpu->env;
 
-    /* The TCG path should also be holding the BQL at this point */
-    g_assert(qemu_mutex_iothread_locked());
-
     if (msr_pr) {
         hcall_dprintf("Hypercall made with MSR[PR]=1\n");
         env->gpr[3] = H_PRIVILEGE;
diff -bur qemu-2.9.1/hw/usb/bus.c panda/hw/usb/bus.c
--- qemu-2.9.1/hw/usb/bus.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/hw/usb/bus.c	2020-01-22 10:59:21.894782430 -0500
@@ -407,8 +407,10 @@
 void usb_port_location(USBPort *downstream, USBPort *upstream, int portnr)
 {
     if (upstream) {
-        snprintf(downstream->path, sizeof(downstream->path), "%s.%d",
+        int l = snprintf(downstream->path, sizeof(downstream->path), "%s.%d",
                  upstream->path, portnr);
+        /* Max string is nn.nn.nn.nn.nn, which fits in 16 bytes */
+        assert(l < sizeof(downstream->path));
         downstream->hubcount = upstream->hubcount + 1;
     } else {
         snprintf(downstream->path, sizeof(downstream->path), "%d", portnr);
diff -bur qemu-2.9.1/hw/usb/host-libusb.c panda/hw/usb/host-libusb.c
--- qemu-2.9.1/hw/usb/host-libusb.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/hw/usb/host-libusb.c	2019-12-05 17:27:34.379984401 -0500
@@ -247,7 +247,14 @@
     if (rc != 0) {
         return -1;
     }
+
+#if defined(LIBUSB_API_VERSION) && (LIBUSB_API_VERSION >= 0x01000106)
+    libusb_set_option(ctx, LIBUSB_OPTION_LOG_LEVEL, loglevel);
+#else
     libusb_set_debug(ctx, loglevel);
+#endif
+
+
 #ifdef CONFIG_WIN32
     /* FIXME: add support for Windows. */
 #else
diff -bur qemu-2.9.1/include/exec/cpu-all.h panda/include/exec/cpu-all.h
--- qemu-2.9.1/include/exec/cpu-all.h	2017-09-07 12:25:12.000000000 -0400
+++ panda/include/exec/cpu-all.h	2019-12-05 17:27:34.391984401 -0500
@@ -347,4 +347,8 @@
 
 int cpu_exec(CPUState *cpu);
 
+// needed by panda
+MemTxResult cpu_physical_memory_rw_ex(hwaddr addr, uint8_t *buf,
+                                      int len, int is_write, bool safe);
+
 #endif /* CPU_ALL_H */
diff -bur qemu-2.9.1/include/exec/cpu-common.h panda/include/exec/cpu-common.h
--- qemu-2.9.1/include/exec/cpu-common.h	2017-09-07 12:25:12.000000000 -0400
+++ panda/include/exec/cpu-common.h	2019-12-05 17:27:34.391984401 -0500
@@ -73,17 +73,19 @@
 size_t qemu_ram_pagesize(RAMBlock *block);
 size_t qemu_ram_pagesize_largest(void);
 
+
+
 void cpu_physical_memory_rw(hwaddr addr, uint8_t *buf,
                             int len, int is_write);
 static inline void cpu_physical_memory_read(hwaddr addr,
                                             void *buf, int len)
 {
-    cpu_physical_memory_rw(addr, buf, len, 0);
+    cpu_physical_memory_rw(addr, (uint8_t *) buf, len, 0);
 }
 static inline void cpu_physical_memory_write(hwaddr addr,
                                              const void *buf, int len)
 {
-    cpu_physical_memory_rw(addr, (void *)buf, len, 1);
+    cpu_physical_memory_rw(addr, (uint8_t *)buf, len, 1);
 }
 void *cpu_physical_memory_map(hwaddr addr,
                               hwaddr *plen,
@@ -115,6 +117,7 @@
 int qemu_ram_foreach_block(RAMBlockIterFunc func, void *opaque);
 int ram_block_discard_range(RAMBlock *rb, uint64_t start, size_t length);
 
+
 #endif
 
 #endif /* CPU_COMMON_H */
diff -bur qemu-2.9.1/include/exec/exec-all.h panda/include/exec/exec-all.h
--- qemu-2.9.1/include/exec/exec-all.h	2017-09-07 12:25:12.000000000 -0400
+++ panda/include/exec/exec-all.h	2019-12-12 11:07:05.624456348 -0500
@@ -17,6 +17,19 @@
  * License along with this library; if not, see <http://www.gnu.org/licenses/>.
  */
 
+/*
+ * The file was modified for S2E Selective Symbolic Execution Framework
+ *
+ * Copyright (c) 2010, Dependable Systems Laboratory, EPFL
+ *
+ * Currently maintained by:
+ *    Volodymyr Kuznetsov <vova.kuznetsov@epfl.ch>
+ *    Vitaly Chipounov <vitaly.chipounov@epfl.ch>
+ *
+ * All contributors are listed in S2E-AUTHORS file.
+ *
+ */
+
 #ifndef EXEC_ALL_H
 #define EXEC_ALL_H
 
@@ -41,6 +54,9 @@
 #define DISAS_UPDATE  2 /* cpu state was modified dynamically */
 #define DISAS_TB_JUMP 3 /* only pc was modified statically */
 
+//struct TranslationBlock;
+//typedef struct TranslationBlock TranslationBlock;
+
 #include "qemu/log.h"
 
 void gen_intermediate_code(CPUArchState *env, struct TranslationBlock *tb);
@@ -310,6 +326,16 @@
 #define USE_DIRECT_JUMP
 #endif
 
+#ifdef CONFIG_LLVM
+#include "panda/tcg-llvm.h"
+#ifdef __cplusplus
+namespace llvm { class Function; }
+using llvm::Function;
+#else
+struct Function;
+#endif
+#endif
+
 struct TranslationBlock {
     target_ulong pc;   /* simulated PC corresponding to this block (EIP + CS base) */
     target_ulong cs_base; /* CS base for this block */
@@ -363,6 +389,20 @@
      */
     uintptr_t jmp_list_next[2];
     uintptr_t jmp_list_first;
+
+#ifdef CONFIG_LLVM
+    /* pointer to LLVM translated code */
+    TCGLLVMContext *tcg_llvm_context;
+#ifdef __cplusplus
+    Function *llvm_function;
+#else
+    struct Function *llvm_function;
+#endif
+    uint8_t *llvm_tc_ptr;
+    uint8_t *llvm_tc_end;
+    struct TranslationBlock* llvm_tb_next[2];
+#endif
+
 };
 
 void tb_free(TranslationBlock *tb);
@@ -412,7 +452,7 @@
                                      int n, uintptr_t addr)
 {
     uint16_t offset = tb->jmp_insn_offset[n];
-    tb_set_jmp_target1((uintptr_t)(tb->tc_ptr + offset), addr);
+    tb_set_jmp_target1((uintptr_t)(tb->tc_ptr) + offset, addr);
 }
 
 #else
@@ -430,7 +470,7 @@
 static inline void tb_add_jump(TranslationBlock *tb, int n,
                                TranslationBlock *tb_next)
 {
-    assert(n < ARRAY_SIZE(tb->jmp_list_next));
+    //assert(n < ARRAY_SIZE(tb->jmp_list_next));
     if (tb->jmp_list_next[n]) {
         /* Another thread has already done this while we were
          * outside of the lock; nothing to do in this case */
@@ -448,6 +488,9 @@
     /* add in TB jmp circular list */
     tb->jmp_list_next[n] = tb_next->jmp_list_first;
     tb_next->jmp_list_first = (uintptr_t)tb | n;
+#ifdef CONFIG_LLVM
+    tb->llvm_tb_next[n] = tb_next;
+#endif
 }
 
 /* GETPC is the true target of the return instruction that we'll execute.  */
@@ -510,10 +553,17 @@
                                        int prot,
                                        target_ulong *address);
 bool memory_region_is_unassigned(MemoryRegion *mr);
-
 #endif
 
 /* vl.c */
 extern int singlestep;
 
+/* cpu-exec.c, accessed with atomic_mb_read/atomic_mb_set */
+extern CPUState *tcg_current_cpu;
+extern bool exit_request;
+
+extern int generate_llvm;
+extern int execute_llvm;
+extern const int has_llvm_engine;
+
 #endif
diff -bur qemu-2.9.1/include/exec/gdbstub.h panda/include/exec/gdbstub.h
--- qemu-2.9.1/include/exec/gdbstub.h	2017-09-07 12:25:12.000000000 -0400
+++ panda/include/exec/gdbstub.h	2019-12-05 17:27:34.391984401 -0500
@@ -54,6 +54,7 @@
 #endif
 /* Get or set a register.  Returns the size of the register.  */
 typedef int (*gdb_reg_cb)(CPUArchState *env, uint8_t *buf, int reg);
+int gdb_write_register(CPUState *cpu, uint8_t *mem_buf, int reg);
 void gdb_register_coprocessor(CPUState *cpu,
                               gdb_reg_cb get_reg, gdb_reg_cb set_reg,
                               int num_regs, const char *xml, int g_pos);
diff -bur qemu-2.9.1/include/exec/gen-icount.h panda/include/exec/gen-icount.h
--- qemu-2.9.1/include/exec/gen-icount.h	2017-09-07 12:25:12.000000000 -0400
+++ panda/include/exec/gen-icount.h	2019-12-05 17:27:34.391984401 -0500
@@ -6,23 +6,29 @@
 /* Helpers for instruction counting code generation.  */
 
 static int icount_start_insn_idx;
+static TCGLabel *icount_label;
 static TCGLabel *exitreq_label;
 
 static inline void gen_tb_start(TranslationBlock *tb)
 {
-    TCGv_i32 count, imm;
+    TCGv_i32 count, flag, imm;
 
     exitreq_label = gen_new_label();
-    if (tb->cflags & CF_USE_ICOUNT) {
-        count = tcg_temp_local_new_i32();
-    } else {
-        count = tcg_temp_new_i32();
+    flag = tcg_temp_new_i32();
+    tcg_gen_ld_i32(flag, cpu_env,
+                   offsetof(CPUState, tcg_exit_req) - ENV_OFFSET);
+    tcg_gen_brcondi_i32(TCG_COND_NE, flag, 0, exitreq_label);
+    tcg_temp_free_i32(flag);
+
+    if (!(tb->cflags & CF_USE_ICOUNT)) {
+        return;
     }
 
+    icount_label = gen_new_label();
+    count = tcg_temp_local_new_i32();
     tcg_gen_ld_i32(count, cpu_env,
                    -ENV_OFFSET + offsetof(CPUState, icount_decr.u32));
 
-    if (tb->cflags & CF_USE_ICOUNT) {
         imm = tcg_temp_new_i32();
         /* We emit a movi with a dummy immediate argument. Keep the insn index
          * of the movi so that we later (when we know the actual insn count)
@@ -32,29 +38,26 @@
 
         tcg_gen_sub_i32(count, count, imm);
         tcg_temp_free_i32(imm);
-    }
-
-    tcg_gen_brcondi_i32(TCG_COND_LT, count, 0, exitreq_label);
 
-    if (tb->cflags & CF_USE_ICOUNT) {
+    tcg_gen_brcondi_i32(TCG_COND_LT, count, 0, icount_label);
         tcg_gen_st16_i32(count, cpu_env,
                          -ENV_OFFSET + offsetof(CPUState, icount_decr.u16.low));
-    }
-
     tcg_temp_free_i32(count);
 }
 
 static void gen_tb_end(TranslationBlock *tb, int num_insns)
 {
+    gen_set_label(exitreq_label);
+    tcg_gen_exit_tb((uintptr_t)tb + TB_EXIT_REQUESTED);
+
     if (tb->cflags & CF_USE_ICOUNT) {
         /* Update the num_insn immediate parameter now that we know
          * the actual insn count.  */
         tcg_set_insn_param(icount_start_insn_idx, 1, num_insns);
+        gen_set_label(icount_label);
+        tcg_gen_exit_tb((uintptr_t)tb + TB_EXIT_ICOUNT_EXPIRED);
     }
 
-    gen_set_label(exitreq_label);
-    tcg_gen_exit_tb((uintptr_t)tb + TB_EXIT_REQUESTED);
-
     /* Terminate the linked list.  */
     tcg_ctx.gen_op_buf[tcg_ctx.gen_op_buf[0].prev].next = 0;
 }
@@ -73,4 +76,25 @@
     tcg_temp_free_i32(tmp);
 }
 
+// Record and replay
+static inline void gen_op_update_rr_icount(void)
+{
+    TCGv_i64 count;
+
+    count = tcg_temp_new_i64();
+
+    tcg_gen_ld_i64(count, cpu_env, -ENV_OFFSET + offsetof(CPUState, rr_guest_instr_count));
+    tcg_gen_addi_i64(count, count, 1);
+    tcg_gen_st_i64(count, cpu_env, -ENV_OFFSET + offsetof(CPUState, rr_guest_instr_count));
+
+    tcg_temp_free_i64(count);
+}
+
+static inline void gen_op_update_panda_pc(uint64_t new_pc)
+{
+    TCGv_i64 tmp_pc = tcg_const_i64(new_pc);
+    tcg_gen_st_i64(tmp_pc, cpu_env, -ENV_OFFSET + offsetof(CPUState, panda_guest_pc));
+    tcg_temp_free_i64(tmp_pc);
+}
+
 #endif
diff -bur qemu-2.9.1/include/exec/memory.h panda/include/exec/memory.h
--- qemu-2.9.1/include/exec/memory.h	2017-09-07 12:25:12.000000000 -0400
+++ panda/include/exec/memory.h	2019-12-05 17:27:34.391984401 -0500
@@ -28,6 +28,7 @@
 #include "qom/object.h"
 #include "qemu/rcu.h"
 
+
 #define RAM_ADDR_INVALID (~(ram_addr_t)0)
 
 #define MAX_PHYS_ADDR_SPACE_BITS 62
@@ -1652,8 +1653,7 @@
     hwaddr l, addr1;
     void *ptr;
     MemoryRegion *mr;
-
-    if (__builtin_constant_p(len)) {
+    if (__builtin_constant_p(len) && false) {
         if (len) {
             rcu_read_lock();
             l = len;
@@ -1686,7 +1686,8 @@
                           void *buf, int len)
 {
     assert(addr < cache->len && len <= cache->len - addr);
-    address_space_read(cache->as, cache->xlat + addr, MEMTXATTRS_UNSPECIFIED, buf, len);
+    address_space_read(cache->as, cache->xlat + addr, MEMTXATTRS_UNSPECIFIED,
+                       (uint8_t *)buf, len);
 }
 
 /**
@@ -1702,7 +1703,8 @@
                            void *buf, int len)
 {
     assert(addr < cache->len && len <= cache->len - addr);
-    address_space_write(cache->as, cache->xlat + addr, MEMTXATTRS_UNSPECIFIED, buf, len);
+    address_space_write(cache->as, cache->xlat + addr, MEMTXATTRS_UNSPECIFIED,
+                        (uint8_t *)buf, len);
 }
 
 #endif
diff -bur qemu-2.9.1/include/glib-compat.h panda/include/glib-compat.h
--- qemu-2.9.1/include/glib-compat.h	2017-09-07 12:25:12.000000000 -0400
+++ panda/include/glib-compat.h	2019-12-12 11:07:05.624456348 -0500
@@ -16,6 +16,9 @@
 #ifndef QEMU_GLIB_COMPAT_H
 #define QEMU_GLIB_COMPAT_H
 
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+
 #include <glib.h>
 
 /* GLIB version compatibility flags */
Only in panda/include/hw/arm: rehosting.h
diff -bur qemu-2.9.1/include/hw/boards.h panda/include/hw/boards.h
--- qemu-2.9.1/include/hw/boards.h	2017-09-07 12:25:12.000000000 -0400
+++ panda/include/hw/boards.h	2020-01-22 10:59:21.894782430 -0500
@@ -173,6 +173,9 @@
     bool enforce_config_section;
     bool enable_graphics;
 
+    int board_id;
+    char *mem_map_str;
+
     ram_addr_t ram_size;
     ram_addr_t maxram_size;
     uint64_t   ram_slots;
diff -bur qemu-2.9.1/include/hw/i386/apic_internal.h panda/include/hw/i386/apic_internal.h
--- qemu-2.9.1/include/hw/i386/apic_internal.h	2017-09-07 12:25:12.000000000 -0400
+++ panda/include/hw/i386/apic_internal.h	2019-12-05 17:27:34.395984401 -0500
@@ -189,6 +189,8 @@
     DeviceState *vapic;
     hwaddr vapic_paddr; /* note: persistence via kvmvapic */
     bool legacy_instance_id;
+
+    int apic_irq_delivered; /* for saving static variable */
 };
 
 typedef struct VAPICState {
diff -bur qemu-2.9.1/include/monitor/monitor.h panda/include/monitor/monitor.h
--- qemu-2.9.1/include/monitor/monitor.h	2017-09-07 12:25:12.000000000 -0400
+++ panda/include/monitor/monitor.h	2020-01-22 10:59:21.894782430 -0500
@@ -18,6 +18,10 @@
 
 void monitor_init_qmp_commands(void);
 void monitor_init(Chardev *chr, int flags);
+
+void panda_init_monitor(void);
+char* panda_monitor_run(char* buf);
+
 void monitor_cleanup(void);
 
 int monitor_suspend(Monitor *mon);
diff -bur qemu-2.9.1/include/net/net.h panda/include/net/net.h
--- qemu-2.9.1/include/net/net.h	2017-09-07 12:25:12.000000000 -0400
+++ panda/include/net/net.h	2019-12-05 17:27:34.411984400 -0500
@@ -214,9 +214,9 @@
 int net_hub_id_for_client(NetClientState *nc, int *id);
 NetClientState *net_hub_port_find(int hub_id);
 
-#define DEFAULT_NETWORK_SCRIPT "/etc/qemu-ifup"
-#define DEFAULT_NETWORK_DOWN_SCRIPT "/etc/qemu-ifdown"
-#define DEFAULT_BRIDGE_HELPER CONFIG_QEMU_HELPERDIR "/qemu-bridge-helper"
+#define DEFAULT_NETWORK_SCRIPT "/etc/panda-ifup"
+#define DEFAULT_NETWORK_DOWN_SCRIPT "/etc/panda-ifdown"
+#define DEFAULT_BRIDGE_HELPER CONFIG_QEMU_HELPERDIR "/panda-bridge-helper"
 #define DEFAULT_BRIDGE_INTERFACE "br0"
 
 void qdev_set_nic_properties(DeviceState *dev, NICInfo *nd);
diff -bur qemu-2.9.1/include/qemu/atomic.h panda/include/qemu/atomic.h
--- qemu-2.9.1/include/qemu/atomic.h	2017-09-07 12:25:12.000000000 -0400
+++ panda/include/qemu/atomic.h	2019-12-05 17:27:34.411984400 -0500
@@ -179,6 +179,7 @@
     atomic_cmpxchg__nocheck(ptr, old, new);                             \
 })
 
+#ifndef __cplusplus
 /* Provide shorter names for GCC atomic builtins, return old value */
 #define atomic_fetch_inc(ptr)  __atomic_fetch_add(ptr, 1, __ATOMIC_SEQ_CST)
 #define atomic_fetch_dec(ptr)  __atomic_fetch_sub(ptr, 1, __ATOMIC_SEQ_CST)
@@ -195,6 +196,7 @@
 #define atomic_and_fetch(ptr, n) __atomic_and_fetch(ptr, n, __ATOMIC_SEQ_CST)
 #define atomic_or_fetch(ptr, n)  __atomic_or_fetch(ptr, n, __ATOMIC_SEQ_CST)
 #define atomic_xor_fetch(ptr, n) __atomic_xor_fetch(ptr, n, __ATOMIC_SEQ_CST)
+#endif
 
 /* And even shorter names that return void.  */
 #define atomic_inc(ptr)    ((void) __atomic_fetch_add(ptr, 1, __ATOMIC_SEQ_CST))
diff -bur qemu-2.9.1/include/qemu/bitmap.h panda/include/qemu/bitmap.h
--- qemu-2.9.1/include/qemu/bitmap.h	2017-09-07 12:25:12.000000000 -0400
+++ panda/include/qemu/bitmap.h	2019-12-05 17:27:34.411984400 -0500
@@ -86,7 +86,7 @@
 static inline unsigned long *bitmap_try_new(long nbits)
 {
     long len = BITS_TO_LONGS(nbits) * sizeof(unsigned long);
-    return g_try_malloc0(len);
+    return (unsigned long *) g_try_malloc0(len);
 }
 
 static inline unsigned long *bitmap_new(long nbits)
@@ -230,9 +230,9 @@
                                                 long old_nbits, long new_nbits)
 {
     long new_len = BITS_TO_LONGS(new_nbits) * sizeof(unsigned long);
-    unsigned long *new = g_realloc(old, new_len);
-    bitmap_clear(new, old_nbits, new_nbits - old_nbits);
-    return new;
+    unsigned long *newfoo = (unsigned long *) g_realloc(old, new_len);
+    bitmap_clear(newfoo, old_nbits, new_nbits - old_nbits);
+    return newfoo;
 }
 
 #endif /* BITMAP_H */
diff -bur qemu-2.9.1/include/qemu/int128.h panda/include/qemu/int128.h
--- qemu-2.9.1/include/qemu/int128.h	2017-09-07 12:25:12.000000000 -0400
+++ panda/include/qemu/int128.h	2019-12-05 17:27:34.411984400 -0500
@@ -195,7 +195,7 @@
 
 static inline Int128 int128_exts64(int64_t a)
 {
-    return (Int128) { .lo = a, .hi = (a < 0) ? -1 : 0 };
+    return (Int128) { .lo = (uint64_t) a, .hi = (a < 0) ? -1 : 0 };
 }
 
 static inline Int128 int128_and(Int128 a, Int128 b)
diff -bur qemu-2.9.1/include/qemu/log.h panda/include/qemu/log.h
--- qemu-2.9.1/include/qemu/log.h	2017-09-07 12:25:12.000000000 -0400
+++ panda/include/qemu/log.h	2019-12-05 17:27:34.411984400 -0500
@@ -43,6 +43,10 @@
 #define CPU_LOG_PAGE       (1 << 14)
 #define LOG_TRACE          (1 << 15)
 #define CPU_LOG_TB_OP_IND  (1 << 16)
+#define CPU_LOG_TAINT_OPS  (1 << 28)
+#define CPU_LOG_RR         (1 << 29)
+#define CPU_LOG_LLVM_IR    (1 << 30)
+#define CPU_LOG_LLVM_ASM   (1 << 31)
 
 /* Returns true if a bit is set in the current loglevel mask
  */
diff -bur qemu-2.9.1/include/qemu/osdep.h panda/include/qemu/osdep.h
--- qemu-2.9.1/include/qemu/osdep.h	2017-09-07 12:25:12.000000000 -0400
+++ panda/include/qemu/osdep.h	2019-12-05 17:27:34.411984400 -0500
@@ -63,6 +63,12 @@
 #include <stddef.h>
 #include <stdbool.h>
 #include <stdint.h>
+#if __GLIBC__ >= 2 && __GLIBC_MINOR__ >= 27
+/* Macros defined in sys/sysmacros.h have to be explicitly included from
+ * glibc 2.27 onwards. Before they were included through sys/types.h.
+ */
+#include <sys/sysmacros.h>
+#endif
 #include <sys/types.h>
 #include <stdlib.h>
 #include <stdio.h>
diff -bur qemu-2.9.1/include/qemu/timer.h panda/include/qemu/timer.h
--- qemu-2.9.1/include/qemu/timer.h	2017-09-07 12:25:12.000000000 -0400
+++ panda/include/qemu/timer.h	2019-12-05 17:27:34.415984400 -0500
@@ -251,6 +251,13 @@
  */
 bool qemu_clock_run_all_timers(void);
 
+/**
+ * qemu_rr_quit_timers:
+ *
+ * Deletes timers for all clocks.
+ */
+void qemu_rr_quit_timers(void);
+
 /*
  * QEMUTimerList
  */
@@ -518,7 +525,7 @@
                                       QEMUTimerCB *cb,
                                       void *opaque)
 {
-    QEMUTimer *ts = g_malloc0(sizeof(QEMUTimer));
+    QEMUTimer *ts = (QEMUTimer*)g_malloc0(sizeof(QEMUTimer));
     timer_init_tl(ts, timer_list, scale, cb, opaque);
     return ts;
 }
@@ -533,12 +540,6 @@
  * Create a new timer and associate it with the default
  * timer list for the clock type @type.
  *
- * The default timer list has one special feature: in icount mode,
- * %QEMU_CLOCK_VIRTUAL timers are run in the vCPU thread.  This is
- * not true of other timer lists, which are typically associated
- * with an AioContext---each of them runs its timer callbacks in its own
- * AioContext thread.
- *
  * Returns: a pointer to the timer
  */
 static inline QEMUTimer *timer_new(QEMUClockType type, int scale,
@@ -556,12 +557,6 @@
  * Create a new timer with nanosecond scale on the default timer list
  * associated with the clock.
  *
- * The default timer list has one special feature: in icount mode,
- * %QEMU_CLOCK_VIRTUAL timers are run in the vCPU thread.  This is
- * not true of other timer lists, which are typically associated
- * with an AioContext---each of them runs its timer callbacks in its own
- * AioContext thread.
- *
  * Returns: a pointer to the newly created timer
  */
 static inline QEMUTimer *timer_new_ns(QEMUClockType type, QEMUTimerCB *cb,
@@ -576,12 +571,6 @@
  * @cb: the callback to call when the timer expires
  * @opaque: the opaque pointer to pass to the callback
  *
- * The default timer list has one special feature: in icount mode,
- * %QEMU_CLOCK_VIRTUAL timers are run in the vCPU thread.  This is
- * not true of other timer lists, which are typically associated
- * with an AioContext---each of them runs its timer callbacks in its own
- * AioContext thread.
- *
  * Create a new timer with microsecond scale on the default timer list
  * associated with the clock.
  *
@@ -599,12 +588,6 @@
  * @cb: the callback to call when the timer expires
  * @opaque: the opaque pointer to pass to the callback
  *
- * The default timer list has one special feature: in icount mode,
- * %QEMU_CLOCK_VIRTUAL timers are run in the vCPU thread.  This is
- * not true of other timer lists, which are typically associated
- * with an AioContext---each of them runs its timer callbacks in its own
- * AioContext thread.
- *
  * Create a new timer with millisecond scale on the default timer list
  * associated with the clock.
  *
@@ -984,7 +967,7 @@
 #define MIPS_RDHWR(rd, value) {                         \
         __asm__ __volatile__ (".set   push\n\t"         \
                               ".set mips32r2\n\t"       \
-                              "rdhwr  %0, "rd"\n\t"     \
+                              "rdhwr  %0, " rd "\n\t"     \
                               ".set   pop"              \
                               : "=r" (value));          \
     }
diff -bur qemu-2.9.1/include/qom/cpu.h panda/include/qom/cpu.h
--- qemu-2.9.1/include/qom/cpu.h	2017-09-07 12:25:12.000000000 -0400
+++ panda/include/qom/cpu.h	2019-12-12 11:07:05.624456348 -0500
@@ -215,12 +215,13 @@
 
 typedef struct CPUBreakpoint {
     vaddr pc;
+    uint64_t rr_instr_count;
     int flags; /* BP_* */
     QTAILQ_ENTRY(CPUBreakpoint) entry;
 } CPUBreakpoint;
 
 struct CPUWatchpoint {
-    vaddr vaddr;
+    vaddr virtaddr;
     vaddr len;
     vaddr hitaddr;
     MemTxAttrs hitattrs;
@@ -275,11 +276,11 @@
  * @stopped: Indicates the CPU has been artificially stopped.
  * @unplug: Indicates a pending CPU unplug request.
  * @crash_occurred: Indicates the OS reported a crash (panic) for this CPU
+ * @tcg_exit_req: Set to force TCG to stop executing linked TBs for this
+ *           CPU and return to its top level loop.
  * @singlestep_enabled: Flags for single-stepping.
  * @icount_extra: Instructions until next timer event.
- * @icount_decr: Low 16 bits: number of cycles left, only used in icount mode.
- * High 16 bits: Set to -1 to force TCG to stop executing linked TBs for this
- * CPU and return to its top level loop (even in non-icount mode).
+ * @icount_decr: Number of cycles left, with interrupt flag in high bit.
  * This allows a single read-compare-cbranch-write sequence to test
  * for both decrementer underflow and exceptions.
  * @can_do_io: Nonzero if memory-mapped IO is safe. Deterministic execution
@@ -329,7 +330,6 @@
     bool unplug;
     bool crash_occurred;
     bool exit_request;
-    /* updates protected by BQL */
     uint32_t interrupt_request;
     int singlestep_enabled;
     int64_t icount_budget;
@@ -359,6 +359,7 @@
 
     QTAILQ_HEAD(watchpoints_head, CPUWatchpoint) watchpoints;
     CPUWatchpoint *watchpoint_hit;
+    bool watchpoints_disabled;
 
     void *opaque;
 
@@ -383,8 +384,20 @@
     /* TODO Move common fields from CPUArchState here. */
     int cpu_index; /* used by alpha TCG */
     uint32_t halted; /* used by alpha, cris, ppc TCG */
+    union {
+        uint32_t u32;
+        icount_decr_u16 u16;
+    } icount_decr;
     uint32_t can_do_io;
     int32_t exception_index; /* used by m68k TCG */
+    uint64_t rr_guest_instr_count;
+    vaddr panda_guest_pc;
+
+    // Used for rr reverse debugging
+    uint8_t reverse_flags;
+    uint64_t last_gdb_instr; // Instruction count from which we last sent a GDB command
+    uint64_t last_bp_hit_instr; // Last bp observed during this checkpoint run
+    uint64_t temp_rr_bp_instr; // Saved bp. Used by rstep/rcont, which disables bp to move forward, then restores on next tb in cpu-exec.c
 
     /* Used to keep track of an outstanding cpu throttle thread for migration
      * autoconverge
@@ -395,10 +408,7 @@
        offset from AREG0.  Leave this field at the end so as to make the
        (absolute value) offset as small as possible.  This reduces code
        size, especially for hosts without large memory offsets.  */
-    union {
-        uint32_t u32;
-        icount_decr_u16 u16;
-    } icount_decr;
+    uint32_t tcg_exit_req;
 
     bool hax_vcpu_dirty;
     struct hax_vcpu_state *hax_vcpu;
@@ -961,9 +971,18 @@
 #define BP_WATCHPOINT_HIT_WRITE 0x80
 #define BP_WATCHPOINT_HIT (BP_WATCHPOINT_HIT_READ | BP_WATCHPOINT_HIT_WRITE)
 
+// Reverse continue flags
+#define GDB_RDONE 0x1
+#define GDB_RSTEP 0x2
+#define GDB_RCONT 0x4
+#define GDB_RCONT_BREAK 0x8
+
 int cpu_breakpoint_insert(CPUState *cpu, vaddr pc, int flags,
                           CPUBreakpoint **breakpoint);
+int cpu_rr_breakpoint_insert(CPUState *cpu,  uint64_t instr_count, int flags,
+                          CPUBreakpoint **breakpoint);
 int cpu_breakpoint_remove(CPUState *cpu, vaddr pc, int flags);
+int cpu_breakpoint_remove_by_instr(CPUState *cpu, uint64_t instr, int flags);
 void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint);
 void cpu_breakpoint_remove_all(CPUState *cpu, int mask);
 
@@ -974,7 +993,22 @@
 
     if (unlikely(!QTAILQ_EMPTY(&cpu->breakpoints))) {
         QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {
-            if (bp->pc == pc && (bp->flags & mask)) {
+            if (bp->pc != 0 && bp->pc == pc && (bp->flags & mask)) {
+                return true;
+            }
+        }
+    }
+    return false;
+}
+
+/* Return true if address matches an installed breakpoint.  */
+static inline bool cpu_rr_breakpoint_test(CPUState *cpu,  uint64_t cur_instr_count, int mask)
+{
+    CPUBreakpoint *bp;
+
+    if (unlikely(!QTAILQ_EMPTY(&cpu->breakpoints))) {
+        QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {
+           if (bp->rr_instr_count != 0 && bp->rr_instr_count == cur_instr_count && (bp->flags & mask)) {
                 return true;
             }
         }
@@ -989,6 +1023,13 @@
 void cpu_watchpoint_remove_by_ref(CPUState *cpu, CPUWatchpoint *watchpoint);
 void cpu_watchpoint_remove_all(CPUState *cpu, int mask);
 
+void cpu_rcont_check_restore(CPUState* cpu, uint64_t rr_instr_count);
+
+//#ifdef CONFIG_SOFTMMU
+//#include "../exec/cpu-defs.h"
+//void invalidate_single_tb(CPUState *env, target_ulong pc);
+//h#endif
+
 /**
  * cpu_get_address_space:
  * @cpu: CPU to get address space from
diff -bur qemu-2.9.1/include/qom/object.h panda/include/qom/object.h
--- qemu-2.9.1/include/qom/object.h	2017-09-07 12:25:12.000000000 -0400
+++ panda/include/qom/object.h	2019-12-05 17:27:34.415984400 -0500
@@ -395,7 +395,7 @@
 struct Object
 {
     /*< private >*/
-    ObjectClass *class;
+    ObjectClass *klass;
     ObjectFree *free;
     GHashTable *properties;
     uint32_t ref;
diff -bur qemu-2.9.1/include/sysemu/cpus.h panda/include/sysemu/cpus.h
--- qemu-2.9.1/include/sysemu/cpus.h	2017-09-07 12:25:12.000000000 -0400
+++ panda/include/sysemu/cpus.h	2020-01-22 10:59:21.894782430 -0500
@@ -27,6 +27,7 @@
 void cpu_synchronize_all_states(void);
 void cpu_synchronize_all_post_reset(void);
 void cpu_synchronize_all_post_init(void);
+int do_vm_stop(RunState state);
 
 void qtest_clock_warp(int64_t dest);
 
diff -bur qemu-2.9.1/include/sysemu/sysemu.h panda/include/sysemu/sysemu.h
--- qemu-2.9.1/include/sysemu/sysemu.h	2017-09-07 12:25:12.000000000 -0400
+++ panda/include/sysemu/sysemu.h	2020-01-22 10:59:21.894782430 -0500
@@ -76,10 +76,12 @@
 void qemu_remove_machine_init_done_notifier(Notifier *notify);
 
 void hmp_savevm(Monitor *mon, const QDict *qdict);
+void monitor_or_stdout_printf(Monitor *mon, const char *fmt, ...);
 int save_vmstate(Monitor *mon, const char *name);
 int load_vmstate(const char *name);
 void hmp_delvm(Monitor *mon, const QDict *qdict);
 void hmp_info_snapshots(Monitor *mon, const QDict *qdict);
+int delvm_name(char *name);
 
 void qemu_announce_self(void);
 
@@ -130,6 +132,7 @@
                                            uint64_t *length_list);
 
 int qemu_loadvm_state(QEMUFile *f);
+int qemu_savevm_state(QEMUFile *f, Error **errp);
 
 extern int autostart;
 
Only in panda: main.c
diff -bur qemu-2.9.1/Makefile panda/Makefile
--- qemu-2.9.1/Makefile	2017-09-07 12:25:12.000000000 -0400
+++ panda/Makefile	2019-12-05 17:27:34.223984408 -0500
@@ -203,7 +203,7 @@
 
 LIBS+=-lz $(LIBS_TOOLS)
 
-HELPERS-$(CONFIG_LINUX) = qemu-bridge-helper$(EXESUF)
+HELPERS-$(CONFIG_LINUX) = panda-bridge-helper$(EXESUF)
 
 ifdef BUILD_DOCS
 DOCS=qemu-doc.html qemu-doc.txt qemu.1 qemu-img.1 qemu-nbd.8 qemu-ga.8
@@ -281,6 +281,8 @@
                 trace-obj-y)
 
 ifneq ($(wildcard config-host.mak),)
+include $(SRC_PATH)/panda/Makefile.panda
+
 include $(SRC_PATH)/tests/Makefile.include
 endif
 
@@ -378,7 +380,7 @@
 qemu-nbd$(EXESUF): qemu-nbd.o $(block-obj-y) $(crypto-obj-y) $(io-obj-y) $(qom-obj-y) $(COMMON_LDADDS)
 qemu-io$(EXESUF): qemu-io.o $(block-obj-y) $(crypto-obj-y) $(io-obj-y) $(qom-obj-y) $(COMMON_LDADDS)
 
-qemu-bridge-helper$(EXESUF): qemu-bridge-helper.o $(COMMON_LDADDS)
+panda-bridge-helper$(EXESUF): panda-bridge-helper.o $(COMMON_LDADDS)
 
 fsdev/virtfs-proxy-helper$(EXESUF): fsdev/virtfs-proxy-helper.o fsdev/9p-marshal.o fsdev/9p-iov-marshal.o $(COMMON_LDADDS)
 fsdev/virtfs-proxy-helper$(EXESUF): LIBS += -lcap
@@ -644,7 +646,7 @@
 
 cscope:
 	rm -f "$(SRC_PATH)"/cscope.*
-	find "$(SRC_PATH)/" -name "*.[chsS]" -print | sed 's,^\./,,' > "$(SRC_PATH)/cscope.files"
+	find "$(SRC_PATH)/" \( -name "*.[chsS]" -o -name '*.cpp' \) -print | sed 's,^\./,,' > "$(SRC_PATH)/cscope.files"
 	cscope -b -i"$(SRC_PATH)/cscope.files"
 
 # opengl shader programs
diff -bur qemu-2.9.1/Makefile.objs panda/Makefile.objs
--- qemu-2.9.1/Makefile.objs	2017-09-07 12:25:12.000000000 -0400
+++ panda/Makefile.objs	2020-01-22 10:59:21.890782321 -0500
@@ -64,8 +64,9 @@
 bt-host.o-cflags := $(BLUEZ_CFLAGS)
 
 common-obj-y += dma-helpers.o
-common-obj-y += vl.o
+common-obj-y += vl.o main.o
 vl.o-cflags := $(GPROF_CFLAGS) $(SDL_CFLAGS)
+main.o-cflags := $(GPROF_CFLAGS) $(SDL_CFLAGS)
 common-obj-y += tpm.o
 
 common-obj-$(CONFIG_SLIRP) += slirp/
diff -bur qemu-2.9.1/Makefile.target panda/Makefile.target
--- qemu-2.9.1/Makefile.target	2017-09-07 12:25:12.000000000 -0400
+++ panda/Makefile.target	2020-01-22 10:59:21.890782321 -0500
@@ -17,14 +17,15 @@
 
 ifdef CONFIG_USER_ONLY
 # user emulator name
-QEMU_PROG=qemu-$(TARGET_NAME)
+QEMU_PROG=panda-$(TARGET_NAME)
 QEMU_PROG_BUILD = $(QEMU_PROG)
 else
 # system emulator name
-QEMU_PROG=qemu-system-$(TARGET_NAME)$(EXESUF)
+QEMU_PROG=panda-system-$(TARGET_NAME)$(EXESUF)
+PANDA_PROG=libpanda-$(TARGET_NAME).so
 ifneq (,$(findstring -mwindows,$(libs_softmmu)))
 # Terminate program name with a 'w' because the linker builds a windows executable.
-QEMU_PROGW=qemu-system-$(TARGET_NAME)w$(EXESUF)
+QEMU_PROGW=panda-system-$(TARGET_NAME)w$(EXESUF)
 $(QEMU_PROG): $(QEMU_PROGW)
 	$(call quiet-command,$(OBJCOPY) --subsystem console $(QEMU_PROGW) $(QEMU_PROG),"GEN","$(TARGET_DIR)$(QEMU_PROG)")
 QEMU_PROG_BUILD = $(QEMU_PROGW)
@@ -33,7 +34,7 @@
 endif
 endif
 
-PROGS=$(QEMU_PROG) $(QEMU_PROGW)
+PROGS=$(QEMU_PROG) $(QEMU_PROGW) $(PANDA_PROG)
 STPFILES=
 
 config-target.h: config-target.h-timestamp
@@ -81,6 +82,11 @@
 endif
 .PHONY: stap
 
+#########################################################
+# Panda code
+#########################################################
+include $(SRC_PATH)/panda/Makefile.panda.target
+
 all: $(PROGS) stap
 
 # Dummy command so that make thinks it has done something
@@ -88,7 +94,7 @@
 
 #########################################################
 # cpu emulator library
-obj-y = exec.o translate-all.o cpu-exec.o
+obj-y += exec.o translate-all.o cpu-exec.o
 obj-y += translate-common.o
 obj-y += cpu-exec-common.o
 obj-y += tcg/tcg.o tcg/tcg-op.o tcg/optimize.o
@@ -171,6 +177,7 @@
 
 dummy := $(call unnest-vars,,obj-y)
 all-obj-y := $(obj-y)
+panda-all-obj-y := $(obj-y)
 
 target-obj-y :=
 block-obj-y :=
@@ -199,15 +206,34 @@
 all-obj-$(CONFIG_SOFTMMU) += $(crypto-obj-y)
 all-obj-$(CONFIG_SOFTMMU) += $(io-obj-y)
 
+ifdef CONFIG_SOFTMMU
+panda-all-obj-y += $(filter-out %main.o, $(common-obj-y))
+panda-all-obj-y += panda/src/panda_api.o
+panda-all-obj-y += $(target-obj-y)
+panda-all-obj-y += $(qom-obj-y)
+panda-all-obj-$(CONFIG_SOFTMMU) += $(block-obj-y) $(chardev-obj-y)
+panda-all-obj-$(CONFIG_SOFTMMU) += $(crypto-obj-y)
+panda-all-obj-$(CONFIG_SOFTMMU) += $(io-obj-y)
+endif #CONFIG_SOFTMMU
+
 $(QEMU_PROG_BUILD): config-devices.mak
+$(PANDA_PROG): config-devices.mak
 
 COMMON_LDADDS = $(trace-obj-y) ../libqemuutil.a ../libqemustub.a
 
-# build either PROG or PROGW
+# build either PROG or PROGW and libpanda.so
 $(QEMU_PROG_BUILD): $(all-obj-y) $(COMMON_LDADDS)
 	$(call LINK, $(filter-out %.mak, $^))
 ifdef CONFIG_DARWIN
-	$(call quiet-command,Rez -append $(SRC_PATH)/pc-bios/qemu.rsrc -o $@,"REZ","$(TARGET_DIR)$@")
+	$(call quiet-command,Rez -append $(SRC_PATH)/pc-bios/panda.rsrc -o $@,"REZ","$(TARGET_DIR)$@")
+	$(call quiet-command,SetFile -a C $@,"SETFILE","$(TARGET_DIR)$@")
+endif
+
+$(PANDA_PROG): LDFLAGS+=-shared
+$(PANDA_PROG): $(panda-all-obj-y) $(COMMON_LDADDS)
+	$(call LINK, $(filter-out %.mak, $^))
+ifdef CONFIG_DARWIN
+	$(call quiet-command,Rez -append $(SRC_PATH)/pc-bios/panda.rsrc -o $@,"REZ","$(TARGET_DIR)$@")
 	$(call quiet-command,SetFile -a C $@,"SETFILE","$(TARGET_DIR)$@")
 endif
 
@@ -237,6 +263,20 @@
 	$(INSTALL_DATA) $(QEMU_PROG).stp-installed "$(DESTDIR)$(qemu_datadir)/../systemtap/tapset/$(QEMU_PROG).stp"
 	$(INSTALL_DATA) $(QEMU_PROG)-simpletrace.stp "$(DESTDIR)$(qemu_datadir)/../systemtap/tapset/$(QEMU_PROG)-simpletrace.stp"
 endif
+ifdef CONFIG_LLVM
+	$(INSTALL_DATA) $(llvmmorph-y) "$(DESTDIR)$(qemu_datadir)/"
+endif
+	$(INSTALL_DIR) "$(DESTDIR)$(libdir)/python2.7/site-packages"
+	$(INSTALL_LIB) plog_pb2.py "$(DESTDIR)$(libdir)/python2.7/site-packages"
+	$(INSTALL_DIR) "$(DESTDIR)$(libdir)/panda/$(TARGET_NAME)"
+	for p in $(PANDA_PLUGINS) $(EXTRA_PANDA_PLUGINS); do \
+		$(INSTALL_LIB) panda/plugins/panda_$$p.so "$(DESTDIR)$(libdir)/panda/$(TARGET_NAME)"; \
+		for f in $$(find panda/plugins/$$p -type f -not -name '*.d' -not -name '*.o' -not -name '*.h'); do \
+			$(INSTALL_DIR) "$(DESTDIR)$(libdir)/panda/$(TARGET_NAME)/$$p"; \
+			$(INSTALL_DATA) $$f "$(DESTDIR)$(libdir)/panda/$(TARGET_NAME)/$$p"; \
+		done; \
+		echo $$p; \
+	done
 
-GENERATED_FILES += config-target.h
+GENERATED_FILES += config-target.h plog_pb2.py
 Makefile: $(GENERATED_FILES)
diff -bur qemu-2.9.1/memory.c panda/memory.c
--- qemu-2.9.1/memory.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/memory.c	2020-01-22 10:59:21.894782430 -0500
@@ -31,7 +31,8 @@
 #include "sysemu/kvm.h"
 #include "sysemu/sysemu.h"
 
-//#define DEBUG_UNASSIGNED
+#include "panda/rr/rr_log_all.h"
+#include "panda/callbacks/cb-support.h"
 
 static unsigned memory_region_transaction_depth;
 static bool memory_region_update_pending;
@@ -911,8 +912,6 @@
     AddressSpace *as;
 
     assert(memory_region_transaction_depth);
-    assert(qemu_mutex_iothread_locked());
-
     --memory_region_transaction_depth;
     if (!memory_region_transaction_depth) {
         if (memory_region_update_pending) {
@@ -1091,26 +1090,29 @@
 }
 
 static uint64_t unassigned_mem_read(void *opaque, hwaddr addr,
-                                    unsigned size)
+                                    size_t size)
 {
 #ifdef DEBUG_UNASSIGNED
     printf("Unassigned mem read " TARGET_FMT_plx "\n", addr);
 #endif
+    uint8_t val = 0;
     if (current_cpu != NULL) {
         cpu_unassigned_access(current_cpu, addr, false, false, 0, size);
     }
-    return 0;
+    panda_callbacks_unassigned_io(first_cpu, addr, size, &val, false);
+    return val;
 }
 
 static void unassigned_mem_write(void *opaque, hwaddr addr,
-                                 uint64_t val, unsigned size)
+                                 uint8_t val, size_t size)
 {
 #ifdef DEBUG_UNASSIGNED
-    printf("Unassigned mem write " TARGET_FMT_plx " = 0x%"PRIx64"\n", addr, val);
+    printf("Unassigned mem write to " TARGET_FMT_plx "\n", addr);
 #endif
     if (current_cpu != NULL) {
         cpu_unassigned_access(current_cpu, addr, true, false, 0, size);
     }
+    panda_callbacks_unassigned_io(first_cpu, addr, size, &val, true);
 }
 
 static bool unassigned_mem_accepts(void *opaque, hwaddr addr,
@@ -1234,23 +1236,28 @@
 {
     *pval = 0;
 
+    MemTxResult result;
     if (mr->ops->read) {
-        return access_with_adjusted_size(addr, pval, size,
+        result = access_with_adjusted_size(addr, pval, size,
                                          mr->ops->impl.min_access_size,
                                          mr->ops->impl.max_access_size,
                                          memory_region_read_accessor,
                                          mr, attrs);
     } else if (mr->ops->read_with_attrs) {
-        return access_with_adjusted_size(addr, pval, size,
+        result = access_with_adjusted_size(addr, pval, size,
                                          mr->ops->impl.min_access_size,
                                          mr->ops->impl.max_access_size,
                                          memory_region_read_with_attrs_accessor,
                                          mr, attrs);
     } else {
-        return access_with_adjusted_size(addr, pval, size, 1, 4,
+        result = access_with_adjusted_size(addr, pval, size, 1, 4,
                                          memory_region_oldmmio_read_accessor,
                                          mr, attrs);
     }
+
+
+    return result;
+
 }
 
 MemTxResult memory_region_dispatch_read(MemoryRegion *mr,
diff -bur qemu-2.9.1/memory_ldst.inc.c panda/memory_ldst.inc.c
--- qemu-2.9.1/memory_ldst.inc.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/memory_ldst.inc.c	2019-12-05 17:27:34.439984399 -0500
@@ -38,7 +38,11 @@
         release_lock |= prepare_mmio_access(mr);
 
         /* I/O case */
-        r = memory_region_dispatch_read(mr, addr1, &val, 4, attrs);
+        RR_DO_RECORD_OR_REPLAY(
+            /*action*/   r = memory_region_dispatch_read(mr, addr1, &val, 4, attrs),
+            /*record*/   rr_input_4(&r); rr_input_8(&val),
+            /*replay*/   rr_input_4(&r); rr_input_8(&val),
+            /*location*/ RR_CALLSITE_READ_4);
 #if defined(TARGET_WORDS_BIGENDIAN)
         if (endian == DEVICE_LITTLE_ENDIAN) {
             val = bswap32(val);
@@ -132,7 +136,11 @@
         release_lock |= prepare_mmio_access(mr);
 
         /* I/O case */
-        r = memory_region_dispatch_read(mr, addr1, &val, 8, attrs);
+        RR_DO_RECORD_OR_REPLAY(
+            /*action*/   r = memory_region_dispatch_read(mr, addr1, &val, 8, attrs),
+            /*record*/   rr_input_4(&r); rr_input_8(&val),
+            /*replay*/   rr_input_4(&r); rr_input_8(&val),
+            /*location*/ RR_CALLSITE_READ_8);
 #if defined(TARGET_WORDS_BIGENDIAN)
         if (endian == DEVICE_LITTLE_ENDIAN) {
             val = bswap64(val);
@@ -224,7 +232,11 @@
         release_lock |= prepare_mmio_access(mr);
 
         /* I/O case */
-        r = memory_region_dispatch_read(mr, addr1, &val, 1, attrs);
+        RR_DO_RECORD_OR_REPLAY(
+            /*action*/   r = memory_region_dispatch_read(mr, addr1, &val, 1, attrs),
+            /*record*/   rr_input_4(&r); rr_input_8(&val),
+            /*replay*/   rr_input_4(&r); rr_input_8(&val),
+            /*location*/ RR_CALLSITE_READ_1);
     } else {
         /* RAM case */
         ptr = MAP_RAM(mr, addr1);
@@ -266,7 +278,11 @@
         release_lock |= prepare_mmio_access(mr);
 
         /* I/O case */
-        r = memory_region_dispatch_read(mr, addr1, &val, 2, attrs);
+        RR_DO_RECORD_OR_REPLAY(
+            /*action*/   r = memory_region_dispatch_read(mr, addr1, &val, 2, attrs),
+            /*record*/   rr_input_4(&r); rr_input_8(&val),
+            /*replay*/   rr_input_4(&r); rr_input_8(&val),
+            /*location*/ RR_CALLSITE_READ_2);
 #if defined(TARGET_WORDS_BIGENDIAN)
         if (endian == DEVICE_LITTLE_ENDIAN) {
             val = bswap16(val);
@@ -360,7 +376,12 @@
     if (l < 4 || !IS_DIRECT(mr, true)) {
         release_lock |= prepare_mmio_access(mr);
 
-        r = memory_region_dispatch_write(mr, addr1, val, 4, attrs);
+        RR_DO_RECORD_OR_REPLAY(
+        /*action=*/
+        r = memory_region_dispatch_write(mr, addr1, val, 4, attrs),
+        /*record=*/RR_NO_ACTION,
+        /*replay=*/r = MEMTX_OK,
+        /*location=*/RR_CALLSITE_WRITE_4);
     } else {
         ptr = MAP_RAM(mr, addr1);
         stl_p(ptr, val);
@@ -412,7 +433,18 @@
             val = bswap32(val);
         }
 #endif
-        r = memory_region_dispatch_write(mr, addr1, val, 4, attrs);
+        /* Because is_direct is false, these are accesses to an area other
+         * than RAM. That means we want to throw it away on replay. All paths
+         * to this function from guest code don't request a result, so we don't
+         * have to record the result of the memory_region_dispatch_write. The
+         * paths from device code shouldn't happen during replay.
+         */
+        RR_DO_RECORD_OR_REPLAY(
+        /*action=*/
+        r = memory_region_dispatch_write(mr, addr1, val, 4, attrs),
+        /*record=*/RR_NO_ACTION,
+        /*replay=*/r = MEMTX_OK,
+        /*location=*/RR_CALLSITE_WRITE_4);
     } else {
         /* RAM case */
         ptr = MAP_RAM(mr, addr1);
@@ -427,6 +459,9 @@
             stl_p(ptr, val);
             break;
         }
+        if (rr_in_record() && (rr_record_in_progress || rr_record_in_main_loop_wait)) {
+            rr_device_mem_rw_call_record(addr1, ptr, l, /*is_write*/1);
+        }
         INVALIDATE(mr, addr1, 4);
         r = MEMTX_OK;
     }
@@ -492,7 +527,12 @@
     mr = TRANSLATE(addr, &addr1, &l, true);
     if (!IS_DIRECT(mr, true)) {
         release_lock |= prepare_mmio_access(mr);
-        r = memory_region_dispatch_write(mr, addr1, val, 1, attrs);
+        RR_DO_RECORD_OR_REPLAY(
+        /*action=*/
+        r = memory_region_dispatch_write(mr, addr1, val, 1, attrs),
+        /*record=*/RR_NO_ACTION,
+        /*replay=*/r = MEMTX_OK,
+        /*location=*/RR_CALLSITE_WRITE_1);
     } else {
         /* RAM case */
         ptr = MAP_RAM(mr, addr1);
@@ -541,7 +581,13 @@
             val = bswap16(val);
         }
 #endif
-        r = memory_region_dispatch_write(mr, addr1, val, 2, attrs);
+        /* See comment in address_space_stl_internal. */
+        RR_DO_RECORD_OR_REPLAY(
+        /*action=*/
+        r = memory_region_dispatch_write(mr, addr1, val, 2, attrs),
+        /*record=*/RR_NO_ACTION,
+        /*replay=*/r = MEMTX_OK,
+        /*location=*/RR_CALLSITE_WRITE_2);
     } else {
         /* RAM case */
         ptr = MAP_RAM(mr, addr1);
@@ -632,7 +678,13 @@
             val = bswap64(val);
         }
 #endif
-        r = memory_region_dispatch_write(mr, addr1, val, 8, attrs);
+        /* See comment in address_space_stl_internal. */
+        RR_DO_RECORD_OR_REPLAY(
+        /*action=*/
+        r = memory_region_dispatch_write(mr, addr1, val, 8, attrs),
+        /*record=*/RR_NO_ACTION,
+        /*replay=*/r = MEMTX_OK,
+        /*location=*/RR_CALLSITE_WRITE_8);
     } else {
         /* RAM case */
         ptr = MAP_RAM(mr, addr1);
diff -bur qemu-2.9.1/migration/colo-comm.c panda/migration/colo-comm.c
--- qemu-2.9.1/migration/colo-comm.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/migration/colo-comm.c	2019-12-12 11:07:05.624456348 -0500
@@ -12,7 +12,7 @@
  */
 
 #include "qemu/osdep.h"
-#include <migration/colo.h>
+#include "migration/colo.h"
 #include "trace.h"
 
 typedef struct {
diff -bur qemu-2.9.1/migration/savevm.c panda/migration/savevm.c
--- qemu-2.9.1/migration/savevm.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/migration/savevm.c	2020-01-22 10:59:21.894782430 -0500
@@ -1233,7 +1233,7 @@
     }
 }
 
-static int qemu_savevm_state(QEMUFile *f, Error **errp)
+int qemu_savevm_state(QEMUFile *f, Error **errp)
 {
     int ret;
     MigrationParams params = {
@@ -2071,6 +2071,17 @@
     return ret;
 }
 
+void monitor_or_stdout_printf(Monitor *mon, const char *fmt, ...) {
+    // Print results via monitor if available. Otherwise print via stdout
+    va_list ap;
+    va_start(ap, fmt);
+    if (mon)
+        monitor_printf(mon, fmt, ap);
+    else
+        printf(fmt, ap);
+    va_end(ap);
+}
+
 int save_vmstate(Monitor *mon, const char *name)
 {
     BlockDriverState *bs, *bs1;
@@ -2085,7 +2096,7 @@
     AioContext *aio_context;
 
     if (!bdrv_all_can_snapshot(&bs)) {
-        monitor_printf(mon, "Device '%s' is writable but does not "
+        monitor_or_stdout_printf(mon, "Device '%s' is writable but does not "
                        "support snapshots.\n", bdrv_get_device_name(bs));
         return ret;
     }
@@ -2103,7 +2114,7 @@
 
     bs = bdrv_all_find_vmstate_bs();
     if (bs == NULL) {
-        monitor_printf(mon, "No block device can accept snapshots\n");
+        monitor_or_stdout_printf(mon, "No block device can accept snapshots\n");
         return ret;
     }
     aio_context = bdrv_get_aio_context(bs);
@@ -2112,7 +2123,7 @@
 
     ret = global_state_store();
     if (ret) {
-        monitor_printf(mon, "Error saving global state\n");
+        monitor_or_stdout_printf(mon, "Error saving global state\n");
         return ret;
     }
     vm_stop(RUN_STATE_SAVE_VM);
@@ -2144,7 +2155,7 @@
     /* save the VM state */
     f = qemu_fopen_bdrv(bs, 1);
     if (!f) {
-        monitor_printf(mon, "Could not open VM state file\n");
+        monitor_or_stdout_printf(mon, "Could not open VM state file\n");
         goto the_end;
     }
     ret = qemu_savevm_state(f, &local_err);
@@ -2157,7 +2168,7 @@
 
     ret = bdrv_all_create_snapshot(sn, bs, vm_state_size, &bs);
     if (ret < 0) {
-        monitor_printf(mon, "Error while creating snapshot on '%s'\n",
+        monitor_or_stdout_printf(mon, "Error while creating snapshot on '%s'\n",
                        bdrv_get_device_name(bs));
         goto the_end;
     }
@@ -2323,6 +2334,14 @@
     }
 }
 
+int delvm_name(char *name) {
+    BlockDriverState *bs;
+    Error *err;
+
+    // returns 0 if successful
+    return bdrv_all_delete_snapshot(name, &bs, &err);
+}
+
 void hmp_info_snapshots(Monitor *mon, const QDict *qdict)
 {
     BlockDriverState *bs, *bs1;
diff -bur qemu-2.9.1/monitor.c panda/monitor.c
--- qemu-2.9.1/monitor.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/monitor.c	2020-01-22 10:59:21.894782430 -0500
@@ -80,6 +80,7 @@
 #include "sysemu/cpus.h"
 #include "qemu/cutils.h"
 #include "qapi/qmp/dispatch.h"
+#include "chardev/char-panda.h"
 
 #if defined(TARGET_S390X)
 #include "hw/s390x/storage-keys.h"
@@ -224,7 +225,11 @@
 
 QmpCommandList qmp_commands, qmp_cap_negotiation_commands;
 
-Monitor *cur_mon;
+Monitor *cur_mon = NULL;
+
+// global vars for panda monitor and chardev
+PandaChardev *panda_chr = NULL;
+Monitor *panda_mon = NULL;
 
 static QEMUClockType event_clock_type = QEMU_CLOCK_REALTIME;
 
@@ -3974,6 +3979,65 @@
     qemu_mutex_init(&monitor_lock);
 }
 
+// Create a panda chardev and monitor to interact with (panda_chr and panda_mon)
+void panda_init_monitor(void) {
+  if (panda_mon != NULL) {
+    return;
+  }
+  Chardev* chr;
+  chr = qemu_chardev_new(NULL, TYPE_CHARDEV_PANDA,
+        NULL, &error_abort);
+
+  // Modified version of logic from monitor_init
+  int flags=0;
+  panda_mon = g_malloc(sizeof(*panda_mon));
+  monitor_data_init(panda_mon);
+
+  qemu_chr_fe_init(&panda_mon->chr, chr, &error_abort);
+  panda_mon->flags = flags;
+  qemu_chr_fe_set_handlers(&panda_mon->chr, monitor_can_read, monitor_read,
+      monitor_event, panda_mon, NULL, true);
+
+  qemu_mutex_lock(&monitor_lock);
+  QLIST_INSERT_HEAD(&mon_list, panda_mon, entry);
+  qemu_mutex_unlock(&monitor_lock);
+
+  panda_chr = PANDA_CHARDEV(chr);
+
+  // Initialize cur_mon
+  cur_mon = panda_mon;
+}
+
+char* panda_monitor_run(char * cmdline)
+{
+    if (panda_mon == NULL) {
+      panda_init_monitor();
+    }
+
+    assert(panda_mon != NULL);
+
+    Monitor *mon = panda_mon;
+
+    panda_chr->buf = NULL;
+
+    monitor_suspend(mon);
+    handle_hmp_command(mon, cmdline);
+    monitor_resume(mon);
+
+    // Wait for result. Must not be called from the thread that's processing
+    // the hmp command!
+    int i=0;
+    while (panda_chr->buf == NULL) {
+      if (i++ > 10000) {
+        error_vprintf("PANDA monitor got no result after 10,000 iterations\n", NULL);
+        break;
+      }
+    }
+    return panda_chr->buf;
+}
+
+
+
 void monitor_init(Chardev *chr, int flags)
 {
     static int is_first_init = 1;
diff -bur qemu-2.9.1/net/slirp.c panda/net/slirp.c
--- qemu-2.9.1/net/slirp.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/net/slirp.c	2020-01-22 10:59:21.894782430 -0500
@@ -80,7 +80,7 @@
     Slirp *slirp;
     Notifier exit_notifier;
 #ifndef _WIN32
-    char smb_dir[128];
+    gchar *smb_dir;
 #endif
 } SlirpState;
 
@@ -558,11 +558,10 @@
 /* automatic user mode samba server configuration */
 static void slirp_smb_cleanup(SlirpState *s)
 {
-    char cmd[128];
     int ret;
 
-    if (s->smb_dir[0] != '\0') {
-        snprintf(cmd, sizeof(cmd), "rm -rf %s", s->smb_dir);
+    if (s->smb_dir) {
+        gchar *cmd = g_strdup_printf("rm -rf %s", s->smb_dir);
         ret = system(cmd);
         if (ret == -1 || !WIFEXITED(ret)) {
             error_report("'%s' failed.", cmd);
@@ -570,15 +569,17 @@
             error_report("'%s' failed. Error code: %d",
                          cmd, WEXITSTATUS(ret));
         }
-        s->smb_dir[0] = '\0';
+        g_free(cmd);
+        g_free(s->smb_dir);
+        s->smb_dir = NULL;
     }
 }
 
 static int slirp_smb(SlirpState* s, const char *exported_dir,
                      struct in_addr vserver_addr)
 {
-    char smb_conf[128];
-    char smb_cmdline[128];
+    char *smb_conf;
+    char *smb_cmdline;
     struct passwd *passwd;
     FILE *f;
 
@@ -600,19 +601,19 @@
         return -1;
     }
 
-    snprintf(s->smb_dir, sizeof(s->smb_dir), "/tmp/qemu-smb.XXXXXX");
-    if (!mkdtemp(s->smb_dir)) {
-        error_report("could not create samba server dir '%s'", s->smb_dir);
-        s->smb_dir[0] = 0;
+    s->smb_dir = g_dir_make_tmp("qemu-smb.XXXXXX", NULL);
+    if (!s->smb_dir) {
+        error_report("could not create samba server dir");
         return -1;
     }
-    snprintf(smb_conf, sizeof(smb_conf), "%s/%s", s->smb_dir, "smb.conf");
+    smb_conf = g_strdup_printf("%s/%s", s->smb_dir, "smb.conf");
 
     f = fopen(smb_conf, "w");
     if (!f) {
         slirp_smb_cleanup(s);
         error_report("could not create samba server configuration file '%s'",
                      smb_conf);
+        g_free(smb_conf);
         return -1;
     }
     fprintf(f,
@@ -651,15 +652,18 @@
             );
     fclose(f);
 
-    snprintf(smb_cmdline, sizeof(smb_cmdline), "%s -l %s -s %s",
+    smb_cmdline = g_strdup_printf("%s -l %s -s %s",
              CONFIG_SMBD_COMMAND, s->smb_dir, smb_conf);
+    g_free(smb_conf);
 
     if (slirp_add_exec(s->slirp, 0, smb_cmdline, &vserver_addr, 139) < 0 ||
         slirp_add_exec(s->slirp, 0, smb_cmdline, &vserver_addr, 445) < 0) {
         slirp_smb_cleanup(s);
+        g_free(smb_cmdline);
         error_report("conflicting/invalid smbserver address");
         return -1;
     }
+    g_free(smb_cmdline);
     return 0;
 }
 
diff -bur qemu-2.9.1/os-posix.c panda/os-posix.c
--- qemu-2.9.1/os-posix.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/os-posix.c	2019-12-12 11:07:05.624456348 -0500
@@ -77,7 +77,7 @@
 /* Find a likely location for support files using the location of the binary.
    For installed binaries this will be "$bindir/../share/qemu".  When
    running from the build tree this will be "$bindir/../pc-bios".  */
-#define SHARE_SUFFIX "/share/qemu"
+#define SHARE_SUFFIX "/share/panda"
 #define BUILD_SUFFIX "/pc-bios"
 char *os_find_datadir(void)
 {
Only in panda: panda
Only in panda: panda-bridge-helper.c
Only in panda/pc-bios: panda.rsrc
Only in panda/pixman: .git
diff -bur qemu-2.9.1/qapi-schema.json panda/qapi-schema.json
--- qemu-2.9.1/qapi-schema.json	2017-09-07 12:25:12.000000000 -0400
+++ panda/qapi-schema.json	2019-12-05 17:27:34.571984394 -0500
@@ -6296,3 +6296,92 @@
 # Since 2.9
 ##
 { 'command': 'query-vm-generation-id', 'returns': 'GuidInfo' }
+
+##
+# @begin_record:
+#
+# Requests that we begin recording for later replay
+# 
+# TRL 20120501
+##
+{ 'command': 'begin_record', 'data': { 'file_name': 'str' } }
+
+##
+# @begin_record_from:
+#
+# Requests that we revert to a snapshot and begin recording for later replay
+#
+##
+{ 'command': 'begin_record_from', 'data': { 'snapshot': 'str', 'file_name': 'str' } }
+
+##
+# @end_record:
+#
+# Requests that we begin recording for later replay
+# 
+# TRL 20120501
+##
+{ 'command': 'end_record' }
+
+##
+# @begin_replay:
+#
+# Requests that we begin replaying
+# 
+# TRL 20120501
+##
+{ 'command': 'begin_replay', 'data': { 'file_name': 'str' } }
+
+##
+# @end_replay:
+#
+# Requests that we end replaying 
+# 
+# TRL 20120501
+##
+{ 'command': 'end_replay' } 
+
+##
+# @load_plugin:
+#
+# Loads a PANDA plugin
+# 
+# BDG 20120821
+##
+{ 'command': 'load_plugin', 'data': { '*file_name': 'str', 'plugin_name': 'str',
+                                      '*plugin_args': 'str'} }
+
+##
+# @unload_plugin:
+#
+# Unloads a PANDA plugin
+# 
+# BDG 20120821
+##
+{ 'command': 'unload_plugin', 'data': { 'index': 'int' } }
+
+
+##
+# @PandaPluginInfo:
+#
+# Structure holding the information of a PANDA plugin
+##
+{ 'struct': 'PandaPluginInfo', 'data': {'index': 'int', 'name': 'str', 'address': 'int'} }
+
+##
+# @list_plugins:
+#
+# List loaded PANDA plugins
+# 
+# BDG 20120821
+##
+{ 'command': 'list_plugins', 'returns': ['PandaPluginInfo']}
+
+##
+# @plugin_cmd:
+#
+# Send a command to a loaded PANDA plugin
+# 
+# BDG 20120822
+##
+{ 'command': 'plugin_cmd', 'data': { 'cmd': 'str' } }
Only in qemu-2.9.1: qemu-bridge-helper.c
diff -bur qemu-2.9.1/qemu-nbd.c panda/qemu-nbd.c
--- qemu-2.9.1/qemu-nbd.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/qemu-nbd.c	2019-12-12 11:07:05.656457194 -0500
@@ -41,7 +41,7 @@
 #include <libgen.h>
 #include <pthread.h>
 
-#define SOCKET_PATH                "/var/lock/qemu-nbd-%s"
+#define SOCKET_PATH                "/var/lock/panda-nbd-%s"
 #define QEMU_NBD_OPT_CACHE         256
 #define QEMU_NBD_OPT_AIO           257
 #define QEMU_NBD_OPT_DISCARD       258
diff -bur qemu-2.9.1/qemu-options.hx panda/qemu-options.hx
--- qemu-2.9.1/qemu-options.hx	2017-09-07 12:25:12.000000000 -0400
+++ panda/qemu-options.hx	2019-12-05 17:27:34.575984393 -0500
@@ -4152,6 +4152,41 @@
 
 ETEXI
 
+#if defined(CONFIG_LLVM)
+DEF("llvm", 0, QEMU_OPTION_execute_llvm,
+    "-llvm           execute code using LLVM JIT\n", QEMU_ARCH_ALL)
+DEF("generate-llvm", 0, QEMU_OPTION_generate_llvm,
+    "-generate-llvm  translate code into LLVM but don't execute it\n", QEMU_ARCH_ALL)
+#endif
+
+DEF("record-from", HAS_ARG, QEMU_OPTION_record_from,
+    "-record-from <snapshot>:<record-name>\n"
+    "                load snapshot <snapshot> and begin recording\n", QEMU_ARCH_ALL)
+
+DEF("replay", HAS_ARG, QEMU_OPTION_replay,
+    "-replay </path/to/snapshot-prefix>\n"
+    "                replay the recording that starts at <snapshot>\n", QEMU_ARCH_ALL)
+
+DEF("pandalog", HAS_ARG, QEMU_OPTION_pandalog,
+    "-pandalog <filename>\n"
+    "                enable panda logging to file\n", QEMU_ARCH_ALL)
+
+DEF("panda-plugin", HAS_ARG, QEMU_OPTION_panda_plugin,
+    "-panda-plugin <file>\n"
+    "                load PANDA plugin from <file>\n", QEMU_ARCH_ALL)
+
+DEF("panda-arg", HAS_ARG, QEMU_OPTION_panda_arg,
+    "-panda-arg <plugin:opt=val>\n"
+    "                pass <opt=val> to <plugin>\n", QEMU_ARCH_ALL)
+
+DEF("panda", HAS_ARG, QEMU_OPTION_panda_plugins,
+    "-panda <plugin1_name:opt1=val1,opt2=val2;plugin2_name>\n"
+    "               load <plugin1> with <opt1=val1> and <opt2=val2>; load <plugin2>\n"
+    "               uses qemubuilddir/panda_plugins/panda_%s.so by default\n", QEMU_ARCH_ALL)
+
+DEF("os", HAS_ARG, QEMU_OPTION_panda_os_name,
+    "-os os_name\n"
+    "               inform panda about guest operating system\n", QEMU_ARCH_ALL)
 
 HXCOMM This is the last statement. Insert new options before this line!
 STEXI
diff -bur qemu-2.9.1/qom/cpu.c panda/qom/cpu.c
--- qemu-2.9.1/qom/cpu.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/qom/cpu.c	2019-12-05 17:27:34.579984393 -0500
@@ -113,19 +113,9 @@
     error_setg(errp, "Obtaining memory mappings is unsupported on this CPU.");
 }
 
-/* Resetting the IRQ comes from across the code base so we take the
- * BQL here if we need to.  cpu_interrupt assumes it is held.*/
 void cpu_reset_interrupt(CPUState *cpu, int mask)
 {
-    bool need_lock = !qemu_mutex_iothread_locked();
-
-    if (need_lock) {
-        qemu_mutex_lock_iothread();
-    }
     cpu->interrupt_request &= ~mask;
-    if (need_lock) {
-        qemu_mutex_unlock_iothread();
-    }
 }
 
 void cpu_exit(CPUState *cpu)
@@ -133,7 +123,7 @@
     atomic_set(&cpu->exit_request, 1);
     /* Ensure cpu_exec will see the exit request after TCG has exited.  */
     smp_wmb();
-    atomic_set(&cpu->icount_decr.u16.high, -1);
+    atomic_set(&cpu->tcg_exit_req, 1);
 }
 
 int cpu_write_elf32_qemunote(WriteCoreDumpFunction f, CPUState *cpu,
diff -bur qemu-2.9.1/qom/object.c panda/qom/object.c
--- qemu-2.9.1/qom/object.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/qom/object.c	2019-12-05 17:27:34.579984393 -0500
@@ -369,7 +369,7 @@
     g_assert_cmpint(size, >=, type->instance_size);
 
     memset(obj, 0, type->instance_size);
-    obj->class = type->class;
+    obj->klass = type->class;
     object_ref(obj);
     obj->properties = g_hash_table_new_full(g_str_hash, g_str_equal,
                                             NULL, object_property_free);
@@ -462,7 +462,7 @@
 static void object_finalize(void *data)
 {
     Object *obj = data;
-    TypeImpl *ti = obj->class->type;
+    TypeImpl *ti = obj->klass->type;
 
     object_property_del_all(obj);
     object_deinit(obj, ti);
@@ -612,7 +612,7 @@
 Object *object_dynamic_cast_assert(Object *obj, const char *typename,
                                    const char *file, int line, const char *func)
 {
-    trace_object_dynamic_cast_assert(obj ? obj->class->type->name : "(null)",
+    trace_object_dynamic_cast_assert(obj ? obj->klass->type->name : "(null)",
                                      typename, file, line, func);
 
 #ifdef CONFIG_QOM_CAST_DEBUG
@@ -620,7 +620,7 @@
     Object *inst;
 
     for (i = 0; obj && i < OBJECT_CLASS_CAST_CACHE; i++) {
-        if (atomic_read(&obj->class->object_cast_cache[i]) == typename) {
+        if (atomic_read(&obj->klass->object_cast_cache[i]) == typename) {
             goto out;
         }
     }
@@ -637,10 +637,10 @@
 
     if (obj && obj == inst) {
         for (i = 1; i < OBJECT_CLASS_CAST_CACHE; i++) {
-            atomic_set(&obj->class->object_cast_cache[i - 1],
-                       atomic_read(&obj->class->object_cast_cache[i]));
+            atomic_set(&obj->klass->object_cast_cache[i - 1],
+                       atomic_read(&obj->klass->object_cast_cache[i]));
         }
-        atomic_set(&obj->class->object_cast_cache[i - 1], typename);
+        atomic_set(&obj->klass->object_cast_cache[i - 1], typename);
     }
 
 out:
@@ -743,12 +743,12 @@
 
 const char *object_get_typename(Object *obj)
 {
-    return obj->class->type->name;
+    return obj->klass->type->name;
 }
 
 ObjectClass *object_get_class(Object *obj)
 {
-    return obj->class;
+    return obj->klass;
 }
 
 bool object_class_is_abstract(ObjectClass *klass)
@@ -1365,8 +1365,8 @@
 {
     Object *child = opaque;
 
-    if (child->class->unparent) {
-        (child->class->unparent)(child);
+    if (child->klass->unparent) {
+        (child->klass->unparent)(child);
     }
     child->parent = NULL;
     object_unref(child);
Only in panda: README.md
Only in panda: .README.md.swp
Only in panda/roms/ipxe: .git
Only in panda/roms/openbios: .git
Only in panda/roms/openhackware: .git
Only in panda/roms/qemu-palcode: console.c
Only in panda/roms/qemu-palcode: console.h
Only in panda/roms/qemu-palcode: console-low.S
Only in panda/roms/qemu-palcode: COPYING
Only in panda/roms/qemu-palcode: core-cia.h
Only in panda/roms/qemu-palcode: core-typhoon.h
Only in panda/roms/qemu-palcode: crb.c
Only in panda/roms/qemu-palcode: .git
Only in panda/roms/qemu-palcode: .gitignore
Only in panda/roms/qemu-palcode: HEADER
Only in panda/roms/qemu-palcode: hwrpb.h
Only in panda/roms/qemu-palcode: init.c
Only in panda/roms/qemu-palcode: ioport.h
Only in panda/roms/qemu-palcode: Makefile
Only in panda/roms/qemu-palcode: memcpy.c
Only in panda/roms/qemu-palcode: memset.c
Only in panda/roms/qemu-palcode: osf.h
Only in panda/roms/qemu-palcode: palcode.ld
Only in panda/roms/qemu-palcode: pal.h
Only in panda/roms/qemu-palcode: pal.S
Only in panda/roms/qemu-palcode: pci.c
Only in panda/roms/qemu-palcode: pci.h
Only in panda/roms/qemu-palcode: pci_ids.h
Only in panda/roms/qemu-palcode: pci_regs.h
Only in panda/roms/qemu-palcode: printf.c
Only in panda/roms/qemu-palcode: protos.h
Only in panda/roms/qemu-palcode: ps2port.c
Only in panda/roms/qemu-palcode: ps2port.h
Only in panda/roms/qemu-palcode: strlen.S
Only in panda/roms/qemu-palcode: sys-clipper.h
Only in panda/roms/qemu-palcode: sys-clipper.S
Only in panda/roms/qemu-palcode: sys-sx164.h
Only in panda/roms/qemu-palcode: uart.c
Only in panda/roms/qemu-palcode: uart.h
Only in panda/roms/qemu-palcode: util.c
Only in panda/roms/qemu-palcode: vgafonts.c
Only in panda/roms/qemu-palcode: vgaio.c
Only in panda/roms/qemu-palcode: vgatables.c
Only in panda/roms/qemu-palcode: vgatables.h
Only in panda/roms/seabios: .git
Only in panda/roms/sgabios: .git
Only in panda/roms/skiboot: .git
Only in panda/roms/SLOF: .git
Only in panda/roms/u-boot: .git
Only in panda/roms/vgabios: .git
diff -bur qemu-2.9.1/rules.mak panda/rules.mak
--- qemu-2.9.1/rules.mak	2017-09-07 12:25:12.000000000 -0400
+++ panda/rules.mak	2019-12-05 17:27:34.583984393 -0500
@@ -21,7 +21,7 @@
 clean-target:
 
 # Flags for C++ compilation
-QEMU_CXXFLAGS = -D__STDC_LIMIT_MACROS $(filter-out -Wstrict-prototypes -Wmissing-prototypes -Wnested-externs -Wold-style-declaration -Wold-style-definition -Wredundant-decls, $(QEMU_CFLAGS))
+QEMU_CXXFLAGS = -std=c++11 -fPIC -fpermissive -Wno-sign-compare -D__STDC_LIMIT_MACROS $(filter-out -std=% -Wstrict-prototypes -Wmissing-prototypes -Wnested-externs -Wold-style-declaration -Wold-style-definition -Wredundant-decls, $(QEMU_CFLAGS))
 
 # Flags for dependency generation
 QEMU_DGFLAGS += -MMD -MP -MT $@ -MF $(@D)/$(*F).d
@@ -34,6 +34,9 @@
 # different for target-dependent ones.
 QEMU_LOCAL_INCLUDES = -I$(BUILD_DIR)/$(@D) -I$(@D)
 
+# Include PANDA headers.
+QEMU_INCLUDES += -I$(SRC_PATH)/panda/include
+
 WL_U := -Wl,-u,
 find-symbols = $(if $1, $(sort $(shell $(NM) -P -g $1 | $2)))
 defined-symbols = $(call find-symbols,$1,awk '$$2!="U"{print $$1}')
diff -bur qemu-2.9.1/scripts/create_config panda/scripts/create_config
--- qemu-2.9.1/scripts/create_config	2017-09-07 12:25:12.000000000 -0400
+++ panda/scripts/create_config	2019-12-05 17:27:34.583984393 -0500
@@ -24,6 +24,15 @@
     # save for the next definitions
     eval "$name=\$define_value"
     ;;
+ panda_*dir=*) # panda-specific directory configuration
+    name=${line%=*}
+    value=${line#*=}
+    define_name=$(echo $name | LC_ALL=C tr '[a-z]' '[A-Z]')
+    eval "define_value=\"$value\""
+    echo "#define CONFIG_$define_name \"$define_value\""
+    # save for the next definitions
+    eval "$name=\$define_value"
+    ;;
  prefix=*)
     # save for the next definitions
     prefix=${line#*=}
diff -bur qemu-2.9.1/softmmu_template.h panda/softmmu_template.h
--- qemu-2.9.1/softmmu_template.h	2017-09-07 12:25:12.000000000 -0400
+++ panda/softmmu_template.h	2019-12-12 11:07:05.656457194 -0500
@@ -168,6 +168,7 @@
 #else
     res = glue(glue(ld, LSUFFIX), _le_p)((uint8_t *)haddr);
 #endif
+
     return res;
 }
 
@@ -412,6 +413,121 @@
     glue(glue(st, SUFFIX), _be_p)((uint8_t *)haddr, val);
 }
 #endif /* DATA_SIZE > 1 */
+
+WORD_TYPE glue(helper_le_ld_name, _panda)(CPUArchState *env, target_ulong addr,
+                                          TCGMemOpIdx oi, uintptr_t retaddr)
+{
+    unsigned mmu_idx = get_mmuidx(oi);
+    int index = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);
+    target_ulong tlb_addr = env->tlb_table[mmu_idx][index].addr_read;
+    CPUState *cpu = ENV_GET_CPU(env);
+    uintptr_t haddr = 0;
+
+    if ((addr & TARGET_PAGE_MASK) == tlb_addr) { // hit!
+        haddr = addr + env->tlb_table[mmu_idx][index].addend;
+    }
+
+    /*
+     * rwhelan: Hack to deal with the fact that we don't have the retaddr
+     * available at the time when we are translating from TCG, retaddr is
+     * handled in the TCG backend.  We get it here for LLVM.
+     */
+    if (execute_llvm && (retaddr == 0xDEADBEEF)){
+        retaddr = GETPC();
+    }
+
+    panda_callbacks_mem_before_read(cpu, cpu->panda_guest_pc, addr, DATA_SIZE, (void *)haddr);
+    WORD_TYPE ret = helper_le_ld_name(env, addr, oi, retaddr);
+    panda_callbacks_mem_after_read(cpu, cpu->panda_guest_pc, addr, DATA_SIZE, (uint64_t)ret, (void *)haddr);
+    return ret;
+}
+
+void glue(helper_le_st_name, _panda)(CPUArchState *env, target_ulong addr,
+                                     DATA_TYPE val, TCGMemOpIdx oi,
+                                     uintptr_t retaddr)
+{
+    unsigned mmu_idx = get_mmuidx(oi);
+    int index = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);
+    target_ulong tlb_addr = env->tlb_table[mmu_idx][index].addr_write;
+    CPUState *cpu = ENV_GET_CPU(env);
+    uintptr_t haddr = 0;
+
+    if ((addr & TARGET_PAGE_MASK) == tlb_addr) { // hit!
+        haddr = addr + env->tlb_table[mmu_idx][index].addend;
+    }
+
+    /*
+     * rwhelan: Hack to deal with the fact that we don't have the retaddr
+     * available at the time when we are translating from TCG, retaddr is
+     * handled in the TCG backend.  We get it here for LLVM.
+     */
+    if (execute_llvm && (retaddr == 0xDEADBEEF)){
+        retaddr = GETPC();
+    }
+
+    panda_callbacks_mem_before_write(cpu, cpu->panda_guest_pc, addr, DATA_SIZE, (uint64_t)val, (void *)haddr);
+    helper_le_st_name(env, addr, val, oi, retaddr);
+    panda_callbacks_mem_after_write(cpu, cpu->panda_guest_pc, addr, DATA_SIZE, (uint64_t)val, (void *)haddr);
+}
+
+#if DATA_SIZE > 1
+WORD_TYPE glue(helper_be_ld_name, _panda)(CPUArchState *env, target_ulong addr,
+                                          TCGMemOpIdx oi, uintptr_t retaddr)
+{
+    unsigned mmu_idx = get_mmuidx(oi);
+    int index = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);
+    target_ulong tlb_addr = env->tlb_table[mmu_idx][index].addr_read;
+    CPUState *cpu = ENV_GET_CPU(env);
+    uintptr_t haddr = 0;
+
+    if ((addr & TARGET_PAGE_MASK) == tlb_addr) { // hit!
+        haddr = addr + env->tlb_table[mmu_idx][index].addend;
+    }
+
+    /*
+     * rwhelan: Hack to deal with the fact that we don't have the retaddr
+     * available at the time when we are translating from TCG, retaddr is
+     * handled in the TCG backend.  We get it here for LLVM.
+     */
+    if (execute_llvm && (retaddr == 0xDEADBEEF)){
+        retaddr = GETPC();
+    }
+
+    panda_callbacks_mem_before_read(cpu, cpu->panda_guest_pc, addr, DATA_SIZE, (void *)haddr);
+    WORD_TYPE ret = helper_be_ld_name(env, addr, oi, retaddr);
+    panda_callbacks_mem_after_read(cpu, cpu->panda_guest_pc, addr, DATA_SIZE, (uint64_t)ret, (void *)haddr);
+    return ret;
+}
+
+void glue(helper_be_st_name, _panda)(CPUArchState *env, target_ulong addr,
+                                     DATA_TYPE val, TCGMemOpIdx oi,
+                                     uintptr_t retaddr)
+{
+    unsigned mmu_idx = get_mmuidx(oi);
+    int index = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);
+    target_ulong tlb_addr = env->tlb_table[mmu_idx][index].addr_write;
+    CPUState *cpu = ENV_GET_CPU(env);
+    uintptr_t haddr = 0;
+
+    if ((addr & TARGET_PAGE_MASK) == tlb_addr) { // hit!
+        haddr = addr + env->tlb_table[mmu_idx][index].addend;
+    }
+
+    /*
+     * rwhelan: Hack to deal with the fact that we don't have the retaddr
+     * available at the time when we are translating from TCG, retaddr is
+     * handled in the TCG backend.  We get it here for LLVM.
+     */
+    if (execute_llvm && (retaddr == 0xDEADBEEF)){
+        retaddr = GETPC();
+    }
+
+    panda_callbacks_mem_before_write(cpu, cpu->panda_guest_pc, addr, DATA_SIZE, (uint64_t)val, (void *)haddr);
+    helper_be_st_name(env, addr, val, oi, retaddr);
+    panda_callbacks_mem_after_write(cpu, cpu->panda_guest_pc, addr, DATA_SIZE, (uint64_t)val, (void *)haddr);
+}
+
+#endif /* DATA_SIZE > 1 */
 #endif /* !defined(SOFTMMU_CODE_ACCESS) */
 
 #undef READ_ACCESS_TYPE
Only in panda: tags
diff -bur qemu-2.9.1/target/arm/cpu.h panda/target/arm/cpu.h
--- qemu-2.9.1/target/arm/cpu.h	2017-09-07 12:25:12.000000000 -0400
+++ panda/target/arm/cpu.h	2019-12-05 17:27:34.595984393 -0500
@@ -1883,7 +1883,7 @@
 static inline bool arm_excp_unmasked(CPUState *cs, unsigned int excp_idx,
                                      unsigned int target_el)
 {
-    CPUARMState *env = cs->env_ptr;
+    CPUARMState *env = (CPUARMState *) cs->env_ptr;
     unsigned int cur_el = arm_current_el(env);
     bool secure = arm_is_secure(env);
     bool pstate_unmasked;
@@ -2465,7 +2465,7 @@
 static inline void cpu_get_tb_cpu_state(CPUARMState *env, target_ulong *pc,
                                         target_ulong *cs_base, uint32_t *flags)
 {
-    ARMMMUIdx mmu_idx = cpu_mmu_index(env, false);
+    ARMMMUIdx mmu_idx = (ARMMMUIdx)cpu_mmu_index(env, false);
     if (is_a64(env)) {
         *pc = env->pc;
         *flags = ARM_TBFLAG_AARCH64_STATE_MASK;
diff -bur qemu-2.9.1/target/arm/helper.c panda/target/arm/helper.c
--- qemu-2.9.1/target/arm/helper.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/target/arm/helper.c	2019-12-05 17:27:34.599984392 -0500
@@ -6946,12 +6946,6 @@
         arm_cpu_do_interrupt_aarch32(cs);
     }
 
-    /* Hooks may change global state so BQL should be held, also the
-     * BQL needs to be held for any modification of
-     * cs->interrupt_request.
-     */
-    g_assert(qemu_mutex_iothread_locked());
-
     arm_call_el_change_hook(cpu);
 
     if (!kvm_enabled()) {
diff -bur qemu-2.9.1/target/arm/helper.h panda/target/arm/helper.h
--- qemu-2.9.1/target/arm/helper.h	2017-09-07 12:25:12.000000000 -0400
+++ panda/target/arm/helper.h	2019-12-12 11:07:05.656457194 -0500
@@ -1,3 +1,5 @@
+#include "panda/callbacks/cb-helper-defs.h"
+
 DEF_HELPER_FLAGS_1(sxtb16, TCG_CALL_NO_RWG_SE, i32, i32)
 DEF_HELPER_FLAGS_1(uxtb16, TCG_CALL_NO_RWG_SE, i32, i32)
 
diff -bur qemu-2.9.1/target/arm/op_helper.c panda/target/arm/op_helper.c
--- qemu-2.9.1/target/arm/op_helper.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/target/arm/op_helper.c	2019-12-12 11:07:05.656457194 -0500
@@ -18,13 +18,14 @@
  */
 #include "qemu/osdep.h"
 #include "qemu/log.h"
-#include "qemu/main-loop.h"
 #include "cpu.h"
 #include "exec/helper-proto.h"
 #include "internals.h"
 #include "exec/exec-all.h"
 #include "exec/cpu_ldst.h"
 
+#include "panda/callbacks/cb-helper-impl.h"
+
 #define SIGNBIT (uint32_t)0x80000000
 #define SIGNBIT64 ((uint64_t)1 << 63)
 
@@ -495,9 +496,7 @@
      */
     env->regs[15] &= (env->thumb ? ~1 : ~3);
 
-    qemu_mutex_lock_iothread();
     arm_call_el_change_hook(arm_env_get_cpu(env));
-    qemu_mutex_unlock_iothread();
 }
 
 /* Access to user mode registers from privileged modes.  */
@@ -745,58 +744,28 @@
 {
     const ARMCPRegInfo *ri = rip;
 
-    if (ri->type & ARM_CP_IO) {
-        qemu_mutex_lock_iothread();
-        ri->writefn(env, ri, value);
-        qemu_mutex_unlock_iothread();
-    } else {
         ri->writefn(env, ri, value);
-    }
 }
 
 uint32_t HELPER(get_cp_reg)(CPUARMState *env, void *rip)
 {
     const ARMCPRegInfo *ri = rip;
-    uint32_t res;
-
-    if (ri->type & ARM_CP_IO) {
-        qemu_mutex_lock_iothread();
-        res = ri->readfn(env, ri);
-        qemu_mutex_unlock_iothread();
-    } else {
-        res = ri->readfn(env, ri);
-    }
 
-    return res;
+    return ri->readfn(env, ri);
 }
 
 void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t value)
 {
     const ARMCPRegInfo *ri = rip;
 
-    if (ri->type & ARM_CP_IO) {
-        qemu_mutex_lock_iothread();
-        ri->writefn(env, ri, value);
-        qemu_mutex_unlock_iothread();
-    } else {
         ri->writefn(env, ri, value);
-    }
 }
 
 uint64_t HELPER(get_cp_reg64)(CPUARMState *env, void *rip)
 {
     const ARMCPRegInfo *ri = rip;
-    uint64_t res;
 
-    if (ri->type & ARM_CP_IO) {
-        qemu_mutex_lock_iothread();
-        res = ri->readfn(env, ri);
-        qemu_mutex_unlock_iothread();
-    } else {
-        res = ri->readfn(env, ri);
-    }
-
-    return res;
+    return ri->readfn(env, ri);
 }
 
 void HELPER(msr_i_pstate)(CPUARMState *env, uint32_t op, uint32_t imm)
@@ -1029,9 +998,7 @@
                       cur_el, new_el, env->pc);
     }
 
-    qemu_mutex_lock_iothread();
     arm_call_el_change_hook(arm_env_get_cpu(env));
-    qemu_mutex_unlock_iothread();
 
     return;
 
diff -bur qemu-2.9.1/target/arm/translate.c panda/target/arm/translate.c
--- qemu-2.9.1/target/arm/translate.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/target/arm/translate.c	2019-12-12 11:07:05.656457194 -0500
@@ -36,6 +36,12 @@
 #include "trace-tcg.h"
 #include "exec/log.h"
 
+#include "panda/callbacks/cb-support.h"
+
+#ifdef CONFIG_SOFTMMU
+#include "panda/rr/rr_log.h"
+extern bool panda_update_pc;
+#endif
 
 #define ENABLE_ARCH_4T    arm_dc_feature(s, ARM_FEATURE_V4T)
 #define ENABLE_ARCH_5     arm_dc_feature(s, ARM_FEATURE_V5)
@@ -7535,6 +7541,20 @@
                                                 rt, isread, false);
                 }
                 break;
+            case 7:
+                /* Coprocessor 7 is used to implement PANDA hypercalls. */
+                if (!(insn & ARM_CP_RW_BIT)) {
+                    gen_set_pc_im(s, s->pc);
+                    gen_helper_panda_guest_hypercall(cpu_env);
+
+                    /* End block here. This enables using hypercalls to
+                     * implement advanced functionality. E.g. to switch
+                     * runtime from TCG to LLVM.
+                     */
+                    gen_jmp(s, s->pc);
+                    return 0;
+                }
+                /* ---fallthrough to default case--- */
             default:
                 /* ARMv8 defines that only coprocessors 14 and 15 exist,
                  * so this can only happen if this is an ARMv7 or earlier CPU,
@@ -11793,6 +11813,13 @@
         max_insns = TCG_MAX_INSNS;
     }
 
+    if (rr_in_replay()) {
+        uint64_t until_interrupt = rr_num_instr_before_next_interrupt();
+        if (max_insns > until_interrupt) {
+            max_insns = until_interrupt;
+        }
+    }
+
     gen_tb_start(tb);
 
     tcg_clear_temp_count();
@@ -11892,6 +11919,15 @@
             gen_io_start();
         }
 
+#ifdef CONFIG_SOFTMMU
+        //mz let's count this instruction
+        // In LLVM mode we generate this more efficiently.
+        if ((rr_on() || panda_update_pc) && !generate_llvm) {
+            gen_op_update_panda_pc(dc->pc);
+            gen_op_update_rr_icount();
+        }
+#endif
+
         if (dc->ss_active && !dc->pstate_ss) {
             /* Singlestep state is Active-pending.
              * If we're in this state at the start of a TB then either
@@ -11909,6 +11945,12 @@
             goto done_generating;
         }
 
+        // PANDA: ask if anyone wants execution notification
+        if (unlikely(panda_callbacks_insn_translate(cs, dc->pc))) {
+            // PANDA: Insert the instrumentation
+            gen_helper_panda_insn_exec(tcg_const_tl(dc->pc));
+        }
+
         if (dc->thumb) {
             disas_thumb_insn(env, dc);
             if (dc->condexec_mask) {
@@ -11925,6 +11967,11 @@
             disas_arm_insn(dc, insn);
         }
 
+        if (unlikely(panda_callbacks_after_insn_translate(cs, dc->pc))
+                && !dc->is_jmp) {
+            gen_helper_panda_after_insn_exec(tcg_const_tl(dc->pc));
+        }
+
         if (dc->condjmp && !dc->is_jmp) {
             gen_set_label(dc->condlabel);
             dc->condjmp = 0;
diff -bur qemu-2.9.1/target/i386/cpu.c panda/target/i386/cpu.c
--- qemu-2.9.1/target/i386/cpu.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/target/i386/cpu.c	2019-12-05 17:27:34.607984392 -0500
@@ -2371,6 +2371,15 @@
 
 }
 
+static gchar *x86_gdb_arch_name(CPUState *cs)
+{
+#ifdef TARGET_X86_64
+        return g_strdup("i386:x86-64");
+#else
+            return g_strdup("i386");
+#endif
+}
+
 /* Return a QDict containing keys for all properties that can be included
  * in static expansion of CPU models. All properties set by x86_cpu_load_def()
  * must be included in the dictionary.
@@ -4056,10 +4065,15 @@
     cc->write_elf32_qemunote = x86_cpu_write_elf32_qemunote;
     cc->vmsd = &vmstate_x86_cpu;
 #endif
-    /* CPU_NB_REGS * 2 = general regs + xmm regs
-     * 25 = eip, eflags, 6 seg regs, st[0-7], fctrl,...,fop, mxcsr.
-     */
-    cc->gdb_num_core_regs = CPU_NB_REGS * 2 + 25;
+
+    cc->gdb_arch_name = x86_gdb_arch_name;
+#ifdef TARGET_X86_64
+    cc->gdb_core_xml_file = "i386-64bit-core.xml";
+    cc->gdb_num_core_regs = 40;
+#else
+    cc->gdb_core_xml_file = "i386-32bit-core.xml";
+    cc->gdb_num_core_regs = 32;
+#endif
 #ifndef CONFIG_USER_ONLY
     cc->debug_excp_handler = breakpoint_handler;
 #endif
diff -bur qemu-2.9.1/target/i386/cpu.h panda/target/i386/cpu.h
--- qemu-2.9.1/target/i386/cpu.h	2017-09-07 12:25:12.000000000 -0400
+++ panda/target/i386/cpu.h	2019-12-05 17:27:34.607984392 -0500
@@ -1621,7 +1621,9 @@
 
 static inline MemTxAttrs cpu_get_mem_attrs(CPUX86State *env)
 {
-    return ((MemTxAttrs) { .secure = (env->hflags & HF_SMM_MASK) != 0 });
+    MemTxAttrs mta;
+    mta.secure = (env->hflags & HF_SMM_MASK) != 0;
+    return mta;
 }
 
 /* fpu_helper.c */
diff -bur qemu-2.9.1/target/i386/helper.c panda/target/i386/helper.c
--- qemu-2.9.1/target/i386/helper.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/target/i386/helper.c	2020-01-22 10:59:21.906782755 -0500
@@ -29,6 +29,8 @@
 #include "hw/i386/apic_internal.h"
 #endif
 
+#include "panda/callbacks/cb-support.h"
+
 static void cpu_x86_version(CPUX86State *env, int *family, int *model)
 {
     int cpuver = env->cpuid_version;
@@ -642,12 +644,16 @@
 {
     X86CPU *cpu = x86_env_get_cpu(env);
 
+    // ret val !=0 means *dont* allow cr3 to change
+    if (0 == (panda_callbacks_asid_changed(ENV_GET_CPU(env), env->cr[3], new_cr3))) {
+
     env->cr[3] = new_cr3;
     if (env->cr[0] & CR0_PG_MASK) {
         qemu_log_mask(CPU_LOG_MMU,
                         "CR3 update: CR3=" TARGET_FMT_lx "\n", new_cr3);
         tlb_flush(CPU(cpu));
     }
+    }
 }
 
 void cpu_x86_update_cr4(CPUX86State *env, uint32_t new_cr4)
diff -bur qemu-2.9.1/target/i386/helper.h panda/target/i386/helper.h
--- qemu-2.9.1/target/i386/helper.h	2017-09-07 12:25:12.000000000 -0400
+++ panda/target/i386/helper.h	2019-12-12 11:07:05.656457194 -0500
@@ -1,3 +1,5 @@
+#include "panda/callbacks/cb-helper-defs.h"
+
 DEF_HELPER_FLAGS_4(cc_compute_all, TCG_CALL_NO_RWG_SE, tl, tl, tl, tl, int)
 DEF_HELPER_FLAGS_4(cc_compute_c, TCG_CALL_NO_RWG_SE, tl, tl, tl, tl, int)
 
diff -bur qemu-2.9.1/target/i386/kvm.c panda/target/i386/kvm.c
--- qemu-2.9.1/target/i386/kvm.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/target/i386/kvm.c	2019-12-05 17:27:34.611984392 -0500
@@ -3131,13 +3131,13 @@
                     case 0x1:
                         ret = EXCP_DEBUG;
                         cs->watchpoint_hit = &hw_watchpoint;
-                        hw_watchpoint.vaddr = hw_breakpoint[n].addr;
+                        hw_watchpoint.virtaddr = hw_breakpoint[n].addr;
                         hw_watchpoint.flags = BP_MEM_WRITE;
                         break;
                     case 0x3:
                         ret = EXCP_DEBUG;
                         cs->watchpoint_hit = &hw_watchpoint;
-                        hw_watchpoint.vaddr = hw_breakpoint[n].addr;
+                        hw_watchpoint.virtaddr = hw_breakpoint[n].addr;
                         hw_watchpoint.flags = BP_MEM_ACCESS;
                         break;
                     }
diff -bur qemu-2.9.1/target/i386/misc_helper.c panda/target/i386/misc_helper.c
--- qemu-2.9.1/target/i386/misc_helper.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/target/i386/misc_helper.c	2019-12-12 11:07:05.656457194 -0500
@@ -18,13 +18,17 @@
  */
 
 #include "qemu/osdep.h"
-#include "qemu/main-loop.h"
 #include "cpu.h"
 #include "exec/helper-proto.h"
 #include "exec/exec-all.h"
 #include "exec/cpu_ldst.h"
 #include "exec/address-spaces.h"
 
+#ifdef CONFIG_SOFTMMU
+#include "panda/rr/rr_log.h"
+#endif
+#include "panda/callbacks/cb-helper-impl.h"
+
 void helper_outb(CPUX86State *env, uint32_t port, uint32_t data)
 {
 #ifdef CONFIG_USER_ONLY
@@ -100,10 +104,15 @@
 
 void helper_cpuid(CPUX86State *env)
 {
-    uint32_t eax, ebx, ecx, edx;
 
     cpu_svm_check_intercept_param(env, SVM_EXIT_CPUID, 0, GETPC());
 
+    if (panda_callbacks_guest_hypercall(ENV_GET_CPU(env))) {
+        // cpuid processed by one of the callbacks
+        return;
+    }
+
+    uint32_t eax, ebx, ecx, edx;
     cpu_x86_cpuid(env, (uint32_t)env->regs[R_EAX], (uint32_t)env->regs[R_ECX],
                   &eax, &ebx, &ecx, &edx);
     env->regs[R_EAX] = eax;
@@ -157,9 +166,7 @@
         break;
     case 8:
         if (!(env->hflags2 & HF2_VINTR_MASK)) {
-            qemu_mutex_lock_iothread();
             cpu_set_apic_tpr(x86_env_get_cpu(env)->apic_state, t0);
-            qemu_mutex_unlock_iothread();
         }
         env->v_tpr = t0 & 0x0f;
         break;
@@ -195,7 +202,16 @@
     }
     cpu_svm_check_intercept_param(env, SVM_EXIT_RDTSC, 0, GETPC());
 
+#ifdef CONFIG_SOFTMMU
+    RR_DO_RECORD_OR_REPLAY(
+        /*action=*/val = cpu_get_tsc(env) + env->tsc_offset,
+        /*record=*/rr_input_8(&val),
+        /*replay=*/rr_input_8(&val),
+        /*location=*/RR_CALLSITE_RDTSC);
+#else
     val = cpu_get_tsc(env) + env->tsc_offset;
+#endif
+
     env->regs[R_EAX] = (uint32_t)(val);
     env->regs[R_EDX] = (uint32_t)(val >> 32);
 }
diff -bur qemu-2.9.1/target/i386/seg_helper.c panda/target/i386/seg_helper.c
--- qemu-2.9.1/target/i386/seg_helper.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/target/i386/seg_helper.c	2019-12-05 17:27:34.611984392 -0500
@@ -26,6 +26,10 @@
 #include "exec/cpu_ldst.h"
 #include "exec/log.h"
 
+#ifdef CONFIG_SOFTMMU
+#include "panda/rr/rr_log.h"
+#endif
+
 //#define DEBUG_PCALL
 
 #ifdef DEBUG_PCALL
@@ -1361,7 +1365,15 @@
             cpu_svm_check_intercept_param(env, SVM_EXIT_INTR, 0, 0);
             cs->interrupt_request &= ~(CPU_INTERRUPT_HARD |
                                        CPU_INTERRUPT_VIRQ);
-            intno = cpu_get_pic_interrupt(env);
+            // dont bother calling this if we are replaying
+            // ... just obtain "intno" from (or record it to)
+            // non-deterministic inputs log
+            RR_DO_RECORD_OR_REPLAY(
+                /*action=*/intno = cpu_get_pic_interrupt(env),
+                /*record=*/rr_input_4((uint32_t*)&intno),
+                /*replay=*/if (!rr_replay_intno((uint32_t*)&intno)) { return false; },
+                /*location=*/ RR_CALLSITE_CPU_HANDLE_INTERRUPT_INTNO);
+
             qemu_log_mask(CPU_LOG_TB_IN_ASM,
                           "Servicing hardware INT=0x%02x\n", intno);
             do_interrupt_x86_hardirq(env, intno, 1);
diff -bur qemu-2.9.1/target/i386/smm_helper.c panda/target/i386/smm_helper.c
--- qemu-2.9.1/target/i386/smm_helper.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/target/i386/smm_helper.c	2019-12-05 17:27:34.611984392 -0500
@@ -18,10 +18,10 @@
  */
 
 #include "qemu/osdep.h"
-#include "qemu/main-loop.h"
 #include "cpu.h"
 #include "exec/helper-proto.h"
 #include "exec/log.h"
+#include "panda/rr/rr_log.h"
 
 /* SMM support */
 
@@ -43,14 +43,11 @@
 #define SMM_REVISION_ID 0x00020000
 #endif
 
-/* Called with iothread lock taken */
 void cpu_smm_update(X86CPU *cpu)
 {
     CPUX86State *env = &cpu->env;
     bool smm_enabled = (env->hflags & HF_SMM_MASK);
 
-    g_assert(qemu_mutex_iothread_locked());
-
     if (cpu->smram) {
         memory_region_set_enabled(cpu->smram, smm_enabled);
     }
@@ -73,6 +70,7 @@
     } else {
         env->hflags2 |= HF2_NMI_MASK;
     }
+
     cpu_smm_update(cpu);
 
     sm_state = env->smbase + 0x8000;
@@ -337,10 +335,7 @@
     }
     env->hflags2 &= ~HF2_SMM_INSIDE_NMI_MASK;
     env->hflags &= ~HF_SMM_MASK;
-
-    qemu_mutex_lock_iothread();
     cpu_smm_update(cpu);
-    qemu_mutex_unlock_iothread();
 
     qemu_log_mask(CPU_LOG_INT, "SMM: after RSM\n");
     log_cpu_state_mask(CPU_LOG_INT, CPU(cpu), CPU_DUMP_CCOP);
diff -bur qemu-2.9.1/target/i386/translate.c panda/target/i386/translate.c
--- qemu-2.9.1/target/i386/translate.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/target/i386/translate.c	2019-12-12 11:07:05.660457299 -0500
@@ -25,6 +25,15 @@
 #include "tcg-op.h"
 #include "exec/cpu_ldst.h"
 
+#ifdef CONFIG_SOFTMMU
+#include "panda/rr/rr_log.h"
+#include "panda/rr/rr_api.h"
+#include "panda/checkpoint.h"
+extern bool panda_update_pc;
+#endif
+
+#include "panda/callbacks/cb-support.h"
+
 #include "exec/helper-proto.h"
 #include "exec/helper-gen.h"
 
@@ -32,6 +41,7 @@
 #include "exec/log.h"
 
 
+
 #define PREFIX_REPZ   0x01
 #define PREFIX_REPNZ  0x02
 #define PREFIX_LOCK   0x04
@@ -1998,7 +2008,7 @@
     }
 
  done:
-    return (AddressParts){ def_seg, base, index, scale, disp };
+    return (AddressParts) { def_seg, base, index, scale, disp };
 }
 
 /* Compute the address, with a minimum number of TCG ops.  */
@@ -8421,6 +8431,14 @@
     cpu_ptr1 = tcg_temp_new_ptr();
     cpu_cc_srcT = tcg_temp_local_new();
 
+#ifdef CONFIG_SOFTMMU
+    //mz for record and replay, let's start each block with EIP = pc_start.
+    //mz this way, we can chain in record and not chain in replay.
+    if (rr_on()) {
+        gen_jmp_im(pc_start - dc->cs_base);
+    }
+#endif
+
     dc->is_jmp = DISAS_NEXT;
     pc_ptr = pc_start;
     num_insns = 0;
@@ -8432,15 +8450,64 @@
         max_insns = TCG_MAX_INSNS;
     }
 
+    if (rr_in_replay()) {
+        uint64_t until_interrupt = rr_num_instr_before_next_interrupt();
+        if (max_insns > until_interrupt) {
+            max_insns = until_interrupt;
+        }
+    }
+
+    uint64_t rr_updated_instr_count = rr_get_guest_instr_count();
+
+    /*
+     * This function call emits a few instructions at the beginning of every
+     * basic block checking for an exit request.  This probably won't affect
+     * LLVM code translation and any analyses that are built on top of that.
+     */
     gen_tb_start(tb);
     for(;;) {
         tcg_gen_insn_start(pc_ptr, dc->cc_op);
         num_insns++;
 
+        // Check reverse-continue status and conditions
+        // potentially restoring to checkpoint
+        cpu_rcont_check_restore(cs, rr_updated_instr_count);
+
         /* If RF is set, suppress an internally generated breakpoint.  */
         if (unlikely(cpu_breakpoint_test(cs, pc_ptr,
                                          tb->flags & HF_RF_MASK
-                                         ? BP_GDB : BP_ANY))) {
+                                         ? BP_GDB : BP_ANY)) || 
+                unlikely(cpu_rr_breakpoint_test(cs, rr_updated_instr_count, 
+                                             tb->flags & HF_RF_MASK ? BP_GDB : BP_ANY))) {
+                // If we're in reverse direction, don't gen a debug event. 
+                // Instead, record it so we can figure out the latest one
+                if (unlikely(cs->reverse_flags & GDB_RCONT)) {
+                    cs->last_bp_hit_instr = rr_updated_instr_count;
+                } else if (cs->reverse_flags & GDB_RSTEP) {
+                    if (rr_updated_instr_count >= cs->last_gdb_instr) {
+                        fprintf(stderr, "GDB_RSTEP went too far");
+                        abort();
+                    }
+
+                    if (rr_updated_instr_count == cs->last_gdb_instr-1) {
+                        cs->reverse_flags |= GDB_RDONE;
+                        goto generate_debug;
+                    }
+
+                } else if (cs->reverse_flags & GDB_RCONT_BREAK) {
+                    // We are doing second pass of reverse-continue
+                    // break on latest breakpoint/watchpoint 
+                    if (rr_updated_instr_count > cs->last_bp_hit_instr) {
+                        fprintf(stderr, "GDB_RCONT_BREAK went too far");
+                        abort();
+                    }
+
+                    if  (rr_updated_instr_count == cs->last_bp_hit_instr) {
+                        cs->reverse_flags = 0;
+                        goto generate_debug;
+                    }
+                } else {
+generate_debug:
             gen_debug(dc, pc_ptr - dc->cs_base);
             /* The address covered by the breakpoint must be included in
                [tb->pc, tb->pc + tb->size) in order to for it to be
@@ -8449,11 +8516,33 @@
             pc_ptr += 1;
             goto done_generating;
         }
+        }
         if (num_insns == max_insns && (tb->cflags & CF_LAST_IO)) {
             gen_io_start();
         }
 
+#ifdef CONFIG_SOFTMMU
+        //mz let's count this instruction
+        // In LLVM mode we generate this more efficiently.
+        if ((rr_on() || panda_update_pc) && !generate_llvm) {
+            gen_op_update_panda_pc(pc_ptr);
+            gen_op_update_rr_icount();
+        }
+#endif
+
+        // PANDA: ask if anyone wants execution notification
+        if (unlikely(panda_callbacks_insn_translate(ENV_GET_CPU(env), pc_ptr))) {
+            gen_helper_panda_insn_exec(tcg_const_tl(pc_ptr));
+        }
+
         pc_ptr = disas_insn(env, dc, pc_ptr);
+        rr_updated_instr_count++;
+
+        if (unlikely(panda_callbacks_after_insn_translate(ENV_GET_CPU(env), pc_ptr))
+                && !dc->is_jmp) {
+            gen_helper_panda_after_insn_exec(tcg_const_tl(pc_ptr));
+        }
+
         /* stop translation if indicated */
         if (dc->is_jmp)
             break;
@@ -8474,7 +8563,7 @@
            If current instruction already crossed the bound - it's ok,
            because an exception hasn't stopped this code.
          */
-        if ((tb->cflags & CF_USE_ICOUNT)
+        if (((tb->cflags & CF_USE_ICOUNT) || rr_in_record() || rr_in_replay())
             && ((pc_ptr & TARGET_PAGE_MASK)
                 != ((pc_ptr + TARGET_MAX_INSN_SIZE - 1) & TARGET_PAGE_MASK)
                 || (pc_ptr & ~TARGET_PAGE_MASK) == 0)) {
diff -bur qemu-2.9.1/target/ppc/cpu-qom.h panda/target/ppc/cpu-qom.h
--- qemu-2.9.1/target/ppc/cpu-qom.h	2017-09-07 12:25:12.000000000 -0400
+++ panda/target/ppc/cpu-qom.h	2019-12-05 17:27:34.627984391 -0500
@@ -44,7 +44,9 @@
 
 /*****************************************************************************/
 /* MMU model                                                                 */
+#ifndef __cplusplus
 typedef enum powerpc_mmu_t powerpc_mmu_t;
+#endif
 enum powerpc_mmu_t {
     POWERPC_MMU_UNKNOWN    = 0x00000000,
     /* Standard 32 bits PowerPC MMU                            */
@@ -99,7 +101,9 @@
 
 /*****************************************************************************/
 /* Exception model                                                           */
+#ifndef __cplusplus
 typedef enum powerpc_excp_t powerpc_excp_t;
+#endif
 enum powerpc_excp_t {
     POWERPC_EXCP_UNKNOWN   = 0,
     /* Standard PowerPC exception model */
@@ -145,7 +149,9 @@
 
 /*****************************************************************************/
 /* Input pins model                                                          */
+#ifndef __cplusplus
 typedef enum powerpc_input_t powerpc_input_t;
+#endif
 enum powerpc_input_t {
     PPC_FLAGS_INPUT_UNKNOWN = 0,
     /* PowerPC 6xx bus                  */
diff -bur qemu-2.9.1/target/ppc/excp_helper.c panda/target/ppc/excp_helper.c
--- qemu-2.9.1/target/ppc/excp_helper.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/target/ppc/excp_helper.c	2019-12-05 17:27:34.627984391 -0500
@@ -24,6 +24,10 @@
 
 #include "helper_regs.h"
 
+#ifdef CONFIG_SOFTMMU
+#include "panda/rr/rr_log.h"
+#endif
+
 //#define DEBUG_OP
 //#define DEBUG_SOFTWARE_TLB
 //#define DEBUG_EXCEPTIONS
@@ -869,11 +873,19 @@
     PowerPCCPU *cpu = POWERPC_CPU(cs);
     CPUPPCState *env = &cpu->env;
 
+    rr_pending_interrupts_at(
+            RR_CALLSITE_CPU_PENDING_INTERRUPTS_BEFORE,
+            (uint32_t*)&env->pending_interrupts);
+
     if (interrupt_request & CPU_INTERRUPT_HARD) {
         ppc_hw_interrupt(env);
         if (env->pending_interrupts == 0) {
             cs->interrupt_request &= ~CPU_INTERRUPT_HARD;
         }
+
+        rr_pending_interrupts_at(
+                RR_CALLSITE_CPU_PENDING_INTERRUPTS_AFTER,
+                (uint32_t*)&env->pending_interrupts);
         return true;
     }
     return false;
diff -bur qemu-2.9.1/target/ppc/helper.h panda/target/ppc/helper.h
--- qemu-2.9.1/target/ppc/helper.h	2017-09-07 12:25:12.000000000 -0400
+++ panda/target/ppc/helper.h	2019-12-12 11:07:05.660457299 -0500
@@ -1,3 +1,5 @@
+#include "panda/callbacks/cb-helper-defs.h"
+
 DEF_HELPER_FLAGS_3(raise_exception_err, TCG_CALL_NO_WG, void, env, i32, i32)
 DEF_HELPER_FLAGS_2(raise_exception, TCG_CALL_NO_WG, void, env, i32)
 DEF_HELPER_FLAGS_4(tw, TCG_CALL_NO_WG, void, env, tl, tl, i32)
diff -bur qemu-2.9.1/target/ppc/misc_helper.c panda/target/ppc/misc_helper.c
--- qemu-2.9.1/target/ppc/misc_helper.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/target/ppc/misc_helper.c	2019-12-12 11:07:05.660457299 -0500
@@ -22,6 +22,7 @@
 #include "exec/helper-proto.h"
 
 #include "helper_regs.h"
+#include "panda/callbacks/cb-helper-impl.h"
 
 /*****************************************************************************/
 /* SPR accesses */
diff -bur qemu-2.9.1/target/ppc/translate.c panda/target/ppc/translate.c
--- qemu-2.9.1/target/ppc/translate.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/target/ppc/translate.c	2019-12-12 11:07:05.660457299 -0500
@@ -33,6 +33,11 @@
 #include "trace-tcg.h"
 #include "exec/log.h"
 
+#include "panda/callbacks/cb-support.h"
+
+#ifdef CONFIG_SOFTMMU
+#include "panda/rr/rr_log.h"
+#endif
 
 #define CPU_SINGLE_STEP 0x1
 #define CPU_BRANCH_STEP 0x2
@@ -7249,6 +7254,13 @@
         max_insns = TCG_MAX_INSNS;
     }
 
+    if (rr_in_replay()) {
+        uint64_t until_interrupt = rr_num_instr_before_next_interrupt();
+        if (max_insns > until_interrupt) {
+            max_insns = until_interrupt;
+        }
+    }
+
     gen_tb_start(tb);
     tcg_clear_temp_count();
     /* Set env in case of segfault during code fetch */
@@ -7271,6 +7283,16 @@
                   ctx.nip, ctx.mem_idx, (int)msr_ir);
         if (num_insns == max_insns && (tb->cflags & CF_LAST_IO))
             gen_io_start();
+
+#ifdef CONFIG_SOFTMMU
+        //mz let's count this instruction
+        // In LLVM mode we generate this more efficiently.
+        if (rr_on() && !generate_llvm) {
+            gen_op_update_panda_pc(ctx.nip);
+            gen_op_update_rr_icount();
+        }
+#endif
+
         if (unlikely(need_byteswap(&ctx))) {
             ctx.opcode = bswap32(cpu_ldl_code(env, ctx.nip));
         } else {
@@ -7323,10 +7345,22 @@
                 break;
             }
         }
+
+        // PANDA: ask if anyone wants execution notification
+        if (unlikely(panda_callbacks_insn_translate(cs, ctx.nip))) {
+            // PANDA: Insert the instrumentation
+            gen_helper_panda_insn_exec(tcg_const_tl(ctx.nip));
+        }
+
         (*(handler->handler))(&ctx);
 #if defined(DO_PPC_STATISTICS)
         handler->count++;
 #endif
+
+        if (unlikely(panda_callbacks_after_insn_translate(cs, ctx.nip))) {
+            gen_helper_panda_after_insn_exec(tcg_const_tl(ctx.nip));
+        }
+
         /* Check trace mode exceptions */
         if (unlikely(ctx.singlestep_enabled & CPU_SINGLE_STEP &&
                      (ctx.nip <= 0x100 || ctx.nip > 0xF00) &&
diff -bur qemu-2.9.1/target/ppc/translate_init.c panda/target/ppc/translate_init.c
--- qemu-2.9.1/target/ppc/translate_init.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/target/ppc/translate_init.c	2019-12-05 17:27:34.635984391 -0500
@@ -10400,12 +10400,12 @@
     return msr_ee && (cs->interrupt_request & CPU_INTERRUPT_HARD);
 }
 
+//rw: commented out this part, which introduced bugs in replay when reserve_addr was getting erroneusly cleared after an lwarx
 static void ppc_cpu_exec_enter(CPUState *cs)
 {
-    PowerPCCPU *cpu = POWERPC_CPU(cs);
-    CPUPPCState *env = &cpu->env;
-
-    env->reserve_addr = -1;
+    /*PowerPCCPU *cpu = POWERPC_CPU(cs);*/
+    /*CPUPPCState *env = &cpu->env;*/
+    /*env->reserve_addr = -1;*/
 }
 
 /* CPUClass::reset() */
diff -bur qemu-2.9.1/target/s390x/misc_helper.c panda/target/s390x/misc_helper.c
--- qemu-2.9.1/target/s390x/misc_helper.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/target/s390x/misc_helper.c	2019-12-05 17:27:34.639984391 -0500
@@ -26,7 +26,6 @@
 #include "exec/helper-proto.h"
 #include "sysemu/kvm.h"
 #include "qemu/timer.h"
-#include "qemu/main-loop.h"
 #include "exec/address-spaces.h"
 #ifdef CONFIG_KVM
 #include <linux/kvm.h>
@@ -111,13 +110,11 @@
 /* SCLP service call */
 uint32_t HELPER(servc)(CPUS390XState *env, uint64_t r1, uint64_t r2)
 {
-    qemu_mutex_lock_iothread();
     int r = sclp_service_call(env, r1, r2);
     if (r < 0) {
         program_interrupt(env, -r, 4);
-        r = 0;
+        return 0;
     }
-    qemu_mutex_unlock_iothread();
     return r;
 }
 
diff -bur qemu-2.9.1/tcg/i386/tcg-target.inc.c panda/tcg/i386/tcg-target.inc.c
--- qemu-2.9.1/tcg/i386/tcg-target.inc.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/tcg/i386/tcg-target.inc.c	2019-12-05 17:27:34.655984390 -0500
@@ -1224,10 +1224,13 @@
 }
 
 #if defined(CONFIG_SOFTMMU)
+extern bool panda_use_memcb;
+
 /* helper signature: helper_ret_ld_mmu(CPUState *env, target_ulong addr,
  *                                     int mmu_idx, uintptr_t ra)
  */
-static void * const qemu_ld_helpers[16] = {
+
+static void * const qemu_ld_helpers_normal[16] = {
     [MO_UB]   = helper_ret_ldub_mmu,
     [MO_LEUW] = helper_le_lduw_mmu,
     [MO_LEUL] = helper_le_ldul_mmu,
@@ -1236,11 +1239,23 @@
     [MO_BEUL] = helper_be_ldul_mmu,
     [MO_BEQ]  = helper_be_ldq_mmu,
 };
+static void * const qemu_ld_helpers_panda[16] = {
+    [MO_UB]   = helper_ret_ldub_mmu_panda,
+    [MO_LEUW] = helper_le_lduw_mmu_panda,
+    [MO_LEUL] = helper_le_ldul_mmu_panda,
+    [MO_LEQ]  = helper_le_ldq_mmu_panda,
+    [MO_BEUW] = helper_be_lduw_mmu_panda,
+    [MO_BEUL] = helper_be_ldul_mmu_panda,
+    [MO_BEQ]  = helper_be_ldq_mmu_panda,
+};
+#define qemu_ld_helpers \
+    (panda_use_memcb ? qemu_ld_helpers_panda : qemu_ld_helpers_normal)
 
 /* helper signature: helper_ret_st_mmu(CPUState *env, target_ulong addr,
  *                                     uintxx_t val, int mmu_idx, uintptr_t ra)
  */
-static void * const qemu_st_helpers[16] = {
+
+static void * const qemu_st_helpers_normal[16] = {
     [MO_UB]   = helper_ret_stb_mmu,
     [MO_LEUW] = helper_le_stw_mmu,
     [MO_LEUL] = helper_le_stl_mmu,
@@ -1249,6 +1264,17 @@
     [MO_BEUL] = helper_be_stl_mmu,
     [MO_BEQ]  = helper_be_stq_mmu,
 };
+static void * const qemu_st_helpers_panda[16] = {
+    [MO_UB]   = helper_ret_stb_mmu_panda,
+    [MO_LEUW] = helper_le_stw_mmu_panda,
+    [MO_LEUL] = helper_le_stl_mmu_panda,
+    [MO_LEQ]  = helper_le_stq_mmu_panda,
+    [MO_BEUW] = helper_be_stw_mmu_panda,
+    [MO_BEUL] = helper_be_stl_mmu_panda,
+    [MO_BEQ]  = helper_be_stq_mmu_panda,
+};
+#define qemu_st_helpers \
+    (panda_use_memcb ? qemu_st_helpers_panda : qemu_st_helpers_normal)
 
 /* Perform the TLB load and compare.
 
@@ -1334,6 +1360,9 @@
     tcg_out_mov(s, ttype, r1, addrlo);
 
     /* jne slow_path */
+    if (panda_use_memcb)
+        tcg_out_opc(s, OPC_JMP_long, 0, 0, 0);
+    else
     tcg_out_opc(s, OPC_JCC_long + JCC_JNE, 0, 0, 0);
     label_ptr[0] = s->code_ptr;
     s->code_ptr += 4;
@@ -2725,7 +2754,7 @@
 };
 #endif
 
-#if defined(ELF_HOST_MACHINE)
+#if defined(ELF_HOST_MACHINE) && !defined(CONFIG_LLVM)
 void tcg_register_jit(void *buf, size_t buf_size)
 {
     tcg_register_jit_int(buf, buf_size, &debug_frame, sizeof(debug_frame));
diff -bur qemu-2.9.1/tcg/tcg.c panda/tcg/tcg.c
--- qemu-2.9.1/tcg/tcg.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/tcg/tcg.c	2019-12-05 17:27:34.659984390 -0500
@@ -962,7 +962,7 @@
 }
 
 /* Find helper name.  */
-static inline const char *tcg_find_helper(TCGContext *s, uintptr_t val)
+const char *tcg_find_helper(TCGContext *s, uintptr_t val)
 {
     const char *ret = NULL;
     if (s->helpers) {
@@ -2736,7 +2736,7 @@
 }
 #endif
 
-#ifdef ELF_HOST_MACHINE
+#if defined(ELF_HOST_MACHINE) && !defined(CONFIG_LLVM)
 /* In order to use this feature, the backend needs to do three things:
 
    (1) Define ELF_HOST_MACHINE to indicate both what value to
@@ -2750,6 +2750,7 @@
 */
 
 /* Begin GDB interface.  THE FOLLOWING MUST MATCH GDB DOCS.  */
+
 typedef enum {
     JIT_NOACTION = 0,
     JIT_REGISTER_FN,
diff -bur qemu-2.9.1/tcg/tcg.h panda/tcg/tcg.h
--- qemu-2.9.1/tcg/tcg.h	2017-09-07 12:25:12.000000000 -0400
+++ panda/tcg/tcg.h	2019-12-05 17:27:34.659984390 -0500
@@ -660,6 +660,7 @@
     intptr_t frame_start;
     intptr_t frame_end;
     TCGTemp *frame_temp;
+    TCGTemp *rr_instr_count_temp;
 
     tcg_insn_unit *code_ptr;
 
@@ -936,6 +937,7 @@
 void tcg_optimize(TCGContext *s);
 
 /* only used for debugging purposes */
+const char *tcg_find_helper(TCGContext *s, uintptr_t val);
 void tcg_dump_ops(TCGContext *s);
 
 TCGv_i32 tcg_const_i32(int32_t val);
@@ -985,7 +987,7 @@
 
 static inline ptrdiff_t tcg_ptr_byte_diff(void *a, void *b)
 {
-    return a - b;
+    return (uintptr_t)a - (uintptr_t)b;
 }
 
 /**
@@ -1039,7 +1041,7 @@
  */
 static inline TCGMemOp get_memop(TCGMemOpIdx oi)
 {
-    return oi >> 4;
+    return (TCGMemOp)(oi >> 4);
 }
 
 /**
@@ -1101,6 +1103,7 @@
 #define TB_EXIT_MASK 3
 #define TB_EXIT_IDX0 0
 #define TB_EXIT_IDX1 1
+#define TB_EXIT_ICOUNT_EXPIRED 2
 #define TB_EXIT_REQUESTED 3
 
 #ifdef HAVE_TCG_QEMU_TB_EXEC
@@ -1174,6 +1177,36 @@
 uint64_t helper_be_ldq_cmmu(CPUArchState *env, target_ulong addr,
                             TCGMemOpIdx oi, uintptr_t retaddr);
 
+/* PANDA versions */
+tcg_target_ulong helper_ret_ldub_mmu_panda(CPUArchState *env, target_ulong addr,
+                                     TCGMemOpIdx oi, uintptr_t retaddr);
+tcg_target_ulong helper_le_lduw_mmu_panda(CPUArchState *env, target_ulong addr,
+                                    TCGMemOpIdx oi, uintptr_t retaddr);
+tcg_target_ulong helper_le_ldul_mmu_panda(CPUArchState *env, target_ulong addr,
+                                    TCGMemOpIdx oi, uintptr_t retaddr);
+uint64_t helper_le_ldq_mmu_panda(CPUArchState *env, target_ulong addr,
+                           TCGMemOpIdx oi, uintptr_t retaddr);
+tcg_target_ulong helper_be_lduw_mmu_panda(CPUArchState *env, target_ulong addr,
+                                    TCGMemOpIdx oi, uintptr_t retaddr);
+tcg_target_ulong helper_be_ldul_mmu_panda(CPUArchState *env, target_ulong addr,
+                                    TCGMemOpIdx oi, uintptr_t retaddr);
+uint64_t helper_be_ldq_mmu_panda(CPUArchState *env, target_ulong addr,
+                           TCGMemOpIdx oi, uintptr_t retaddr);
+void helper_ret_stb_mmu_panda(CPUArchState *env, target_ulong addr, uint8_t val,
+                        TCGMemOpIdx oi, uintptr_t retaddr);
+void helper_le_stw_mmu_panda(CPUArchState *env, target_ulong addr, uint16_t val,
+                       TCGMemOpIdx oi, uintptr_t retaddr);
+void helper_le_stl_mmu_panda(CPUArchState *env, target_ulong addr, uint32_t val,
+                       TCGMemOpIdx oi, uintptr_t retaddr);
+void helper_le_stq_mmu_panda(CPUArchState *env, target_ulong addr, uint64_t val,
+                       TCGMemOpIdx oi, uintptr_t retaddr);
+void helper_be_stw_mmu_panda(CPUArchState *env, target_ulong addr, uint16_t val,
+                       TCGMemOpIdx oi, uintptr_t retaddr);
+void helper_be_stl_mmu_panda(CPUArchState *env, target_ulong addr, uint32_t val,
+                       TCGMemOpIdx oi, uintptr_t retaddr);
+void helper_be_stq_mmu_panda(CPUArchState *env, target_ulong addr, uint64_t val,
+                       TCGMemOpIdx oi, uintptr_t retaddr);
+
 /* Temporary aliases until backends are converted.  */
 #ifdef TARGET_WORDS_BIGENDIAN
 # define helper_ret_ldsw_mmu  helper_be_ldsw_mmu
diff -bur qemu-2.9.1/tests/libqtest.c panda/tests/libqtest.c
--- qemu-2.9.1/tests/libqtest.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/tests/libqtest.c	2019-12-05 17:27:34.667984390 -0500
@@ -611,7 +611,7 @@
     g_assert(qemu != NULL);
     const char *end = strrchr(qemu, '/');
 
-    return end + strlen("/qemu-system-");
+    return end + strlen("/panda-system-");
 }
 
 bool qtest_get_irq(QTestState *s, int num)
diff -bur qemu-2.9.1/tests/Makefile.include panda/tests/Makefile.include
--- qemu-2.9.1/tests/Makefile.include	2017-09-07 12:25:12.000000000 -0400
+++ panda/tests/Makefile.include	2019-12-05 17:27:34.659984390 -0500
@@ -214,7 +214,8 @@
 check-qtest-i386-y += tests/hd-geo-test$(EXESUF)
 gcov-files-i386-y += hw/block/hd-geometry.c
 check-qtest-i386-y += tests/boot-order-test$(EXESUF)
-check-qtest-i386-y += tests/bios-tables-test$(EXESUF)
+# PANDA: disable target qtests because KVM is required (disabled in Travis)
+# check-qtest-i386-y += tests/bios-tables-test$(EXESUF)
 check-qtest-i386-y += tests/boot-serial-test$(EXESUF)
 check-qtest-i386-y += tests/pxe-test$(EXESUF)
 check-qtest-i386-y += tests/rtc-test$(EXESUF)
@@ -258,7 +259,8 @@
 check-qtest-i386-y += tests/test-netfilter$(EXESUF)
 check-qtest-i386-y += tests/test-filter-mirror$(EXESUF)
 check-qtest-i386-y += tests/test-filter-redirector$(EXESUF)
-check-qtest-i386-y += tests/postcopy-test$(EXESUF)
+# PANDA: disable target qtests because KVM is required (disabled in Travis)
+# check-qtest-i386-y += tests/postcopy-test$(EXESUF)
 check-qtest-i386-y += tests/test-x86-cpuid-compat$(EXESUF)
 check-qtest-x86_64-y += $(check-qtest-i386-y)
 gcov-files-i386-y += i386-softmmu/hw/timer/mc146818rtc.c
@@ -813,7 +815,7 @@
 .PHONY: $(patsubst %, check-qtest-%, $(QTEST_TARGETS))
 $(patsubst %, check-qtest-%, $(QTEST_TARGETS)): check-qtest-%: $(check-qtest-y)
 	$(if $(CONFIG_GCOV),@rm -f *.gcda */*.gcda */*/*.gcda */*/*/*.gcda,)
-	$(call quiet-command,QTEST_QEMU_BINARY=$*-softmmu/qemu-system-$* \
+	$(call quiet-command,QTEST_QEMU_BINARY=$*-softmmu/panda-system-$* \
 		QTEST_QEMU_IMG=qemu-img$(EXESUF) \
 		MALLOC_PERTURB_=$${MALLOC_PERTURB_:-$$((RANDOM % 255 + 1))} \
 		gtester $(GTESTER_OPTIONS) -m=$(SPEED) $(check-qtest-$*-y) $(check-qtest-generic-y),"GTESTER","$@")
@@ -836,7 +838,7 @@
 # gtester tests with XML output
 
 $(patsubst %, check-report-qtest-%.xml, $(QTEST_TARGETS)): check-report-qtest-%.xml: $(check-qtest-y)
-	$(call quiet-command,QTEST_QEMU_BINARY=$*-softmmu/qemu-system-$* \
+	$(call quiet-command,QTEST_QEMU_BINARY=$*-softmmu/panda-system-$* \
 		QTEST_QEMU_IMG=qemu-img$(EXESUF) \
 	  gtester -q $(GTESTER_OPTIONS) -o $@ -m=$(SPEED) $(check-qtest-$*-y) $(check-qtest-generic-y),"GTESTER","$@")
 
diff -bur qemu-2.9.1/tests/qemu-iotests/check panda/tests/qemu-iotests/check
--- qemu-2.9.1/tests/qemu-iotests/check	2017-09-07 12:25:12.000000000 -0400
+++ panda/tests/qemu-iotests/check	2019-12-05 17:27:34.715984388 -0500
@@ -70,12 +70,12 @@
 then
     arch=$(uname -m 2> /dev/null)
 
-    if [[ -n $arch && -x "$build_root/$arch-softmmu/qemu-system-$arch" ]]
+    if [[ -n $arch && -x "$build_root/$arch-softmmu/panda-system-$arch" ]]
     then
-        export QEMU_PROG="$build_root/$arch-softmmu/qemu-system-$arch"
+        export QEMU_PROG="$build_root/$arch-softmmu/panda-system-$arch"
     else
         pushd "$build_root" > /dev/null
-        for binary in *-softmmu/qemu-system-*
+        for binary in *-softmmu/panda-system-*
         do
             if [ -x "$binary" ]
             then
diff -bur qemu-2.9.1/translate-all.c panda/translate-all.c
--- qemu-2.9.1/translate-all.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/translate-all.c	2019-12-12 11:07:05.660457299 -0500
@@ -16,6 +16,20 @@
  * You should have received a copy of the GNU Lesser General Public
  * License along with this library; if not, see <http://www.gnu.org/licenses/>.
  */
+
+/*
+ * The file was modified for S2E Selective Symbolic Execution Framework
+ *
+ * Copyright (c) 2010, Dependable Systems Laboratory, EPFL
+ *
+ * Currently maintained by:
+ *    Volodymyr Kuznetsov <vova.kuznetsov@epfl.ch>
+ *    Vitaly Chipounov <vitaly.chipounov@epfl.ch>
+ *
+ * All contributors are listed in S2E-AUTHORS file.
+ *
+ */
+
 #ifdef _WIN32
 #include <windows.h>
 #endif
@@ -55,10 +69,16 @@
 #include "translate-all.h"
 #include "qemu/bitmap.h"
 #include "qemu/timer.h"
-#include "qemu/main-loop.h"
 #include "exec/log.h"
 #include "sysemu/cpus.h"
 
+#ifdef CONFIG_LLVM
+#include "panda/tcg-llvm.h"
+#endif
+
+#include "panda/rr/rr_log.h"
+#include "panda/callbacks/cb-support.h"
+
 /* #define DEBUG_TB_INVALIDATE */
 /* #define DEBUG_TB_FLUSH */
 /* make various TB consistency checks */
@@ -294,6 +314,26 @@
 
     searched_pc -= GETPC_ADJ;
 
+    panda_callbacks_cpu_restore_state(ENV_GET_CPU(env), tb);
+
+#if defined(CONFIG_LLVM)
+    target_ulong guest_pc = cpu->panda_guest_pc;
+    if (execute_llvm) {
+        assert(guest_pc >= tb->pc);
+        assert(guest_pc < tb->pc + tb->size);
+        for (i = 0; i < num_insns; ++i) {
+            for (j = 0; j < TARGET_INSN_START_WORDS; ++j) {
+                data[j] += decode_sleb128(&p);
+            }
+            decode_sleb128(&p); // throw away value
+            if (data[0] >= guest_pc) {
+                goto found;
+            }
+        }
+        return -1;
+    }
+#endif
+
     if (searched_pc < host_pc) {
         return -1;
     }
@@ -838,6 +878,9 @@
     tb->pc = pc;
     tb->cflags = 0;
     tb->invalid = false;
+#ifdef CONFIG_LLVM
+    tcg_llvm_tb_alloc(tb);
+#endif
     return tb;
 }
 
@@ -852,6 +895,9 @@
     if (tcg_ctx.tb_ctx.nb_tbs > 0 &&
             tb == &tcg_ctx.tb_ctx.tbs[tcg_ctx.tb_ctx.nb_tbs - 1]) {
         tcg_ctx.code_gen_ptr = tb->tc_ptr;
+#if defined(CONFIG_LLVM)
+        tcg_llvm_tb_free(tb);
+#endif
         tcg_ctx.tb_ctx.nb_tbs--;
     }
 }
@@ -922,6 +968,13 @@
         cpu_abort(cpu, "Internal error: code buffer overflow\n");
     }
 
+#if defined(CONFIG_LLVM)
+    int i2;
+    for(i2 = 0; i2 < tcg_ctx.tb_ctx.nb_tbs; ++i2){
+        tcg_llvm_tb_free(&tcg_ctx.tb_ctx.tbs[i2]);
+    }
+#endif
+
     CPU_FOREACH(cpu) {
         int i;
 
@@ -1052,6 +1105,9 @@
 {
     uintptr_t addr = (uintptr_t)(tb->tc_ptr + tb->jmp_reset_offset[n]);
     tb_set_jmp_target(tb, n, addr);
+#ifdef CONFIG_LLVM
+    tb->llvm_tb_next[n] = NULL;
+#endif
 }
 
 /* remove any jumps to the TB */
@@ -1321,6 +1377,12 @@
        that should be required is to flush the TBs, allocate a new TB,
        re-initialize it per above, and re-do the actual code generation.  */
     gen_code_size = tcg_gen_code(&tcg_ctx, tb);
+
+#if defined(CONFIG_LLVM)
+    if (generate_llvm)
+        tcg_llvm_gen_code(tcg_llvm_ctx, &tcg_ctx, tb);
+#endif
+
     if (unlikely(gen_code_size < 0)) {
         goto buffer_overflow;
     }
@@ -1336,6 +1398,18 @@
     tcg_ctx.search_out_len += search_size;
 #endif
 
+#if defined(CONFIG_LLVM)
+    if(generate_llvm && qemu_loglevel_mask(CPU_LOG_LLVM_ASM)
+            && tb->llvm_tc_ptr) {
+        ptrdiff_t size = tb->llvm_tc_end - tb->llvm_tc_ptr;
+        qemu_log("OUT (LLVM ASM) [size=%ld] (%s)\n", size,
+                    tcg_llvm_get_func_name(tb));
+        log_disas((void*) tb->llvm_tc_ptr, size);
+        qemu_log("\n");
+        qemu_log_flush();
+    }
+#endif
+
 #ifdef DEBUG_DISAS
     if (qemu_loglevel_mask(CPU_LOG_TB_OUT_ASM) &&
         qemu_log_in_addr_range(tb->pc)) {
@@ -1348,6 +1422,25 @@
     }
 #endif
 
+#ifdef CONFIG_LLVM
+    // Sanity check. We had a bug before where we were misrecording
+    // translated code sizes, and so TC blocks appeared to overlap.
+    int i;
+    if (generate_llvm) {
+        for (i = 0; i < tcg_ctx.tb_ctx.nb_tbs; i++) {
+            TranslationBlock *other = &tcg_ctx.tb_ctx.tbs[i];
+            if (tb == other) continue;
+            if (other->llvm_tc_ptr <= tb->llvm_tc_ptr &&
+                    tb->llvm_tc_ptr < other->llvm_tc_end) {
+                assert(false && "Allocating apparently overlapping blocks!");
+            } else if (other->llvm_tc_ptr < tb->llvm_tc_end &&
+                    tb->llvm_tc_end <= other->llvm_tc_end) {
+                assert(false && "Allocating apparently overlapping blocks!");
+            }
+        }
+    }
+#endif
+
     tcg_ctx.code_gen_ptr = (void *)
         ROUND_UP((uintptr_t)gen_code_buf + gen_code_size + search_size,
                  CODE_GEN_ALIGN);
@@ -1493,11 +1586,17 @@
                 that the modification is after the current PC, but it
                 would require a specialized function to partially
                 restore the CPU state */
-
                 current_tb_modified = 1;
                 cpu_restore_state_from_tb(cpu, current_tb, cpu->mem_io_pc);
                 cpu_get_tb_cpu_state(env, &current_pc, &current_cs_base,
                                      &current_flags);
+
+                /* this is a hack, but probably a necessary one. fixes
+                double-counting when SMC occurs. long-term fix: count
+                BEFORE instr executes instead of after. */
+                if (rr_on()) {
+                    cpu->rr_guest_instr_count--;
+                }
             }
 #endif /* TARGET_HAS_PRECISE_SMC */
             tb_phys_invalidate(tb, -1);
@@ -1525,7 +1624,7 @@
 #ifdef CONFIG_SOFTMMU
 /* len must be <= 8 and start must be a multiple of len.
  * Called via softmmu_template.h when code areas are written to with
- * iothread mutex not held.
+ * tb_lock held.
  */
 void tb_invalidate_phys_page_fast(tb_page_addr_t start, int len)
 {
@@ -1657,6 +1756,29 @@
     if (tcg_ctx.tb_ctx.nb_tbs <= 0) {
         return NULL;
     }
+
+#ifdef CONFIG_LLVM
+    if (execute_llvm) {
+        /* first check last tb. optimization for coming from generated code. */
+        tb = tcg_llvm_runtime.last_tb;
+        if (tb && tb->llvm_function
+                && tc_ptr >= (uintptr_t)tb->llvm_tc_ptr
+                && tc_ptr <  (uintptr_t)tb->llvm_tc_end) {
+            return tb;
+        }
+        /* then do linear search. */
+        for (m = 0; m < tcg_ctx.tb_ctx.nb_tbs; m++) {
+            tb = &tcg_ctx.tb_ctx.tbs[m];
+            if (tb->llvm_function
+                    && tc_ptr >= (uintptr_t)tb->llvm_tc_ptr
+                    && tc_ptr <  (uintptr_t)tb->llvm_tc_end) {
+                return tb;
+            }
+        }
+        return NULL;
+    }
+#endif
+
     if (tc_ptr < (uintptr_t)tcg_ctx.code_gen_buffer ||
         tc_ptr >= (uintptr_t)tcg_ctx.code_gen_ptr) {
         return NULL;
@@ -1727,10 +1849,7 @@
 
 #ifndef CONFIG_USER_ONLY
 /* in deterministic execution mode, instructions doing device I/Os
- * must be at the end of the TB.
- *
- * Called by softmmu_template.h, with iothread mutex not held.
- */
+   must be at the end of the TB */
 void cpu_io_recompile(CPUState *cpu, uintptr_t retaddr)
 {
 #if defined(TARGET_MIPS) || defined(TARGET_SH4)
@@ -1942,9 +2061,8 @@
 
 void cpu_interrupt(CPUState *cpu, int mask)
 {
-    g_assert(qemu_mutex_iothread_locked());
     cpu->interrupt_request |= mask;
-    cpu->icount_decr.u16.high = -1;
+    cpu->tcg_exit_req = 1;
 }
 
 /*
diff -bur qemu-2.9.1/translate-common.c panda/translate-common.c
--- qemu-2.9.1/translate-common.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/translate-common.c	2019-12-05 17:27:34.747984386 -0500
@@ -21,7 +21,6 @@
 #include "qemu-common.h"
 #include "qom/cpu.h"
 #include "sysemu/cpus.h"
-#include "qemu/main-loop.h"
 
 uintptr_t qemu_real_host_page_size;
 intptr_t qemu_real_host_page_mask;
@@ -31,7 +30,6 @@
 static void tcg_handle_interrupt(CPUState *cpu, int mask)
 {
     int old_mask;
-    g_assert(qemu_mutex_iothread_locked());
 
     old_mask = cpu->interrupt_request;
     cpu->interrupt_request |= mask;
@@ -42,13 +40,17 @@
      */
     if (!qemu_cpu_is_self(cpu)) {
         qemu_cpu_kick(cpu);
-    } else {
-        cpu->icount_decr.u16.high = -1;
-        if (use_icount &&
-            !cpu->can_do_io
+        return;
+    }
+
+    if (use_icount) {
+        cpu->icount_decr.u16.high = 0xffff;
+        if (!cpu->can_do_io
             && (mask & ~old_mask) != 0) {
             cpu_abort(cpu, "Raised interrupt while not in I/O function");
         }
+    } else {
+        cpu->tcg_exit_req = 1;
     }
 }
 
diff -bur qemu-2.9.1/.travis.yml panda/.travis.yml
--- qemu-2.9.1/.travis.yml	2017-09-07 12:25:12.000000000 -0400
+++ panda/.travis.yml	2020-01-22 10:59:21.890782321 -0500
@@ -1,24 +1,38 @@
-sudo: false
+# The current Travis default is a VM based 16.04 Xenial on GCE
+dist: xenial
 language: c
-python:
-  - "2.4"
 compiler:
   - gcc
-cache: ccache
+cache:
+  # There is one cache per branch and compiler version.
+  timeout: 1200
+  ccache: true
+  pip: true
+  directories:
+  - $HOME/avocado/data/cache
+
+
 addons:
   apt:
+    sources:
+      # up to ubuntu xenial, we can use the ppa name
+      - sourceline: 'ppa:phulin/panda'
+      # the ppa doesn't support later ubuntu releases -- specify url instead
+      #- sourceline: 'deb http://ppa.launchpad.net/phulin/panda/ubuntu xenial main'
     packages:
       # Build dependencies
       - libaio-dev
       - libattr1-dev
       - libbrlapi-dev
+      - libcap-dev
       - libcap-ng-dev
+      - libgcc-4.8-dev
       - libgnutls-dev
       - libgtk-3-dev
       - libiscsi-dev
       - liblttng-ust-dev
-      - libnfs-dev
       - libncurses5-dev
+      - libnfs-dev
       - libnss3-dev
       - libpixman-1-dev
       - libpng12-dev
@@ -27,171 +41,84 @@
       - libseccomp-dev
       - libspice-protocol-dev
       - libspice-server-dev
-      - libssh2-1-dev
+      - libssh-dev
       - liburcu-dev
       - libusb-1.0-0-dev
-      - libvte-2.90-dev
+      - libvte-2.91-dev
       - sparse
       - uuid-dev
+      # PANDA stuff
+      - bison
+      - flex
+      - linux-libc-dev
+      - libcapstone-dev
+      - libdwarf-dev
+      - libelf-dev
+      - libprotobuf-c0-dev
+      - libprotoc-dev
+      - libwireshark-dev
+      - libwiretap-dev
+      - llvm-3.3-dev
+      - clang-3.3
+      - protobuf-c-compiler
+      - protobuf-compiler
+      - python-pip
+      - python-protobuf
+      - python-pycparser
+      # PYPANDA stuff
+      - python3
+      - python3-pip
+      - python3-venv
+      - python3-setuptools
+      - genisoimage # To make isos for run_guest
+      - wget
+      # To build 32-bit targets for testing
+      - libc6-dev-i386
+      - gcc-multilib
+      - nasm
 
-# The channel name "irc.oftc.net#qemu" is encrypted against qemu/qemu
-# to prevent IRC notifications from forks. This was created using:
-# $ travis encrypt -r "qemu/qemu" "irc.oftc.net#qemu"
-notifications:
-  irc:
-    channels:
-      - secure: "F7GDRgjuOo5IUyRLqSkmDL7kvdU4UcH3Lm/W2db2JnDHTGCqgEdaYEYKciyCLZ57vOTsTsOgesN8iUT7hNHBd1KWKjZe9KDTZWppWRYVwAwQMzVeSOsbbU4tRoJ6Pp+3qhH1Z0eGYR9ZgKYAoTumDFgSAYRp4IscKS8jkoedOqM="
-    on_success: change
-    on_failure: always
+# PANDA
+sudo: required
+dist: xenial
 env:
   global:
-    - TEST_CMD="make check"
-  matrix:
-    - CONFIG=""
-    - CONFIG="--enable-debug --enable-debug-tcg --enable-trace-backends=log"
-    - CONFIG="--disable-linux-aio --disable-cap-ng --disable-attr --disable-brlapi --disable-uuid --disable-libusb"
-    - CONFIG="--enable-modules"
-    - CONFIG="--with-coroutine=ucontext"
-    - CONFIG="--with-coroutine=sigaltstack"
+    - PANDA_TEST="no" # These tests aren't too useful and timeout travis. They passed locally as of 2ce657c
 git:
-  # we want to do this ourselves
+  # we want to do this ourselves for some reason
   submodules: false
+
 before_install:
-  - if [ "$TRAVIS_OS_NAME" == "osx" ]; then brew update ; fi
-  - if [ "$TRAVIS_OS_NAME" == "osx" ]; then brew install libffi gettext glib pixman ; fi
-  - wget -O - http://people.linaro.org/~alex.bennee/qemu-submodule-git-seed.tar.xz | tar -xvJ
-  - git submodule update --init --recursive
+  - sudo pip install pycparser cffi colorama protobuf # pycparser is a core dependency, rest are for pypanda
+  - git submodule update --init dtc
+  - cd $(pyenv root) && git checkout master && git pull; cd - # Update pyenv
+  - echo 'core_%e.%p' | sudo tee /proc/sys/kernel/core_pattern # Store coredumps locally
 before_script:
-  - ./configure ${CONFIG}
+  - ulimit -c unlimited -S       # enable core dumps
+  # Setup python environment with pyenv (python2 and python3)
+  - pyenv install 2.7.9 || travis_terminate 1; # For core qemu
+  - pyenv install 3.6.6 || travis_terminate 1; # For pypanda
+  - pyenv shell 2.7.9 3.6.6 || travis_terminate 1; # Create a shell with both python2 and python3
+  - pip3 install cffi colorama protobuf # PYPANDA dependencies - not auto installed by setup because we don't use pip to install pypanda
+
 script:
-  - make -j3 && ${TEST_CMD}
-matrix:
-  include:
-    # Test with CLang for compile portability
-    - env: CONFIG=""
-      compiler: clang
-    # gprof/gcov are GCC features
-    - env: CONFIG="--enable-gprof --enable-gcov --disable-pie"
-      compiler: gcc
-    # We manually include builds which we disable "make check" for
-    - env: CONFIG="--enable-debug --enable-tcg-interpreter"
-           TEST_CMD=""
-      compiler: gcc
-    - env: CONFIG="--enable-trace-backends=simple"
-           TEST_CMD=""
-      compiler: gcc
-    - env: CONFIG="--enable-trace-backends=ftrace"
-           TEST_CMD=""
-      compiler: gcc
-    - env: CONFIG="--enable-trace-backends=ust"
-           TEST_CMD=""
-      compiler: gcc
-    - env: CONFIG="--with-coroutine=gthread"
-           TEST_CMD=""
-      compiler: gcc
-    - env: CONFIG=""
-      os: osx
-      compiler: clang
-    # Plain Trusty System Build
-    - env: CONFIG="--disable-linux-user"
-      sudo: required
-      addons:
-      dist: trusty
-      compiler: gcc
-      before_install:
-        - sudo apt-get update -qq
-        - sudo apt-get build-dep -qq qemu
-        - wget -O - http://people.linaro.org/~alex.bennee/qemu-submodule-git-seed.tar.xz | tar -xvJ
-        - git submodule update --init --recursive
-    # Plain Trusty Linux User Build
-    - env: CONFIG="--disable-system"
-      sudo: required
-      addons:
-      dist: trusty
-      compiler: gcc
-      before_install:
-        - sudo apt-get update -qq
-        - sudo apt-get build-dep -qq qemu
-        - wget -O - http://people.linaro.org/~alex.bennee/qemu-submodule-git-seed.tar.xz | tar -xvJ
-        - git submodule update --init --recursive
-    # Trusty System build with latest stable clang
-    - sudo: required
-      addons:
-      dist: trusty
-      language: generic
-      compiler: none
-      env:
-        - COMPILER_NAME=clang CXX=clang++-3.9 CC=clang-3.9
-        - CONFIG="--disable-linux-user --cc=clang-3.9 --cxx=clang++-3.9"
-      before_install:
-        - wget -nv -O - http://llvm.org/apt/llvm-snapshot.gpg.key | sudo apt-key add -
-        - sudo apt-add-repository -y 'deb http://llvm.org/apt/trusty llvm-toolchain-trusty-3.9 main'
-        - sudo apt-get update -qq
-        - sudo apt-get install -qq -y clang-3.9
-        - sudo apt-get build-dep -qq qemu
-        - wget -O - http://people.linaro.org/~alex.bennee/qemu-submodule-git-seed.tar.xz | tar -xvJ
-        - git submodule update --init --recursive
-      before_script:
-        - ./configure ${CONFIG} || cat config.log
-    # Trusty Linux User build with latest stable clang
-    - sudo: required
-      addons:
-      dist: trusty
-      language: generic
-      compiler: none
-      env:
-        - COMPILER_NAME=clang CXX=clang++-3.9 CC=clang-3.9
-        - CONFIG="--disable-system --cc=clang-3.9 --cxx=clang++-3.9"
-      before_install:
-        - wget -nv -O - http://llvm.org/apt/llvm-snapshot.gpg.key | sudo apt-key add -
-        - sudo apt-add-repository -y 'deb http://llvm.org/apt/trusty llvm-toolchain-trusty-3.9 main'
-        - sudo apt-get update -qq
-        - sudo apt-get install -qq -y clang-3.9
-        - sudo apt-get build-dep -qq qemu
-        - wget -O - http://people.linaro.org/~alex.bennee/qemu-submodule-git-seed.tar.xz | tar -xvJ
-        - git submodule update --init --recursive
-      before_script:
-        - ./configure ${CONFIG} || cat config.log
-    # Using newer GCC with sanitizers
-    - addons:
-        apt:
-          sources:
-            # PPAs for newer toolchains
-            - ubuntu-toolchain-r-test
-          packages:
-            # Extra toolchains
-            - gcc-5
-            - g++-5
-            # Build dependencies
-            - libaio-dev
-            - libattr1-dev
-            - libbrlapi-dev
-            - libcap-ng-dev
-            - libgnutls-dev
-            - libgtk-3-dev
-            - libiscsi-dev
-            - liblttng-ust-dev
-            - libnfs-dev
-            - libncurses5-dev
-            - libnss3-dev
-            - libpixman-1-dev
-            - libpng12-dev
-            - librados-dev
-            - libsdl1.2-dev
-            - libseccomp-dev
-            - libspice-protocol-dev
-            - libspice-server-dev
-            - libssh2-1-dev
-            - liburcu-dev
-            - libusb-1.0-0-dev
-            - libvte-2.90-dev
-            - sparse
-            - uuid-dev
-      language: generic
-      compiler: none
-      env:
-        - COMPILER_NAME=gcc CXX=g++-5 CC=gcc-5
-        - CONFIG="--cc=gcc-5 --cxx=g++-5 --disable-pie --disable-linux-user --with-coroutine=gthread"
-        - TEST_CMD=""
-      before_script:
-        - ./configure ${CONFIG} --extra-cflags="-g3 -O0 -fsanitize=thread -fuse-ld=gold" || cat config.log
+  # Run install script
+  - sudo panda/scripts/install_ubuntu.sh || travis_terminate 1; # Build panda
+  # Install pypanda
+  - cd panda/pypanda
+  - python3 setup.py install || travis_terminate 1
+  # Run pypanda tests
+  - cd tests
+  - make || travis_terminate 1
+  - pip3 install -r requirements.txt || travis_terminate 1 # Install test python dependencies (capstone, pyelftools)
+  - python3 multi_proc_cbs.py
+  - python3 taint_reg.py
+  - python3 taint_ram.py
+  # Run record_then_replay on multiple architectures
+  - python3 record_then_replay.py i386
+  - python3 record_then_replay.py x86_64
+  - python3 record_then_replay.py arm
+  - python3 record_then_replay.py ppc
+  # Test hooking framework
+  - python3 hooking.py
+  # Regression tests
+  - python3 sleep_in_cb.py
diff -bur qemu-2.9.1/ui/cocoa.m panda/ui/cocoa.m
--- qemu-2.9.1/ui/cocoa.m	2017-09-07 12:25:12.000000000 -0400
+++ panda/ui/cocoa.m	2019-12-05 17:27:34.747984386 -0500
@@ -34,6 +34,7 @@
 #include "qmp-commands.h"
 #include "sysemu/blockdev.h"
 #include "qemu-version.h"
+#include "panda/rr/rr_log_all.h"
 #include <Carbon/Carbon.h>
 
 #ifndef MAC_OS_X_VERSION_10_5
@@ -244,6 +245,7 @@
     BOOL isFullscreen;
     BOOL isAbsoluteEnabled;
     BOOL isMouseDeassociated;
+    @public BOOL isRecording;
 }
 - (void) switchSurface:(DisplaySurface *)surface;
 - (void) grabMouse;
@@ -455,8 +457,7 @@
         [[fullScreenWindow contentView] setFrame:[[NSScreen mainScreen] frame]];
         [normalWindow setFrame:NSMakeRect([normalWindow frame].origin.x, [normalWindow frame].origin.y - h + oldh, w, h + [normalWindow frame].size.height - oldh) display:NO animate:NO];
     } else {
-        if (qemu_name)
-            [normalWindow setTitle:[NSString stringWithFormat:@"QEMU %s", qemu_name]];
+        [self setQEMUTitle];
         [normalWindow setFrame:NSMakeRect([normalWindow frame].origin.x, [normalWindow frame].origin.y - h + oldh, w, h + [normalWindow frame].size.height - oldh) display:YES animate:NO];
     }
 
@@ -734,40 +735,41 @@
     }
 }
 
+- (void) setQEMUTitle
+{
+    if (!isFullscreen) {
+        [normalWindow setTitle:[NSString stringWithFormat:@"PANDA QEMU%s%s%s%s",
+            qemu_name ? " " : "",
+            qemu_name ? qemu_name : "",
+            isMouseGrabbed ? " - (Press ctrl + alt to release Mouse) " : "",
+            isRecording ? " (recording)" : ""]];
+    }
+}
+
 - (void) grabMouse
 {
     COCOA_DEBUG("QemuCocoaView: grabMouse\n");
 
-    if (!isFullscreen) {
-        if (qemu_name)
-            [normalWindow setTitle:[NSString stringWithFormat:@"QEMU %s - (Press ctrl + alt to release Mouse)", qemu_name]];
-        else
-            [normalWindow setTitle:@"QEMU - (Press ctrl + alt to release Mouse)"];
-    }
     [self hideCursor];
     if (!isAbsoluteEnabled) {
         isMouseDeassociated = TRUE;
         CGAssociateMouseAndMouseCursorPosition(FALSE);
     }
     isMouseGrabbed = TRUE; // while isMouseGrabbed = TRUE, QemuCocoaApp sends all events to [cocoaView handleEvent:]
+    [self setQEMUTitle];
 }
 
 - (void) ungrabMouse
 {
     COCOA_DEBUG("QemuCocoaView: ungrabMouse\n");
 
-    if (!isFullscreen) {
-        if (qemu_name)
-            [normalWindow setTitle:[NSString stringWithFormat:@"QEMU %s", qemu_name]];
-        else
-            [normalWindow setTitle:@"QEMU"];
-    }
     [self unhideCursor];
     if (isMouseDeassociated) {
         CGAssociateMouseAndMouseCursorPosition(TRUE);
         isMouseDeassociated = FALSE;
     }
     isMouseGrabbed = FALSE;
+    [self setQEMUTitle];
 }
 
 - (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled {isAbsoluteEnabled = tIsAbsoluteEnabled;}
@@ -828,6 +830,8 @@
 - (void)openDocumentation:(NSString *)filename;
 - (IBAction) do_about_menu_item: (id) sender;
 - (void)make_about_window;
+- (void)beginRecord:(id)sender;
+- (void)endRecord:(id)sender;
 @end
 
 @implementation QemuCocoaAppController
@@ -854,7 +858,7 @@
             exit(1);
         }
         [normalWindow setAcceptsMouseMovedEvents:YES];
-        [normalWindow setTitle:@"QEMU"];
+        [normalWindow setTitle:@"PANDA QEMU"];
         [normalWindow setContentView:cocoaView];
 #if (MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_10)
         [normalWindow useOptimizedDrawing:YES];
@@ -1063,6 +1067,42 @@
     qmp_system_powerdown(NULL);
 }
 
+/* Begins a PANDA recording */
+- (void)beginRecord:(id)sender
+{
+    /* Display the file open dialog */
+    NSSavePanel * savePanel;
+    savePanel = [NSSavePanel savePanel];
+    [savePanel setCanCreateDirectories: YES];
+    [savePanel setTitle: @"Create Recording"];
+    if([savePanel runModal] == NSFileHandlingPanelOKButton) {
+        NSString * file = [[savePanel URL] path];
+        if(file == nil) {
+            NSBeep();
+            QEMU_Alert(@"Failed to convert URL to file path!");
+            return;
+        }
+
+        Error *err = NULL;
+        qmp_begin_record([file cStringUsingEncoding: NSASCIIStringEncoding], &err);
+        [sender setEnabled: NO];
+        [[[sender menu] itemWithTitle: @"End Record"] setEnabled: YES];
+        cocoaView->isRecording = YES;
+        [cocoaView setQEMUTitle];
+    }
+}
+
+/* Begins a PANDA replay */
+- (void)endRecord:(id)sender
+{
+    Error *err = NULL;
+    qmp_end_record(&err);
+    [sender setEnabled: NO];
+    [[[sender menu] itemWithTitle: @"Begin Record"] setEnabled: YES];
+    cocoaView->isRecording = NO;
+    [cocoaView setQEMUTitle];
+}
+
 /* Ejects the media.
  * Uses sender's tag to figure out the device to eject.
  */
@@ -1258,6 +1298,7 @@
                 !strcmp(opt, "-version") ||
                 !strcmp(opt, "-curses") ||
                 !strcmp(opt, "-display") ||
+                !strcmp(opt, "-replay") ||
                 !strcmp(opt, "-qtest")) {
                 return qemu_main(gArgc, gArgv, *_NSGetEnviron());
             }
@@ -1304,6 +1345,22 @@
     [menu addItem: [NSMenuItem separatorItem]];
     [menu addItem: [[[NSMenuItem alloc] initWithTitle: @"Reset" action: @selector(restartQEMU:) keyEquivalent: @""] autorelease]];
     [menu addItem: [[[NSMenuItem alloc] initWithTitle: @"Power Down" action: @selector(powerDownQEMU:) keyEquivalent: @""] autorelease]];
+    [menu addItem: [NSMenuItem separatorItem]];
+    menuItem = [[[NSMenuItem alloc]
+            initWithTitle: @"Begin Record"
+            action: @selector(beginRecord:)
+            keyEquivalent: @"r"]
+        autorelease];
+    [menu addItem: menuItem];
+    [menuItem setKeyEquivalentModifierMask: NSCommandKeyMask];
+    menuItem = [[[NSMenuItem alloc]
+            initWithTitle: @"End Record"
+            action: @selector(endRecord:)
+            keyEquivalent: @"r"]
+        autorelease];
+    [menu addItem: menuItem];
+    [menuItem setKeyEquivalentModifierMask: NSShiftKeyMask | NSCommandKeyMask];
+    [menuItem setEnabled: NO];
     menuItem = [[[NSMenuItem alloc] initWithTitle: @"Machine" action:nil keyEquivalent:@""] autorelease];
     [menuItem setSubmenu:menu];
     [[NSApp mainMenu] addItem:menuItem];
diff -bur qemu-2.9.1/ui/console.c panda/ui/console.c
--- qemu-2.9.1/ui/console.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/ui/console.c	2019-12-05 17:27:34.747984386 -0500
@@ -1576,22 +1576,19 @@
 }
 
 /*
- * Safe DPY refresh for TCG guests. We use the exclusive mechanism to
- * ensure the TCG vCPUs are quiescent so we can avoid races between
- * dirty page tracking for direct frame-buffer access by the guest.
+ * Safe DPY refresh for TCG guests. This runs when the TCG vCPUs are
+ * quiescent so we can avoid races between dirty page tracking for
+ * direct frame-buffer access by the guest.
  *
  * This is a temporary stopgap until we've fixed the dirty tracking
  * races in display adapters.
  */
-static void do_safe_dpy_refresh(DisplayChangeListener *dcl)
+static void do_safe_dpy_refresh(CPUState *cpu, run_on_cpu_data opaque)
 {
-    qemu_mutex_unlock_iothread();
-    start_exclusive();
+    DisplayChangeListener *dcl = opaque.host_ptr;
     qemu_mutex_lock_iothread();
     dcl->ops->dpy_refresh(dcl);
     qemu_mutex_unlock_iothread();
-    end_exclusive();
-    qemu_mutex_lock_iothread();
 }
 
 static void dpy_refresh(DisplayState *s)
@@ -1601,7 +1598,8 @@
     QLIST_FOREACH(dcl, &s->listeners, next) {
         if (dcl->ops->dpy_refresh) {
             if (tcg_enabled()) {
-                do_safe_dpy_refresh(dcl);
+                async_safe_run_on_cpu(first_cpu, do_safe_dpy_refresh,
+                                      RUN_ON_CPU_HOST_PTR(dcl));
             } else {
                 dcl->ops->dpy_refresh(dcl);
             }
diff -bur qemu-2.9.1/util/log.c panda/util/log.c
--- qemu-2.9.1/util/log.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/util/log.c	2019-12-05 17:27:34.755984386 -0500
@@ -17,6 +17,19 @@
  * License along with this library; if not, see <http://www.gnu.org/licenses/>.
  */
 
+/*
+ * The file was modified for S2E Selective Symbolic Execution Framework
+ *
+ * Copyright (c) 2010, Dependable Systems Laboratory, EPFL
+ *
+ * Currently maintained by:
+ *    Volodymyr Kuznetsov <vova.kuznetsov@epfl.ch>
+ *    Vitaly Chipounov <vitaly.chipounov@epfl.ch>
+ *
+ * All contributors are listed in S2E-AUTHORS file.
+ *
+ */
+
 #include "qemu/osdep.h"
 #include "qemu-common.h"
 #include "qemu/log.h"
@@ -272,6 +285,16 @@
     { CPU_LOG_TB_NOCHAIN, "nochain",
       "do not chain compiled TBs so that \"exec\" and \"cpu\" show\n"
       "complete traces" },
+#ifdef CONFIG_LLVM
+    { CPU_LOG_LLVM_IR, "llvm_ir",
+      "show generated LLVM IR code" },
+    { CPU_LOG_LLVM_ASM, "llvm_asm",
+      "show LLVM-generated assembly code" },
+    { CPU_LOG_TAINT_OPS, "taint_ops",
+      "show taint ops for each llvm bb", },
+#endif
+    { CPU_LOG_RR, "rr",
+        "record/replay program points" },
     { 0, NULL, NULL },
 };
 
diff -bur qemu-2.9.1/util/main-loop.c panda/util/main-loop.c
--- qemu-2.9.1/util/main-loop.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/util/main-loop.c	2019-12-12 11:07:05.660457299 -0500
@@ -32,6 +32,7 @@
 #include "slirp/libslirp.h"
 #include "qemu/main-loop.h"
 #include "block/aio.h"
+#include "panda/rr/rr_log_all.h"
 
 #ifndef _WIN32
 
@@ -210,7 +211,9 @@
     GPollFD *pfds = &g_array_index(gpollfds, GPollFD, glib_pollfds_idx);
 
     if (g_main_context_check(context, max_priority, pfds, glib_n_poll_fds)) {
+        rr_begin_main_loop_wait();
         g_main_context_dispatch(context);
+        rr_end_main_loop_wait();
     }
 }
 
@@ -226,6 +229,7 @@
 
     glib_pollfds_fill(&timeout);
 
+
     /* If the I/O thread is very busy or we are incorrectly busy waiting in
      * the I/O thread, this can lead to starvation of the BQL such that the
      * VCPU threads never run.  To make sure we can detect the later case,
@@ -257,8 +261,9 @@
     if (timeout) {
         qemu_mutex_lock_iothread();
     }
-
+    rr_begin_main_loop_wait();
     glib_pollfds_poll();
+    rr_end_main_loop_wait();
 
     g_main_context_release(context);
 
@@ -487,13 +492,20 @@
 }
 #endif
 
+
+#define RR_MAIN_WAIT_LOOP_TIMEOUT_IN_REPLAY 1000
+
+
 int main_loop_wait(int nonblocking)
 {
     int ret;
     uint32_t timeout = UINT32_MAX;
     int64_t timeout_ns;
 
-    if (nonblocking) {
+    if (rr_in_replay()) {
+        timeout = RR_MAIN_WAIT_LOOP_TIMEOUT_IN_REPLAY;
+    }
+    else if (nonblocking) {
         timeout = 0;
     }
 
@@ -501,7 +513,9 @@
     g_array_set_size(gpollfds, 0); /* reset for new iteration */
     /* XXX: separate device handlers from system ones */
 #ifdef CONFIG_SLIRP
+    if (! (rr_in_replay() || rr_replay_requested())) {
     slirp_pollfds_fill(gpollfds, &timeout);
+    }
 #endif
 
     if (timeout == UINT32_MAX) {
@@ -515,14 +529,19 @@
                                           &main_loop_tlg));
 
     ret = os_host_main_loop_wait(timeout_ns);
+
 #ifdef CONFIG_SLIRP
+    rr_begin_main_loop_wait();
     slirp_pollfds_poll(gpollfds, (ret < 0));
+    rr_end_main_loop_wait();
 #endif
 
     /* CPU thread can infinitely wait for event after
        missing the warp */
     qemu_start_warp_timer();
+    rr_begin_main_loop_wait();
     qemu_clock_run_all_timers();
+    rr_end_main_loop_wait();
 
     return ret;
 }
diff -bur qemu-2.9.1/util/memfd.c panda/util/memfd.c
--- qemu-2.9.1/util/memfd.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/util/memfd.c	2019-12-05 17:27:34.755984386 -0500
@@ -31,9 +31,7 @@
 
 #include "qemu/memfd.h"
 
-#ifdef CONFIG_MEMFD
-#include <sys/memfd.h>
-#elif defined CONFIG_LINUX
+#if defined CONFIG_LINUX && !defined CONFIG_MEMFD
 #include <sys/syscall.h>
 #include <asm/unistd.h>
 
diff -bur qemu-2.9.1/util/qemu-timer.c panda/util/qemu-timer.c
--- qemu-2.9.1/util/qemu-timer.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/util/qemu-timer.c	2019-12-12 11:07:05.660457299 -0500
@@ -29,6 +29,10 @@
 #include "sysemu/sysemu.h"
 #include "sysemu/cpus.h"
 
+#ifdef CONFIG_SOFTMMU
+#include "panda/rr/rr_log_all.h"
+#endif
+
 #ifdef CONFIG_POSIX
 #include <pthread.h>
 #endif
@@ -41,6 +45,8 @@
 #include <sys/prctl.h>
 #endif
 
+#define RR_REPLAY_DEADLINE 1000000 /* one millisecond. */
+
 /***********************************************************/
 /* timers */
 
@@ -579,6 +585,11 @@
     int64_t deadline = -1;
     QEMUClockType type;
     bool play = replay_mode == REPLAY_MODE_PLAY;
+
+#ifdef CONFIG_SOFTMMU
+    if (rr_in_replay() || rr_replay_requested()) return RR_REPLAY_DEADLINE;
+#endif
+
     for (type = 0; type < QEMU_CLOCK_MAX; type++) {
         if (qemu_clock_use_for_deadline(type)) {
             if (!play || type == QEMU_CLOCK_REALTIME) {
@@ -658,10 +669,33 @@
     QEMUClockType type;
 
     for (type = 0; type < QEMU_CLOCK_MAX; type++) {
-        if (qemu_clock_use_for_deadline(type)) {
             progress |= qemu_clock_run_timers(type);
         }
-    }
 
     return progress;
 }
+
+static bool debug = false;
+// ru: function to stop timers in timerlist
+static void qemu_clock_stop_timers(QEMUClockType type)
+{
+    QEMUTimerList *timer_list;
+    QEMUClock *clock = qemu_clock_ptr(type);
+    QLIST_FOREACH(timer_list, &clock->timerlists, list) {
+        while (timer_list->active_timers) {
+            if (debug)
+                printf("Deleting timerlist for QEMUClockType: %d\n", type);
+            timer_del(timer_list->active_timers);
+        }
+    }
+    return;
+}
+// ru: function to stop all timers for every clock
+void qemu_rr_quit_timers(void)
+{
+    QEMUClockType type;
+
+    for (type = 0; type < QEMU_CLOCK_MAX; type++) {
+        qemu_clock_stop_timers(type);
+    }
+}
diff -bur qemu-2.9.1/vl.c panda/vl.c
--- qemu-2.9.1/vl.c	2017-09-07 12:25:12.000000000 -0400
+++ panda/vl.c	2020-01-22 10:59:21.906782755 -0500
@@ -21,11 +21,27 @@
  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  * THE SOFTWARE.
  */
+
+/*
+ * The file was modified for S2E Selective Symbolic Execution Framework
+ *
+ * Copyright (c) 2010, Dependable Systems Laboratory, EPFL
+ *
+ * Currently maintained by:
+ *    Volodymyr Kuznetsov <vova.kuznetsov@epfl.ch>
+ *    Vitaly Chipounov <vitaly.chipounov@epfl.ch>
+ *
+ * All contributors are listed in S2E-AUTHORS file.
+ *
+ */
+
 #include "qemu/osdep.h"
 #include "qemu-version.h"
 #include "qemu/cutils.h"
 #include "qemu/help_option.h"
 #include "qemu/uuid.h"
+#include <unistd.h>
+#include <glib.h>
 
 #ifdef CONFIG_SECCOMP
 #include "sysemu/seccomp.h"
@@ -111,7 +127,6 @@
 
 #include "disas/disas.h"
 
-
 #include "slirp/libslirp.h"
 
 #include "trace-root.h"
@@ -130,6 +145,44 @@
 #include "qapi/qmp/qerror.h"
 #include "sysemu/iothread.h"
 
+#include "vl.h"
+
+extern void panda_cleanup(void);
+extern bool panda_add_arg(const char *, const char *);
+extern bool panda_load_plugin(const char *, const char *);
+extern void panda_unload_plugins(void);
+extern char *panda_plugin_path(const char *name);
+extern void panda_set_os_name(char *os_name);
+extern void panda_callbacks_after_machine_init(CPUState *);
+extern void panda_callbacks_pre_shutdown(void);
+extern void panda_callbacks_main_loop_wait(void);
+extern void pandalog_cc_init_write(const char * fname);
+
+int pandalog = 0;
+int panda_in_main_loop = 0;
+extern bool panda_abort_requested; // When set, we exit in after printing a help message
+bool panda_break_vl_loop_req = false; // When set, we break the main loop in vl.c
+bool panda_library_mode = false; // Set if using panda from python
+bool panda_aborted = false; // Set if panda was terminated abnormally (e.g., Ctrl-C)
+
+char *panda_snap_name = NULL;
+const char* replay_name = NULL;
+
+#include "panda/debug.h"
+#include "panda/rr/rr_log_all.h"
+
+#ifdef CONFIG_LLVM
+struct TCGLLVMContext;
+
+extern struct TCGLLVMContext* tcg_llvm_ctx;
+extern int generate_llvm;
+extern int execute_llvm;
+extern const int has_llvm_engine;
+
+void tcg_llvm_initialize(void);
+void tcg_llvm_destroy(void);
+#endif
+
 #define MAX_VIRTIO_CONSOLES 1
 #define MAX_SCLP_CONSOLES 1
 
@@ -1634,6 +1687,7 @@
              * avoiding printing an odd message in that case.
              */
             error_report("terminating on signal %d", shutdown_signal);
+            panda_aborted = true;
         } else {
             char *shutdown_cmd = qemu_get_pid_name(shutdown_pid);
 
@@ -1851,7 +1905,12 @@
     if (qemu_suspend_requested()) {
         qemu_system_suspend();
     }
+    if (panda_break_vl_loop_req) {
+      panda_break_vl_loop_req = false; // Only break the loop once
+      return true;
+    }
     if (qemu_shutdown_requested()) {
+        panda_callbacks_pre_shutdown();
         qemu_kill_report();
         qapi_event_send_shutdown(&error_abort);
         if (no_shutdown) {
@@ -1886,16 +1945,76 @@
     return false;
 }
 
-static void main_loop(void)
+#ifdef CONFIG_LLVM
+static void tcg_llvm_cleanup(void)
 {
+    if(tcg_llvm_ctx) {
+        tcg_llvm_destroy();
+        tcg_llvm_ctx = NULL;
+    }
+}
+#endif
+
+void main_loop(void)
+{
+    bool nonblocking;
+    int last_io = 0;
 #ifdef CONFIG_PROFILER
     int64_t ti;
 #endif
     do {
+        nonblocking = tcg_enabled() && last_io > 0;
 #ifdef CONFIG_PROFILER
         ti = profile_getclock();
 #endif
-        main_loop_wait(false);
+        last_io = main_loop_wait(nonblocking);
+        panda_callbacks_main_loop_wait();
+
+        // rr: check for begin/end record/replay
+        sigset_t blockset, oldset;
+
+        // create a signal set containing just ALARM and USR2
+        sigemptyset(&blockset);
+        sigaddset(&blockset, SIGALRM);
+        sigaddset(&blockset, SIGUSR2);
+        sigaddset(&blockset, SIGIO);
+
+	if (likely(rr_control.next == RR_NOCHANGE)) {
+	    // nop
+	} else if (unlikely(rr_control.next == RR_RECORD)) {
+            //block signals
+            sigprocmask(SIG_BLOCK, &blockset, &oldset);
+            rr_do_begin_record(rr_control.name, first_cpu);
+            rr_control.next = RR_NOCHANGE;
+            //unblock signals
+            sigprocmask(SIG_SETMASK, &oldset, NULL);
+        } else if (unlikely(rr_control.next == RR_REPLAY)) {
+            //block signals
+            sigprocmask(SIG_BLOCK, &blockset, &oldset);
+            if (0 != rr_do_begin_replay(rr_control.name, first_cpu)){
+                printf("Failed to start replay\n");
+                exit(1);
+            } else { // we have to unblock signals, so we can't just continue on failure
+                qemu_rr_quit_timers();
+                rr_control.next = RR_NOCHANGE;
+            }
+            //unblock signals
+            sigprocmask(SIG_SETMASK, &oldset, NULL);
+        } else if (unlikely((rr_control.next == RR_OFF) && rr_in_record())) {
+	    //mz 05.2012 We have the global mutex here, so this should be OK.
+            rr_do_end_record();
+            rr_reset_state(first_cpu);
+            rr_control.next = RR_NOCHANGE;
+            vm_start();
+        } else if (unlikely((rr_control.next == RR_OFF) && rr_in_replay())) {
+            //mz restore timers
+            qemu_clock_run_all_timers();
+            //mz FIXME this is used in the monitor for do_stop()??
+            rr_do_end_replay(/*is_error=*/0);
+            rr_control.next = RR_NOCHANGE;
+            vm_stop(RUN_STATE_PAUSED);
+        }
+
 #ifdef CONFIG_PROFILER
         dev_time += profile_getclock() - ti;
 #endif
@@ -1905,6 +2024,7 @@
 static void version(void)
 {
     printf("QEMU emulator version " QEMU_VERSION QEMU_PKGVERSION "\n"
+            "Build date " __DATE__ "\n"
            QEMU_COPYRIGHT "\n");
 }
 
@@ -2913,6 +3033,12 @@
     loc_pop(&loc);
 }
 
+const char *qemu_file = NULL;
+
+// bdg: This is Tim's fault
+char **gargv;
+int gargc;
+
 static int global_init_func(void *opaque, QemuOpts *opts, Error **errp)
 {
     GlobalProperty *g;
@@ -2939,8 +3065,37 @@
     return 0;
 }
 
-int main(int argc, char **argv, char **envp)
-{
+// Panda stuff
+
+/** Obtains the full path to the current executable */
+static char* this_executable_path(const char* argv0){
+    char buf[PATH_MAX] = {0};
+
+    // readlink method, linux only
+    // should fail at runtime on other posix-compatible systems
+    ssize_t size = readlink("/proc/self/exe", buf, sizeof(buf));
+    if (size > 0 && size < sizeof(buf)) {
+        return strdup(buf);
+    }
+
+    // fallback method (only works when the executable is run directly)
+    return realpath(argv0, NULL);
+}
+
+void main_panda_run(void) {
+    panda_in_main_loop = 1;
+    main_loop();
+    panda_in_main_loop = 0;
+}
+
+void set_replay_name(char *name) {
+    replay_name = name;
+}
+
+int main_aux(int argc, char **argv, char **envp, PandaMainMode pmm)
+ {
+    if (pmm == PANDA_RUN)    goto PANDA_MAIN_RUN;
+    if (pmm == PANDA_FINISH) goto PANDA_MAIN_FINISH;
     int i;
     int snapshot, linux_boot;
     const char *initrd_filename;
@@ -2984,6 +3139,21 @@
     QSIMPLEQ_HEAD(, BlockdevOptions_queue) bdo_queue
         = QSIMPLEQ_HEAD_INITIALIZER(bdo_queue);
 
+    // PANDA stuff
+    gargv = argv;
+    gargc = argc;
+    if (pmm == PANDA_NORMAL)
+        qemu_file = this_executable_path(argv[0]);
+    else
+        qemu_file = strdup(argv[0]);
+    assert(qemu_file != NULL);
+
+    const char* record_name = NULL;
+    // In order to load PANDA plugins all at once at the end
+    const char * panda_plugin_files[64] = {};
+    const char * panda_plugin_names[64] = {};
+    int nb_panda_plugins = 0;
+
     module_call_init(MODULE_INIT_TRACE);
 
     qemu_init_cpu_list();
@@ -4043,6 +4213,101 @@
                     exit(1);
                 }
                 break;
+#if defined(CONFIG_LLVM)
+            case QEMU_OPTION_execute_llvm:
+                if (!has_llvm_engine) {
+                    fprintf(stderr, "Cannot execute in LLVM mode (S2E mode present or LLVM mode missing)\n");
+                    exit(1);
+                }
+                generate_llvm = 1;
+                execute_llvm = 1;
+                break;
+            case QEMU_OPTION_generate_llvm:
+                if (!has_llvm_engine) {
+                    fprintf(stderr, "Cannot execute in LLVM mode (S2E mode present or LLVM mode missing)\n");
+                    exit(1);
+                }
+                generate_llvm = 1;
+                break;
+#endif
+            case QEMU_OPTION_replay:
+                display_type = DT_NONE;
+                replay_name = optarg;
+                break;
+            case QEMU_OPTION_pandalog:
+                pandalog = 1;
+                pandalog_cc_init_write(optarg);
+                printf ("pandalogging to [%s]\n", optarg);
+                break;
+            case QEMU_OPTION_record_from:
+                record_name = optarg;
+                break;
+            case QEMU_OPTION_panda_arg:
+                // panda_add_arg() currently always return true
+                assert(panda_add_arg(NULL, optarg));
+                break;
+            case QEMU_OPTION_panda_plugin:
+                panda_plugin_files[nb_panda_plugins] = optarg;
+                panda_plugin_names[nb_panda_plugins] = NULL;
+                nb_panda_plugins++;
+                break;
+            case QEMU_OPTION_panda_plugins:
+                {
+                    char *new_optarg = strdup(optarg);
+                    char *plugin_start = new_optarg;
+                    char *plugin_end = new_optarg;
+
+                    while (plugin_end != NULL) {
+                        plugin_end = strchr(plugin_start, ';');
+                        if (plugin_end != NULL) *plugin_end = '\0';
+
+                        char *opt_list;
+                        if ((opt_list = strchr(plugin_start, ':'))) {
+                            *opt_list = '\0';
+                            opt_list++;
+
+                            char *opt_start = opt_list, *opt_end = opt_list;
+                            while (opt_end != NULL) {
+                                opt_end = strchr(opt_start, ',');
+                                if (opt_end != NULL) *opt_end = '\0';
+
+                                // panda_add_arg() currently always return true
+                                assert(panda_add_arg(plugin_start, opt_start));
+                                fprintf(stderr, PANDA_MSG_FMT "adding argument %s.\n", plugin_start, opt_start);
+
+                                opt_start = opt_end + 1;
+                            }
+                        }
+
+                        if (0 == strcmp("general", plugin_start)) {
+                            // not really a plugin -- just used to collect general panda args
+                        }
+                        else {
+                            char *plugin_path = panda_plugin_path((const char *) plugin_start);
+                            if (NULL == plugin_path) {
+                                fprintf(stderr,
+                                        PANDA_MSG_FMT
+                                        "Failed to resolve path for plugin.\n",
+                                        plugin_start);
+                                abort();
+                            }
+                            panda_plugin_files[nb_panda_plugins] = plugin_path;
+                            panda_plugin_names[nb_panda_plugins] = strdup(plugin_start);
+                            nb_panda_plugins++;
+                        }
+
+                        plugin_start = plugin_end + 1;
+                    }
+                    free(new_optarg);
+                    break;
+                }
+            case QEMU_OPTION_panda_os_name:
+            {
+                char *os_name = strdup(optarg);
+                // NB: this will complain if we provide an os name that panda doesnt know about
+                panda_set_os_name(os_name);
+                break;
+            }
             default:
                 os_parse_cmd_args(popt->index, optarg);
             }
@@ -4054,6 +4319,21 @@
      */
     loc_set_none();
 
+    // Now that all arguments are available, we can load plugins
+    int pp_idx;
+    for (pp_idx = 0; pp_idx < nb_panda_plugins; pp_idx++) {
+      if(!panda_load_plugin(panda_plugin_files[pp_idx], panda_plugin_names[pp_idx])) {
+          fprintf(stderr, "FAIL: Unable to load plugin `%s'\n", panda_plugin_files[pp_idx]);
+          abort();
+      }
+    }
+
+    // This is to support having a help option in the plugins. If
+    // someone asked for help on a plugin, we don't want to start
+    // anything else.
+    if (panda_abort_requested)
+        exit(0);
+
     replay_configure(icount_opts);
 
     machine_class = select_machine();
@@ -4158,6 +4438,14 @@
         data_dir[data_dir_idx++] = CONFIG_QEMU_DATADIR;
     }
 
+#if defined(CONFIG_LLVM)
+    if (generate_llvm || execute_llvm){
+        if (tcg_llvm_ctx == NULL){
+	    tcg_llvm_initialize();
+        }
+    }
+#endif
+
     /* -L help lists the data directories and exits. */
     if (list_data_dirs) {
         for (i = 0; i < data_dir_idx; i++) {
@@ -4682,6 +4970,61 @@
     replay_checkpoint(CHECKPOINT_RESET);
     qemu_system_reset(VMRESET_SILENT);
     register_global_state();
+
+    if (replay_name) {
+        // rr: check for begin/end record/replay
+        sigset_t blockset, oldset = {0};
+
+        //block signals
+        sigprocmask(SIG_BLOCK, &blockset, &oldset);
+        if (0 != rr_do_begin_replay(replay_name, first_cpu)){
+            printf("Failed to start replay\n");
+            exit(1);
+        }
+        // ru: qemu_quit_timers() defined by PANDA team to stop timers
+        qemu_rr_quit_timers();
+
+        //unblock signals
+        sigprocmask(SIG_SETMASK, &oldset, NULL);
+    }
+
+    if (record_name) {
+        Error *err;
+        char snap_name[256];
+        char rec_name[256];
+        // None of QEMU's built-in parsers seem to be able to do something this simple
+        int s_i = 0;
+        int r_i = 0;
+        int full_i = 0;
+
+        while(record_name[full_i] != '\0'){
+            if (':' == record_name[full_i]){
+                snap_name[s_i] = '\0';
+                s_i = -1;
+                full_i++;
+                continue;
+            }
+            if (s_i < 0){
+                rec_name[r_i++] = record_name[full_i++];
+            } else {
+                snap_name[s_i++] = record_name[full_i++];
+            }
+            if (s_i >= 256 || r_i >= 256){
+                // BAIL BAIL BAIL
+                fprintf(stderr,"snapshots and recordings must have names no longer than 256 characters\n");
+                exit(1);
+            }
+            rec_name[r_i] = '\0';
+        }
+
+        if(*rec_name == '\0'){
+            fprintf(stderr, "missing record name, usage: -record-from <snapshot>:<record-name>\n");
+            exit(1);
+        }
+
+        qmp_begin_record_from(snap_name,rec_name, &err);
+    }
+
     if (replay_mode != REPLAY_MODE_NONE) {
         replay_vmstate_init();
     } else if (loadvm) {
@@ -4710,10 +5053,31 @@
 
     os_setup_post();
 
+    // Call PANDA post-machine init hook
+    panda_callbacks_after_machine_init(first_cpu);
+
+    if (pmm == PANDA_INIT) return 0;
+
+PANDA_MAIN_RUN:
+    
+
+    panda_in_main_loop = 1;
     main_loop();
+    panda_in_main_loop = 0;
+
+    if (pmm == PANDA_RUN) return 0;
+
+PANDA_MAIN_FINISH:
+
+    if(rr_in_record()){
+        rr_do_end_record();
+    }
+
     replay_disable_events();
     iothread_stop_all();
 
+    panda_cleanup();
+
     pause_all_vcpus();
     bdrv_close_all();
     res_free();
@@ -4724,5 +5088,13 @@
     monitor_cleanup();
     qemu_chr_cleanup();
 
+#ifdef CONFIG_LLVM
+    if (generate_llvm || execute_llvm){
+        tcg_llvm_cleanup();
+    }
+#endif
+
+    free((void*)qemu_file);
+
     return 0;
 }
Only in panda: vl.h
